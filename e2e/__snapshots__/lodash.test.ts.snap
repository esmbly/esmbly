// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/Hash.ts 1`] = `
"/** Used to stand-in for \`undefined\` hash values. */
const HASH_UNDEFINED = '__lodash_hash_undefined__'

class Hash {

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  constructor(entries) {
    let index = -1
    const length = entries == null ? 0 : entries.length

    this.clear()
    while (++index < length) {
      const entry = entries[index]
      this.set(entry[0], entry[1])
    }
  }

  /**
   * Removes all key-value entries from the hash.
   *
   * @memberOf Hash
   */
  clear() {
    this.__data__ = Object.create(null)
    this.size = 0
  }

  /**
   * Removes \`key\` and its value from the hash.
   *
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns \`true\` if the entry was removed, else \`false\`.
   */
  delete(key) {
    const result = this.has(key) && delete this.__data__[key]
    this.size -= result ? 1 : 0
    return result
  }

  /**
   * Gets the hash value for \`key\`.
   *
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  get(key) {
    const data = this.__data__
    const result = data[key]
    return result === HASH_UNDEFINED ? undefined : result
  }

  /**
   * Checks if a hash value for \`key\` exists.
   *
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns \`true\` if an entry for \`key\` exists, else \`false\`.
   */
  has(key) {
    const data = this.__data__
    return data[key] !== undefined
  }

  /**
   * Sets the hash \`key\` to \`value\`.
   *
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  set(key, value) {
    const data = this.__data__
    this.size += this.has(key) ? 0 : 1
    data[key] = value === undefined ? HASH_UNDEFINED : value
    return this
  }
}

export default Hash
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/ListCache.ts 1`] = `
"import assocIndexOf from './assocIndexOf.js'

class ListCache {

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  constructor(entries) {
    let index = -1
    const length = entries == null ? 0 : entries.length

    this.clear()
    while (++index < length) {
      const entry = entries[index]
      this.set(entry[0], entry[1])
    }
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @memberOf ListCache
   */
  clear() {
    this.__data__ = []
    this.size = 0
  }

  /**
   * Removes \`key\` and its value from the list cache.
   *
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns \`true\` if the entry was removed, else \`false\`.
   */
  delete(key) {
    const data = this.__data__
    const index = assocIndexOf(data, key)

    if (index < 0) {
      return false
    }
    const lastIndex = data.length - 1
    if (index == lastIndex) {
      data.pop()
    } else {
      data.splice(index, 1)
    }
    --this.size
    return true
  }

  /**
   * Gets the list cache value for \`key\`.
   *
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  get(key) {
    const data = this.__data__
    const index = assocIndexOf(data, key)
    return index < 0 ? undefined : data[index][1]
  }

  /**
   * Checks if a list cache value for \`key\` exists.
   *
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns \`true\` if an entry for \`key\` exists, else \`false\`.
   */
  has(key) {
    return assocIndexOf(this.__data__, key) > -1
  }

  /**
   * Sets the list cache \`key\` to \`value\`.
   *
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  set(key, value) {
    const data = this.__data__
    const index = assocIndexOf(data, key)

    if (index < 0) {
      ++this.size
      data.push([key, value])
    } else {
      data[index][1] = value
    }
    return this
  }
}

export default ListCache
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/MapCache.ts 1`] = `
"
import Hash from './Hash.js'

/**
 * Gets the data for \`map\`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(
  {
    __data__
  }: Object,
  key: string
): any {
  const data = __data__
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map
}

/**
 * Checks if \`value\` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is suitable, else \`false\`.
 */
function isKeyable(value: any): boolean {
  const type = typeof value
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null)
}

class MapCache {

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  constructor(entries) {
    let index = -1
    const length = entries == null ? 0 : entries.length

    this.clear()
    while (++index < length) {
      const entry = entries[index]
      this.set(entry[0], entry[1])
    }
  }

  /**
   * Removes all key-value entries from the map.
   *
   * @memberOf MapCache
   */
  clear() {
    this.size = 0
    this.__data__ = {
      'hash': new Hash,
      'map': new Map,
      'string': new Hash
    }
  }

  /**
   * Removes \`key\` and its value from the map.
   *
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns \`true\` if the entry was removed, else \`false\`.
   */
  delete(key) {
    const result = getMapData(this, key)['delete'](key)
    this.size -= result ? 1 : 0
    return result
  }

  /**
   * Gets the map value for \`key\`.
   *
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  get(key) {
    return getMapData(this, key).get(key)
  }

  /**
   * Checks if a map value for \`key\` exists.
   *
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns \`true\` if an entry for \`key\` exists, else \`false\`.
   */
  has(key) {
    return getMapData(this, key).has(key)
  }

  /**
   * Sets the map \`key\` to \`value\`.
   *
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  set(key, value) {
    const data = getMapData(this, key)
    const size = data.size

    data.set(key, value)
    this.size += data.size == size ? 0 : 1
    return this
  }
}

export default MapCache
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/SetCache.ts 1`] = `
"import MapCache from './MapCache.js'

/** Used to stand-in for \`undefined\` hash values. */
const HASH_UNDEFINED = '__lodash_hash_undefined__'

class SetCache {

  /**
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  constructor(values) {
    let index = -1
    const length = values == null ? 0 : values.length

    this.__data__ = new MapCache
    while (++index < length) {
      this.add(values[index])
    }
  }

  /**
   * Adds \`value\` to the array cache.
   *
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  add(value) {
    this.__data__.set(value, HASH_UNDEFINED)
    return this
  }

  /**
   * Checks if \`value\` is in the array cache.
   *
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns \`true\` if \`value\` is found, else \`false\`.
   */
  has(value) {
    return this.__data__.has(value)
  }
}

SetCache.prototype.push = SetCache.prototype.add

export default SetCache
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/Stack.ts 1`] = `
"import ListCache from './ListCache.js'
import MapCache from './MapCache.js'

/** Used as the size to enable large array optimizations. */
const LARGE_ARRAY_SIZE = 200

class Stack {

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  constructor(entries) {
    const data = this.__data__ = new ListCache(entries)
    this.size = data.size
  }

  /**
   * Removes all key-value entries from the stack.
   *
   * @memberOf Stack
   */
  clear() {
    this.__data__ = new ListCache
    this.size = 0
  }

  /**
   * Removes \`key\` and its value from the stack.
   *
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns \`true\` if the entry was removed, else \`false\`.
   */
  delete(key) {
    const data = this.__data__
    const result = data['delete'](key)

    this.size = data.size
    return result
  }

  /**
   * Gets the stack value for \`key\`.
   *
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  get(key) {
    return this.__data__.get(key)
  }

  /**
   * Checks if a stack value for \`key\` exists.
   *
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns \`true\` if an entry for \`key\` exists, else \`false\`.
   */
  has(key) {
    return this.__data__.has(key)
  }

  /**
   * Sets the stack \`key\` to \`value\`.
   *
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  set(key, value) {
    let data = this.__data__
    if (data instanceof ListCache) {
      const pairs = data.__data__
      if (pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value])
        this.size = ++data.size
        return this
      }
      data = this.__data__ = new MapCache(pairs)
    }
    data.set(key, value)
    this.size = data.size
    return this
  }
}

export default Stack
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/addMapEntry.ts 1`] = `
"/**
 * Adds the key-value \`pair\` to \`map\`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns \`map\`.
 */
function addMapEntry(map: Object, pair: any[]): Object {
  // Don't return \`map.set\` because it's not chainable in IE 11.
  map.set(pair[0], pair[1])
  return map
}

export default addMapEntry
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/addSetEntry.ts 1`] = `
"/**
 * Adds \`value\` to \`set\`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns \`set\`.
 */
function addSetEntry(set: Object, value: any): Object {
  // Don't return \`set.add\` because it's not chainable in IE 11.
  set.add(value)
  return set
}

export default addSetEntry
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/arrayEach.ts 1`] = `
"/**
 * A specialized version of \`forEach\` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns \`array\`.
 */
function arrayEach(array: any[], iteratee: Function): any[] {
  let index = -1
  const length = array.length

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break
    }
  }
  return array
}

export default arrayEach
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/arrayEachRight.ts 1`] = `
"/**
 * A specialized version of \`forEachRight\` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns \`array\`.
 */
function arrayEachRight(array: any[], iteratee: Function): any[] {
  let length = array == null ? 0 : array.length

  while (length--) {
    if (iteratee(array[length], length, array) === false) {
      break
    }
  }
  return array
}

export default arrayEachRight
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/arrayIncludes.ts 1`] = `
"import baseIndexOf from './baseIndexOf.js'

/**
 * A specialized version of \`includes\` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns \`true\` if \`target\` is found, else \`false\`.
 */
function arrayIncludes(array: any[], value: any): boolean {
  const length = array == null ? 0 : array.length
  return !!length && baseIndexOf(array, value, 0) > -1
}

export default arrayIncludes
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/arrayIncludesWith.ts 1`] = `
"/**
 * This function is like \`arrayIncludes\` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns \`true\` if \`target\` is found, else \`false\`.
 */
function arrayIncludesWith(array: any[], target: any, comparator: Function): boolean {
  if (array == null) {
    return false
  }

  for (const value of array) {
    if (comparator(target, value)) {
      return true
    }
  }
  return false
}

export default arrayIncludesWith
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/arrayLikeKeys.ts 1`] = `
"import isArguments from '../isArguments.js'
import isBuffer from '../isBuffer.js'
import isIndex from './isIndex.js'
import isTypedArray from '../isTypedArray.js'

/** Used to check objects for own properties. */
const hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Creates an array of the enumerable property names of the array-like \`value\`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value: any, inherited: boolean): any[] {
  const isArr = Array.isArray(value)
  const isArg = !isArr && isArguments(value)
  const isBuff = !isArr && !isArg && isBuffer(value)
  const isType = !isArr && !isArg && !isBuff && isTypedArray(value)
  const skipIndexes = isArr || isArg || isBuff || isType
  const length = value.length
  const result = new Array(skipIndexes ? length : 0)
  let index = skipIndexes ? -1 : length
  while (++index < length) {
    result[index] = \`\${index}\`
  }
  for (const key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable \`arguments.length\` in strict mode.
           (key == 'length' ||
           // Skip index properties.
           isIndex(key, length))
        ))) {
      result.push(key)
    }
  }
  return result
}

export default arrayLikeKeys
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/arrayReduce.ts 1`] = `
"/**
 * A specialized version of \`reduce\` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of \`array\` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array: any[], iteratee: Function, accumulator: any, initAccum: boolean): any {
  let index = -1
  const length = array == null ? 0 : array.length

  if (initAccum && length) {
    accumulator = array[++index]
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array)
  }
  return accumulator
}

export default arrayReduce
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/arrayReduceRight.ts 1`] = `
"/**
 * A specialized version of \`reduceRight\` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the last element of \`array\` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduceRight(array: any[], iteratee: Function, accumulator: any, initAccum: boolean): any {
  let length = array == null ? 0 : array.length
  if (initAccum && length) {
    accumulator = array[--length]
  }
  while (length--) {
    accumulator = iteratee(accumulator, array[length], length, array)
  }
  return accumulator
}

export default arrayReduceRight
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/asciiSize.ts 1`] = `
"/**
 * Gets the size of an ASCII \`string\`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
function asciiSize(
 {
  length
 }: string
): number {
  return length
}

export default asciiSize
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/asciiToArray.ts 1`] = `
"/**
 * Converts an ASCII \`string\` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string: string): any[] {
  return string.split('')
}

export default asciiToArray
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/assignMergeValue.ts 1`] = `
"import baseAssignValue from './baseAssignValue.js'
import eq from '../eq.js'

/**
 * This function is like \`assignValue\` except that it doesn't assign
 * \`undefined\` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object: Object, key: string, value: any) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value)
  }
}

export default assignMergeValue
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/assignValue.ts 1`] = `
"import baseAssignValue from './baseAssignValue.js'
import eq from '../eq.js'

/** Used to check objects for own properties. */
const hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Assigns \`value\` to \`key\` of \`object\` if the existing value is not equivalent.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object: Object, key: string, value: any) {
  const objValue = object[key]

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value))) {
    if (value !== 0 || (1 / value) == (1 / objValue)) {
      baseAssignValue(object, key, value)
    }
  } else if (value === undefined && !(key in object)) {
    baseAssignValue(object, key, value)
  }
}

export default assignValue
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/assocIndexOf.ts 1`] = `
"import eq from '../eq.js'

/**
 * Gets the index at which the \`key\` is found in \`array\` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 */
function assocIndexOf(array: any[], key: any): number {
  let { length } = array
  while (length--) {
    if (eq(array[length][0], key)) {
      return length
    }
  }
  return -1
}

export default assocIndexOf
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseAssignValue.ts 1`] = `
"/**
 * The base implementation of \`assignValue\` and \`assignMergeValue\` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object: Object, key: string, value: any) {
  if (key == '__proto__') {
    Object.defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    })
  } else {
    object[key] = value
  }
}

export default baseAssignValue
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseAt.ts 1`] = `
"import get from '../get.js'

/**
 * The base implementation of \`at\` without support for individual paths.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {string[]} paths The property paths to pick.
 * @returns {Array} Returns the picked elements.
 */
function baseAt(object: Object, paths: string[]): any[] {
  let index = -1
  const length = paths.length
  const result = new Array(length)
  const skip = object == null

  while (++index < length) {
    result[index] = skip ? undefined : get(object, paths[index])
  }
  return result
}

export default baseAt
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseClone.ts 1`] = `
"import Stack from './Stack.js'
import arrayEach from './arrayEach.js'
import assignValue from './assignValue.js'
import cloneBuffer from './cloneBuffer.js'
import copyArray from './copyArray.js'
import copyObject from './copyObject.js'
import cloneArrayBuffer from './cloneArrayBuffer.js'
import cloneDataView from './cloneDataView.js'
import cloneRegExp from './cloneRegExp.js'
import cloneSymbol from './cloneSymbol.js'
import cloneTypedArray from './cloneTypedArray.js'
import copySymbols from './copySymbols.js'
import copySymbolsIn from './copySymbolsIn.js'
import getAllKeys from './getAllKeys.js'
import getAllKeysIn from './getAllKeysIn.js'
import getTag from './getTag.js'
import initCloneObject from './initCloneObject.js'
import isBuffer from '../isBuffer.js'
import isObject from '../isObject.js'
import keys from '../keys.js'
import keysIn from '../keysIn.js'

/** Used to compose bitmasks for cloning. */
const CLONE_DEEP_FLAG = 1
const CLONE_FLAT_FLAG = 2
const CLONE_SYMBOLS_FLAG = 4

/** \`Object#toString\` result references. */
const argsTag = '[object Arguments]'
const arrayTag = '[object Array]'
const boolTag = '[object Boolean]'
const dateTag = '[object Date]'
const errorTag = '[object Error]'
const mapTag = '[object Map]'
const numberTag = '[object Number]'
const objectTag = '[object Object]'
const regexpTag = '[object RegExp]'
const setTag = '[object Set]'
const stringTag = '[object String]'
const symbolTag = '[object Symbol]'
const weakMapTag = '[object WeakMap]'

const arrayBufferTag = '[object ArrayBuffer]'
const dataViewTag = '[object DataView]'
const float32Tag = '[object Float32Array]'
const float64Tag = '[object Float64Array]'
const int8Tag = '[object Int8Array]'
const int16Tag = '[object Int16Array]'
const int32Tag = '[object Int32Array]'
const uint8Tag = '[object Uint8Array]'
const uint8ClampedTag = '[object Uint8ClampedArray]'
const uint16Tag = '[object Uint16Array]'
const uint32Tag = '[object Uint32Array]'

/** Used to identify \`toStringTag\` values supported by \`clone\`. */
const cloneableTags = {}
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true
cloneableTags[errorTag] = cloneableTags[weakMapTag] = false

/** Used to check objects for own properties. */
const hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Initializes an object clone based on its \`toStringTag\`.
 *
 * **Note:** This function only supports cloning values with tags of
 * \`Boolean\`, \`Date\`, \`Error\`, \`Map\`, \`Number\`, \`RegExp\`, \`Set\`, or \`String\`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The \`toStringTag\` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object: Object, tag: string, isDeep: boolean): Object {
  const Ctor = object.constructor
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object)

    case boolTag:
    case dateTag:
      return new Ctor(+object)

    case dataViewTag:
      return cloneDataView(object, isDeep)

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep)

    case mapTag:
      return new Ctor

    case numberTag:
    case stringTag:
      return new Ctor(object)

    case regexpTag:
      return cloneRegExp(object)

    case setTag:
      return new Ctor

    case symbolTag:
      return cloneSymbol(object)
  }
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array: any[]): any[] {
  const { length } = array
  const result = new array.constructor(length)

  // Add properties assigned by \`RegExp#exec\`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index
    result.input = array.input
  }
  return result
}

/**
 * The base implementation of \`clone\` and \`cloneDeep\` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {number} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of \`value\`.
 * @param {Object} [object] The parent object of \`value\`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(
  value: any,
  bitmask: number,
  customizer: Function,
  key: string,
  object: Object,
  stack: Object
): any {
  let result
  const isDeep = bitmask & CLONE_DEEP_FLAG
  const isFlat = bitmask & CLONE_FLAT_FLAG
  const isFull = bitmask & CLONE_SYMBOLS_FLAG

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value)
  }
  if (result !== undefined) {
    return result
  }
  if (!isObject(value)) {
    return value
  }
  const isArr = Array.isArray(value)
  const tag = getTag(value)
  if (isArr) {
    result = initCloneArray(value)
    if (!isDeep) {
      return copyArray(value, result)
    }
  } else {
    const isFunc = typeof value == 'function'

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep)
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value)
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, copyObject(value, keysIn(value), result))
          : copySymbols(value, Object.assign(result, value))
      }
    } else {
      if (isFunc || !cloneableTags[tag]) {
        return object ? value : {}
      }
      result = initCloneByTag(value, tag, isDeep)
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack)
  const stacked = stack.get(value)
  if (stacked) {
    return stacked
  }
  stack.set(value, result)

  if (tag == mapTag) {
    value.forEach((subValue, key) => {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))
    })
    return result
  }

  if (tag == setTag) {
    value.forEach((subValue) => {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))
    })
    return result
  }

  if (isTypedArray(value)) {
    return result
  }

  const keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys)

  const props = isArr ? undefined : keysFunc(value)
  arrayEach(props || value, (subValue, key) => {
    if (props) {
      key = subValue
      subValue = value[key]
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))
  })
  return result
}

export default baseClone
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseConforms.ts 1`] = `
"import baseConformsTo from './baseConformsTo.js'
import keys from '../keys.js'

/**
 * The base implementation of \`conforms\` which doesn't clone \`source\`.
 *
 * @private
 * @param {Object} source The object of property predicates to conform to.
 * @returns {Function} Returns the new spec function.
 */
function baseConforms(source: Object): Function {
  const props = keys(source)
  return (object) => baseConformsTo(object, source, props)
}

export default baseConforms
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseConformsTo.ts 1`] = `
"/**
 * The base implementation of \`conformsTo\` which accepts \`props\` to check.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property predicates to conform to.
 * @returns {boolean} Returns \`true\` if \`object\` conforms, else \`false\`.
 */
function baseConformsTo(object: Object, source: Object, props: any): boolean {
  let length = props.length
  if (object == null) {
    return !length
  }
  object = Object(object)
  while (length--) {
    const key = props[length]
    const predicate = source[key]
    const value = object[key]

    if ((value === undefined && !(key in object)) || !predicate(value)) {
      return false
    }
  }
  return true
}

export default baseConformsTo
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseDifference.ts 1`] = `
"import SetCache from './SetCache.js'
import arrayIncludes from './arrayIncludes.js'
import arrayIncludesWith from './arrayIncludesWith.js'
import map from '../map.js'
import cacheHas from './cacheHas.js'

/** Used as the size to enable large array optimizations. */
const LARGE_ARRAY_SIZE = 200

/**
 * The base implementation of methods like \`difference\` without support
 * for excluding multiple arrays.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array: any[], values: any[], iteratee: Function, comparator: Function): any[] {
  let includes = arrayIncludes
  let isCommon = true
  const result = []
  const valuesLength = values.length

  if (!array.length) {
    return result
  }
  if (iteratee) {
    values = map(values, (value) => iteratee(value))
  }
  if (comparator) {
    includes = arrayIncludesWith
    isCommon = false
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas
    isCommon = false
    values = new SetCache(values)
  }
  outer:
  for (let value of array) {
    const computed = iteratee == null ? value : iteratee(value)

    value = (comparator || value !== 0) ? value : 0
    if (isCommon && computed === computed) {
      let valuesIndex = valuesLength
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer
        }
      }
      result.push(value)
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value)
    }
  }
  return result
}

export default baseDifference
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseEach.ts 1`] = `
"import baseForOwn from './baseForOwn.js'
import isArrayLike from '../isArrayLike.js'

/**
 * The base implementation of \`forEach\`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns \`collection\`.
 */
function baseEach(collection: any[] | Object, iteratee: Function): any[] | Object {
  if (collection == null) {
    return collection
  }
  if (!isArrayLike(collection)) {
    return baseForOwn(collection, iteratee)
  }
  const length = collection.length
  const iterable = Object(collection)
  let index = -1

  while (++index < length) {
    if (iteratee(iterable[index], index, iterable) === false) {
      break
    }
  }
  return collection
}

export default baseEach
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseEachRight.ts 1`] = `
"import baseForOwnRight from './baseForOwnRight.js'
import isArrayLike from '../isArrayLike.js'

/**
 * The base implementation of \`forEachRight\`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns \`collection\`.
 */
function baseEachRight(collection: any[] | Object, iteratee: Function): any[] | Object {
  if (collection == null) {
    return collection
  }
  if (!isArrayLike(collection)) {
    return baseForOwnRight(collection, iteratee)
  }
  const iterable = Object(collection)
  let length = collection.length

  while (length--) {
    if (iteratee(iterable[length], length, iterable) === false) {
      break
    }
  }
  return collection
}

export default baseEachRight
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseFindIndex.ts 1`] = `
"/**
 * The base implementation of \`findIndex\` and \`findLastIndex\`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 */
function baseFindIndex(array: any[], predicate: Function, fromIndex: number, fromRight: boolean): number {
  const { length } = array
  let index = fromIndex + (fromRight ? 1 : -1)

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index
    }
  }
  return -1
}

export default baseFindIndex
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseFindKey.ts 1`] = `
"/**
 * The base implementation of methods like \`findKey\` and \`findLastKey\`
 * which iterates over \`collection\` using \`eachFunc\`.
 *
 * @private
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {Function} eachFunc The function to iterate over \`collection\`.
 * @returns {*} Returns the found element or its key, else \`undefined\`.
 */
function baseFindKey(collection: any[] | Object, predicate: Function, eachFunc: Function): any {
  let result
  eachFunc(collection, (value, key, collection) => {
    if (predicate(value, key, collection)) {
      result = key
      return false
    }
  })
  return result
}

export default baseFindKey
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseFlatten.ts 1`] = `
"import isFlattenable from './isFlattenable.js'

/**
 * The base implementation of \`flatten\` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass \`predicate\` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(
  array: any[],
  depth: number,
  predicate: boolean,
  isStrict: boolean,
  result: any[]
): any[] {
  predicate || (predicate = isFlattenable)
  result || (result = [])

  if (array == null) {
    return result
  }

  for (const value of array) {
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result)
      } else {
        result.push(...value)
      }
    } else if (!isStrict) {
      result[result.length] = value
    }
  }
  return result
}

export default baseFlatten
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseFor.ts 1`] = `
"/**
 * The base implementation of \`baseForOwn\` which iterates over \`object\`
 * properties returned by \`keysFunc\` and invokes \`iteratee\` for each property.
 * Iteratee functions may exit iteration early by explicitly returning \`false\`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of \`object\`.
 * @returns {Object} Returns \`object\`.
 */
function baseFor(object: Object, iteratee: Function, keysFunc: Function): Object {
  const iterable = Object(object)
  const props = keysFunc(object)
  let { length } = props
  let index = -1

  while (length--) {
    const key = props[++index]
    if (iteratee(iterable[key], key, iterable) === false) {
      break
    }
  }
  return object
}

export default baseFor
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseForOwn.ts 1`] = `
"import baseFor from './baseFor.js'
import keys from '../keys.js'

/**
 * The base implementation of \`forOwn\`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns \`object\`.
 */
function baseForOwn(object: Object, iteratee: Function): Object {
  return object && baseFor(object, iteratee, keys)
}

export default baseForOwn
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseForOwnRight.ts 1`] = `
"import baseForRight from './baseForRight.js'
import keys from '../keys.js'

/**
 * The base implementation of \`forOwnRight\`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns \`object\`.
 */
function baseForOwnRight(object: Object, iteratee: Function): Object {
  return object && baseForRight(object, iteratee, keys)
}

export default baseForOwnRight
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseForRight.ts 1`] = `
"/**
 * This function is like \`baseFor\` except that it iterates over properties
 * in the opposite order.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of \`object\`.
 * @returns {Object} Returns \`object\`.
 */
function baseForRight(object: Object, iteratee: Function, keysFunc: Function): Object {
  const iterable = Object(object)
  const props = keysFunc(object)
  let { length } = props

  while (length--) {
    const key = props[length]
    if (iteratee(iterable[key], key, iterable) === false) {
      break
    }
  }
  return object
}

export default baseForRight
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseGet.ts 1`] = `
"import castPath from './castPath.js'
import toKey from './toKey.js'

/**
 * The base implementation of \`get\` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object: Object, path: any[] | string): any {
  path = castPath(path, object)

  let index = 0
  const length = path.length

  while (object != null && index < length) {
    object = object[toKey(path[index++])]
  }
  return (index && index == length) ? object : undefined
}

export default baseGet
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseInRange.ts 1`] = `
"/**
 * The base implementation of \`inRange\` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to check.
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns \`true\` if \`number\` is in the range, else \`false\`.
 */
function baseInRange(number: number, start: number, end: number): boolean {
  return number >= Math.min(start, end) && number < Math.max(start, end)
}

export default baseInRange
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseIndexOf.ts 1`] = `
"import baseFindIndex from './baseFindIndex.js'
import baseIsNaN from './baseIsNaN.js'
import strictIndexOf from './strictIndexOf.js'

/**
 * The base implementation of \`indexOf\` without \`fromIndex\` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 */
function baseIndexOf(array: any[], value: any, fromIndex: number): number {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex)
}

export default baseIndexOf
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseIndexOfWith.ts 1`] = `
"/**
 * This function is like \`baseIndexOf\` except that it accepts a comparator.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 */
function baseIndexOfWith(array: any[], value: any, fromIndex: number, comparator: Function): number {
  let index = fromIndex - 1
  const { length } = array

  while (++index < length) {
    if (comparator(array[index], value)) {
      return index
    }
  }
  return -1
}

export default baseIndexOfWith
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseIntersection.ts 1`] = `
"import SetCache from './SetCache.js'
import arrayIncludes from './arrayIncludes.js'
import arrayIncludesWith from './arrayIncludesWith.js'
import map from '../map.js'
import cacheHas from './cacheHas.js'

/**
 * The base implementation of methods like \`intersection\` that accepts an
 * array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays: any[], iteratee: Function, comparator: Function): any[] {
  const includes = comparator ? arrayIncludesWith : arrayIncludes
  const length = arrays[0].length
  const othLength = arrays.length
  const caches = new Array(othLength)
  const result = []

  let array
  let maxLength = Infinity
  let othIndex = othLength

  while (othIndex--) {
    array = arrays[othIndex]
    if (othIndex && iteratee) {
      array = map(array, (value) => iteratee(value))
    }
    maxLength = Math.min(array.length, maxLength)
    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
      ? new SetCache(othIndex && array)
      : undefined
  }
  array = arrays[0]

  let index = -1
  const seen = caches[0]

  outer:
  while (++index < length && result.length < maxLength) {
    let value = array[index]
    const computed = iteratee ? iteratee(value) : value

    value = (comparator || value !== 0) ? value : 0
    if (!(seen
          ? cacheHas(seen, computed)
          : includes(result, computed, comparator)
        )) {
      othIndex = othLength
      while (--othIndex) {
        const cache = caches[othIndex]
        if (!(cache
              ? cacheHas(cache, computed)
              : includes(arrays[othIndex], computed, comparator))
            ) {
          continue outer
        }
      }
      if (seen) {
        seen.push(computed)
      }
      result.push(value)
    }
  }
  return result
}

export default baseIntersection
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseIsEqual.ts 1`] = `
"import baseIsEqualDeep from './baseIsEqualDeep.js'
import isObjectLike from '../isObjectLike.js'

/**
 * The base implementation of \`isEqual\` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed \`value\` and \`other\` objects.
 * @returns {boolean} Returns \`true\` if the values are equivalent, else \`false\`.
 */
function baseIsEqual(
  value: any,
  other: any,
  bitmask: boolean,
  customizer: Function,
  stack: Object
): boolean {
  if (value === other) {
    return true
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack)
}

export default baseIsEqual
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseIsEqualDeep.ts 1`] = `
"import Stack from './Stack.js'
import equalArrays from './equalArrays.js'
import equalByTag from './equalByTag.js'
import equalObjects from './equalObjects.js'
import getTag from './getTag.js'
import isBuffer from '../isBuffer.js'
import isTypedArray from '../isTypedArray.js'

/** Used to compose bitmasks for value comparisons. */
const COMPARE_PARTIAL_FLAG = 1

/** \`Object#toString\` result references. */
const argsTag = '[object Arguments]'
const arrayTag = '[object Array]'
const objectTag = '[object Object]'

/** Used to check objects for own properties. */
const hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * A specialized version of \`baseIsEqual\` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See \`baseIsEqual\` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed \`object\` and \`other\` objects.
 * @returns {boolean} Returns \`true\` if the objects are equivalent, else \`false\`.
 */
function baseIsEqualDeep(
  object: Object,
  other: Object,
  bitmask: number,
  customizer: Function,
  equalFunc: Function,
  stack: Object
): boolean {
  let objIsArr = Array.isArray(object)
  const othIsArr = Array.isArray(other)
  let objTag = objIsArr ? arrayTag : getTag(object)
  let othTag = othIsArr ? arrayTag : getTag(other)

  objTag = objTag == argsTag ? objectTag : objTag
  othTag = othTag == argsTag ? objectTag : othTag

  let objIsObj = objTag == objectTag
  const othIsObj = othTag == objectTag
  const isSameTag = objTag == othTag

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false
    }
    objIsArr = true
    objIsObj = false
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack)
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack)
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    const objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__')
    const othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__')

    if (objIsWrapped || othIsWrapped) {
      const objUnwrapped = objIsWrapped ? object.value() : object
      const othUnwrapped = othIsWrapped ? other.value() : other

      stack || (stack = new Stack)
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack)
    }
  }
  if (!isSameTag) {
    return false
  }
  stack || (stack = new Stack)
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack)
}

export default baseIsEqualDeep
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseIsMatch.ts 1`] = `
"import Stack from './Stack.js'
import baseIsEqual from './baseIsEqual.js'

/** Used to compose bitmasks for value comparisons. */
const COMPARE_PARTIAL_FLAG = 1
const COMPARE_UNORDERED_FLAG = 2

/**
 * The base implementation of \`isMatch\`.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns \`true\` if \`object\` is a match, else \`false\`.
 */
function baseIsMatch(object: Object, source: Object, matchData: any[], customizer: Function): boolean {
  let index = matchData.length
  const length = index
  const noCustomizer = !customizer

  if (object == null) {
    return !length
  }
  let data
  let result
  object = Object(object)
  while (index--) {
    data = matchData[index]
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false
    }
  }
  while (++index < length) {
    data = matchData[index]
    const key = data[0]
    const objValue = object[key]
    const srcValue = data[1]

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false
      }
    } else {
      const stack = new Stack
      if (customizer) {
        result = customizer(objValue, srcValue, key, object, source, stack)
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false
      }
    }
  }
  return true
}

export default baseIsMatch
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseIsNaN.ts 1`] = `
"/**
 * The base implementation of \`isNaN\` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is \`NaN\`, else \`false\`.
 */
function baseIsNaN(value: any): boolean {
  return value !== value
}

export default baseIsNaN
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseMatches.ts 1`] = `
"import baseIsMatch from './baseIsMatch.js'
import getMatchData from './getMatchData.js'
import matchesStrictComparable from './matchesStrictComparable.js'

/**
 * The base implementation of \`matches\` which doesn't clone \`source\`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source: Object): Function {
  const matchData = getMatchData(source)
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1])
  }
  return (object) => object === source || baseIsMatch(object, source, matchData)
}

export default baseMatches
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseMatchesProperty.ts 1`] = `
"import baseIsEqual from './baseIsEqual.js'
import get from '../get.js'
import hasIn from '../hasIn.js'
import isKey from './isKey.js'
import isStrictComparable from './isStrictComparable.js'
import matchesStrictComparable from './matchesStrictComparable.js'
import toKey from './toKey.js'

/** Used to compose bitmasks for value comparisons. */
const COMPARE_PARTIAL_FLAG = 1
const COMPARE_UNORDERED_FLAG = 2

/**
 * The base implementation of \`matchesProperty\` which doesn't clone \`srcValue\`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path: string, srcValue: any): Function {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue)
  }
  return (object) => {
    const objValue = get(object, path)
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
  }
}

export default baseMatchesProperty
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseMerge.ts 1`] = `
"import Stack from './Stack.js'
import assignMergeValue from './assignMergeValue.js'
import baseFor from './baseFor.js'
import baseMergeDeep from './baseMergeDeep.js'
import isObject from '../isObject.js'
import keysIn from '../keysIn.js'

/**
 * The base implementation of \`merge\` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of \`source\`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object: Object, source: Object, srcIndex: number, customizer: Function, stack: Object) {
  if (object === source) {
    return
  }
  baseFor(source, (srcValue, key) => {
    if (isObject(srcValue)) {
      stack || (stack = new Stack)
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack)
    }
    else {
      let newValue = customizer
        ? customizer(object[key], srcValue, \`\${key}\`, object, source, stack)
        : undefined

      if (newValue === undefined) {
        newValue = srcValue
      }
      assignMergeValue(object, key, newValue)
    }
  }, keysIn)
}

export default baseMerge
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseMergeDeep.ts 1`] = `
"import assignMergeValue from './assignMergeValue.js'
import cloneBuffer from './cloneBuffer.js'
import cloneTypedArray from './cloneTypedArray.js'
import copyArray from './copyArray.js'
import initCloneObject from './initCloneObject.js'
import isArguments from '../isArguments.js'
import isArrayLikeObject from '../isArrayLikeObject.js'
import isBuffer from '../isBuffer.js'
import isObject from '../isObject.js'
import isPlainObject from '../isPlainObject.js'
import isTypedArray from '../isTypedArray.js'
import toPlainObject from '../toPlainObject.js'

/**
 * A specialized version of \`baseMerge\` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of \`source\`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object: Object, source: Object, key: string, srcIndex: number, mergeFunc: Function, customizer: Function, stack: Object) {
  const objValue = object[key]
  const srcValue = source[key]
  const stacked = stack.get(srcValue)

  if (stacked) {
    assignMergeValue(object, key, stacked)
    return
  }
  let newValue = customizer
    ? customizer(objValue, srcValue, \`\${key}\`, object, source, stack)
    : undefined

  let isCommon = newValue === undefined

  if (isCommon) {
    const isArr = Array.isArray(srcValue)
    const isBuff = !isArr && isBuffer(srcValue)
    const isTyped = !isArr && !isBuff && isTypedArray(srcValue)

    newValue = srcValue
    if (isArr || isBuff || isTyped) {
      if (Array.isArray(objValue)) {
        newValue = objValue
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue)
      }
      else if (isBuff) {
        isCommon = false
        newValue = cloneBuffer(srcValue, true)
      }
      else if (isTyped) {
        isCommon = false
        newValue = cloneTypedArray(srcValue, true)
      }
      else {
        newValue = []
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue)
      }
      else if ((srcIndex && typeof objValue == 'function') || !isObject(objValue)) {
        newValue = initCloneObject(srcValue)
      }
    }
    else {
      isCommon = false
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue)
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack)
    stack['delete'](srcValue)
  }
  assignMergeValue(object, key, newValue)
}

export default baseMergeDeep
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseOrderBy.ts 1`] = `
"import baseEach from './baseEach.js'
import baseSortBy from './baseSortBy.js'
import compareMultiple from './compareMultiple.js'

/**
 * The base implementation of \`orderBy\` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of \`iteratees\`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(
  collection: any[] | Object,
  iteratees: Function[] | Object[] | string[],
  orders: string[]
): any[] {
  let criteriaIndex = -1
  let eachIndex = -1
  iteratees = iteratees.length ? iteratees : [(value) => value]

  const result = isArrayLike(collection) ? new Array(collection.length) : []

  baseEach(collection, (value) => {
    const criteria = iteratees.map((iteratee) => iteratee(value))
    result[++eachIndex] = { 'criteria': criteria, 'index': ++criteriaIndex, 'value': value }
  })

  return baseSortBy(result, (object, other) => compareMultiple(object, other, orders))
}

export default baseOrderBy
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/basePick.ts 1`] = `
"import basePickBy from './basePickBy.js'
import hasIn from '../hasIn.js'

/**
 * The base implementation of \`pick\` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object: Object, paths: string[]): Object {
  return basePickBy(object, paths, (value, path) => hasIn(object, path))
}

export default basePick
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/basePickBy.ts 1`] = `
"import baseGet from './baseGet.js'
import baseSet from './baseSet.js'
import castPath from './castPath.js'

/**
 * The base implementation of \`pickBy\`.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object: Object, paths: string[], predicate: Function): Object {
  let index = -1
  const length = paths.length
  const result = {}

  while (++index < length) {
    const path = paths[index]
    const value = baseGet(object, path)
    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value)
    }
  }
  return result
}

export default basePickBy
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseProperty.ts 1`] = `
"/**
 * The base implementation of \`property\` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key: string): Function {
  return (object) => object == null ? undefined : object[key]
}

export default baseProperty
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/basePropertyDeep.ts 1`] = `
"import baseGet from './baseGet.js'

/**
 * A specialized version of \`baseProperty\` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path: any[] | string): Function {
  return (object) => baseGet(object, path)
}

export default basePropertyDeep
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/basePropertyOf.ts 1`] = `
"/**
 * The base implementation of \`propertyOf\` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object: Object): Function {
  return (key) => object == null ? undefined : object[key]
}

export default basePropertyOf
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/basePullAll.ts 1`] = `
"import map from '../map.js'
import baseIndexOf from './baseIndexOf.js'
import baseIndexOfWith from './baseIndexOfWith.js'
import copyArray from './copyArray.js'

/**
 * The base implementation of \`pullAllBy\`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns \`array\`.
 */
function basePullAll(array: any[], values: any[], iteratee: Function, comparator: Function): any[] {
  const indexOf = comparator ? baseIndexOfWith : baseIndexOf
  const length = values.length

  let index = -1
  let seen = array

  if (array === values) {
    values = copyArray(values)
  }
  if (iteratee) {
    seen = map(array, (value) => iteratee(value))
  }
  while (++index < length) {
    let fromIndex = 0
    const value = values[index]
    const computed = iteratee ? iteratee(value) : value

    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        seen.splice(fromIndex, 1)
      }
      array.splice(fromIndex, 1)
    }
  }
  return array
}

export default basePullAll
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/basePullAt.ts 1`] = `
"import baseUnset from './baseUnset.js'
import isIndex from './isIndex.js'

/**
 * The base implementation of \`pullAt\` without support for individual
 * indexes or capturing the removed elements.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {number[]} indexes The indexes of elements to remove.
 * @returns {Array} Returns \`array\`.
 */
function basePullAt(array: any[], indexes: number[]): any[] {
  let length = array ? indexes.length : 0
  const lastIndex = length - 1

  while (length--) {
    let previous
    const index = indexes[length]
    if (length == lastIndex || index !== previous) {
      previous = index
      if (isIndex(index)) {
        array.splice(index, 1)
      } else {
        baseUnset(array, index)
      }
    }
  }
  return array
}

export default basePullAt
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseRange.ts 1`] = `
"/**
 * The base implementation of \`range\` and \`rangeRight\` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start: number, end: number, step: number, fromRight: boolean): any[] {
  let index = -1
  let length = Math.max(Math.ceil((end - start) / (step || 1)), 0)
  const result = new Array(length)

  while (length--) {
    result[fromRight ? length : ++index] = start
    start += step
  }
  return result
}

export default baseRange
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseReduce.ts 1`] = `
"/**
 * The base implementation of \`reduce\` and \`reduceRight\` which iterates
 * over \`collection\` using \`eachFunc\`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  \`collection\` as the initial value.
 * @param {Function} eachFunc The function to iterate over \`collection\`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(
  collection: any[] | Object,
  iteratee: Function,
  accumulator: any,
  initAccum: boolean,
  eachFunc: Function
): any {
  eachFunc(collection, (value, index, collection) => {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection)
  })
  return accumulator
}

export default baseReduce
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseSet.ts 1`] = `
"import assignValue from './assignValue.js'
import castPath from './castPath.js'
import isIndex from './isIndex.js'
import isObject from '../isObject.js'
import toKey from './toKey.js'

/**
 * The base implementation of \`set\`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns \`object\`.
 */
function baseSet(object: Object, path: any[] | string, value: any, customizer: Function): Object {
  if (!isObject(object)) {
    return object
  }
  path = castPath(path, object)

  const length = path.length
  const lastIndex = length - 1

  let index = -1
  let nested = object

  while (nested != null && ++index < length) {
    const key = toKey(path[index])
    let newValue = value

    if (index != lastIndex) {
      const objValue = nested[key]
      newValue = customizer ? customizer(objValue, key, nested) : undefined
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {})
      }
    }
    assignValue(nested, key, newValue)
    nested = nested[key]
  }
  return object
}

export default baseSet
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseSortBy.ts 1`] = `
"/**
 * The base implementation of \`sortBy\` which uses \`comparer\` to define the
 * sort order of \`array\` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns \`array\`.
 */
function baseSortBy(array: any[], comparer: Function): any[] {
  let { length } = array

  array.sort(comparer)
  while (length--) {
    array[length] = array[length].value
  }
  return array
}

export default baseSortBy
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseSortedIndex.ts 1`] = `
"import baseSortedIndexBy from './baseSortedIndexBy.js'
import isSymbol from '../isSymbol.js'

/** Used as references for the maximum length and index of an array. */
const MAX_ARRAY_LENGTH = 4294967295
const HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1

/**
 * The base implementation of \`sortedIndex\` and \`sortedLastIndex\` which
 * performs a binary search of \`array\` to determine the index at which \`value\`
 * should be inserted into \`array\` in order to maintain its sort order.
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which \`value\` should be inserted
 *  into \`array\`.
 */
function baseSortedIndex(array: any[], value: any, retHighest: boolean): number {
  let low = 0
  let high = array == null ? low : array.length

  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      const mid = (low + high) >>> 1
      const computed = array[mid]
      if (computed !== null && !isSymbol(computed) &&
          (retHighest ? (computed <= value) : (computed < value))) {
        low = mid + 1
      } else {
        high = mid
      }
    }
    return high
  }
  return baseSortedIndexBy(array, value, (value) => value, retHighest)
}

export default baseSortedIndex
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseSortedIndexBy.ts 1`] = `
"import isSymbol from '../isSymbol.js'

/** Used as references for the maximum length and index of an array. */
const MAX_ARRAY_LENGTH = 4294967295
const MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1

/**
 * The base implementation of \`sortedIndexBy\` and \`sortedLastIndexBy\`
 * which invokes \`iteratee\` for \`value\` and each element of \`array\` to compute
 * their sort ranking. The iteratee is invoked with one argument (value).
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} iteratee The iteratee invoked per element.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which \`value\` should be inserted
 *  into \`array\`.
 */
function baseSortedIndexBy(array: any[], value: any, iteratee: Function, retHighest: boolean): number {
  value = iteratee(value)

  let low = 0
  let high = array == null ? 0 : array.length
  const valIsNaN = value !== value
  const valIsNull = value === null
  const valIsSymbol = isSymbol(value)
  const valIsUndefined = value === undefined

  while (low < high) {
    let setLow
    const mid = Math.floor((low + high) / 2)
    const computed = iteratee(array[mid])
    const othIsDefined = computed !== undefined
    const othIsNull = computed === null
    const othIsReflexive = computed === computed
    const othIsSymbol = isSymbol(computed)

    if (valIsNaN) {
      setLow = retHighest || othIsReflexive
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined)
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull)
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol)
    } else if (othIsNull || othIsSymbol) {
      setLow = false
    } else {
      setLow = retHighest ? (computed <= value) : (computed < value)
    }
    if (setLow) {
      low = mid + 1
    } else {
      high = mid
    }
  }
  return Math.min(high, MAX_ARRAY_INDEX)
}

export default baseSortedIndexBy
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseSortedUniq.ts 1`] = `
"import eq from '../eq.js'

/**
 * The base implementation of \`sortedUniq\` and \`sortedUniqBy\`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseSortedUniq(array: any[], iteratee: Function): any[] {
  let seen
  let index = -1
  let resIndex = 0

  const { length } = array
  const result = []

  while (++index < length) {
    const value = array[index], computed = iteratee ? iteratee(value) : value
    if (!index || !eq(computed, seen)) {
      seen = computed
      result[resIndex++] = value === 0 ? 0 : value
    }
  }
  return result
}

export default baseSortedUniq
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseSum.ts 1`] = `
"/**
 * The base implementation of \`sum\` and \`sumBy\`.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum(array: any[], iteratee: Function): number {
  let result

  for (const value of array) {
    const current = iteratee(value)
    if (current !== undefined) {
      result = result === undefined ? current : (result + current)
    }
  }
  return result
}

export default baseSum
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseToNumber.ts 1`] = `
"import isSymbol from '../isSymbol.js'

/** Used as references for various \`Number\` constants. */
const NAN = 0 / 0

/**
 * The base implementation of \`toNumber\` which doesn't ensure correct
 * conversions of binary, hexadecimal, or octal string values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 */
function baseToNumber(value: any): number {
  if (typeof value == 'number') {
    return value
  }
  if (isSymbol(value)) {
    return NAN
  }
  return +value
}

export default baseToNumber
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseToString.ts 1`] = `
"import isSymbol from '../isSymbol.js'

/** Used as references for various \`Number\` constants. */
const INFINITY = 1 / 0

/** Used to convert symbols to primitives and strings. */
const symbolToString = Symbol.prototype.toString

/**
 * The base implementation of \`toString\` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value: any): string {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value
  }
  if (Array.isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return \`\${value.map(baseToString)}\`
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : ''
  }
  const result = \`\${value}\`
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result
}

export default baseToString
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseUniq.ts 1`] = `
"import SetCache from './SetCache.js'
import arrayIncludes from './arrayIncludes.js'
import arrayIncludesWith from './arrayIncludesWith.js'
import cacheHas from './cacheHas.js'
import createSet from './createSet.js'
import setToArray from './setToArray.js'

/** Used as the size to enable large array optimizations. */
const LARGE_ARRAY_SIZE = 200

/**
 * The base implementation of \`uniqBy\`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array: any[], iteratee: Function, comparator: Function): any[] {
  let index = -1
  let includes = arrayIncludes
  let isCommon = true

  const { length } = array
  const result = []
  let seen = result

  if (comparator) {
    isCommon = false
    includes = arrayIncludesWith
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    const set = iteratee ? null : createSet(array)
    if (set) {
      return setToArray(set)
    }
    isCommon = false
    includes = cacheHas
    seen = new SetCache
  }
  else {
    seen = iteratee ? [] : result
  }
  outer:
  while (++index < length) {
    let value = array[index]
    const computed = iteratee ? iteratee(value) : value

    value = (comparator || value !== 0) ? value : 0
    if (isCommon && computed === computed) {
      let seenIndex = seen.length
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer
        }
      }
      if (iteratee) {
        seen.push(computed)
      }
      result.push(value)
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed)
      }
      result.push(value)
    }
  }
  return result
}

export default baseUniq
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseUnset.ts 1`] = `
"import castPath from './castPath.js'
import last from '../last.js'
import parent from './parent.js'
import toKey from './toKey.js'

/**
 * The base implementation of \`unset\`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns \`true\` if the property is deleted, else \`false\`.
 */
function baseUnset(object: Object, path: any[] | string): boolean {
  path = castPath(path, object)
  object = parent(object, path)
  return object == null || delete object[toKey(last(path))]
}

export default baseUnset
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseUpdate.ts 1`] = `
"import baseGet from './baseGet.js'
import baseSet from './baseSet.js'

/**
 * The base implementation of \`update\`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to update.
 * @param {Function} updater The function to produce the updated value.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns \`object\`.
 */
function baseUpdate(
 object: Object,
 path: any[] | string,
 updater: Function,
 customizer: Function
): Object {
  return baseSet(object, path, updater(baseGet(object, path)), customizer)
}

export default baseUpdate
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseValues.ts 1`] = `
"/**
 * The base implementation of \`values\` and \`valuesIn\` which creates an
 * array of \`object\` property values corresponding to the property names
 * of \`props\`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object: Object, props: any[]): Object {
  return props == null ? [] : props.map((key) => object[key])
}

export default baseValues
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseWhile.ts 1`] = `
"import slice from '../slice.js'

/**
 * The base implementation of methods like \`dropWhile\` and \`takeWhile\`.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {Function} predicate The function invoked per iteration.
 * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the slice of \`array\`.
 */
function baseWhile(array: any[], predicate: Function, isDrop: boolean, fromRight: boolean): any[] {
  const { length } = array
  let index = fromRight ? length : -1

  while ((fromRight ? index-- : ++index < length) &&
    predicate(array[index], index, array)) {}

  return isDrop
    ? slice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
    : slice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index))
}

export default baseWhile
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseXor.ts 1`] = `
"import baseDifference from './baseDifference.js'
import baseFlatten from './baseFlatten.js'
import baseUniq from './baseUniq.js'

/**
 * The base implementation of methods like \`xor\` which accepts an array of
 * arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of values.
 */
function baseXor(arrays: any[], iteratee: Function, comparator: Function): any[] {
  const length = arrays.length
  if (length < 2) {
    return length ? baseUniq(arrays[0]) : []
  }
  let index = -1
  const result = new Array(length)

  while (++index < length) {
    const array = arrays[index]
    let othIndex = -1

    while (++othIndex < length) {
      if (othIndex != index) {
        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator)
      }
    }
  }
  return baseUniq(baseFlatten(result, 1), iteratee, comparator)
}

export default baseXor
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/baseZipObject.ts 1`] = `
"/**
 * This base implementation of \`zipObject\` which assigns values using \`assignFunc\`.
 *
 * @private
 * @param {Array} props The property identifiers.
 * @param {Array} values The property values.
 * @param {Function} assignFunc The function to assign values.
 * @returns {Object} Returns the new object.
 */
function baseZipObject(props: any[], values: any[], assignFunc: Function): Object {
  let index = -1
  const length = props.length
  const valsLength = values.length
  const result = {}

  while (++index < length) {
    const value = index < valsLength ? values[index] : undefined
    assignFunc(result, props[index], value)
  }
  return result
}

export default baseZipObject
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/cacheHas.ts 1`] = `
"/**
 * Checks if a \`cache\` value for \`key\` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns \`true\` if an entry for \`key\` exists, else \`false\`.
 */
function cacheHas(cache: Object, key: string): boolean {
  return cache.has(key)
}

export default cacheHas
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/castArrayLikeObject.ts 1`] = `
"import isArrayLikeObject from '../isArrayLikeObject.js'

/**
 * Casts \`value\` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value: any): any[] | Object {
  return isArrayLikeObject(value) ? value : []
}

export default castArrayLikeObject
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/castPath.ts 1`] = `
"import isKey from './isKey.js'
import stringToPath from './stringToPath.js'

/**
 * Casts \`value\` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value: any, object: Object): any[] {
  if (Array.isArray(value)) {
    return value
  }
  return isKey(value, object) ? [value] : stringToPath(value)
}

export default castPath
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/castSlice.ts 1`] = `
"import slice from '../slice.js'

/**
 * Casts \`array\` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array: any[], start: number, end: number): any[] {
  const { length } = array
  end = end === undefined ? length : end
  return (!start && end >= length) ? array : slice(array, start, end)
}

export default castSlice
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/charsEndIndex.ts 1`] = `
"import baseIndexOf from './baseIndexOf.js'

/**
 * Used by \`trim\` and \`trimEnd\` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the last unmatched string symbol.
 */
function charsEndIndex(strSymbols: any[], chrSymbols: any[]): number {
  let index = strSymbols.length

  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index
}

export default charsEndIndex
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/charsStartIndex.ts 1`] = `
"import baseIndexOf from './baseIndexOf.js'

/**
 * Used by \`trim\` and \`trimStart\` to get the index of the first string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the first unmatched string symbol.
 */
function charsStartIndex(strSymbols: any[], chrSymbols: any[]): number {
  let index = -1
  const length = strSymbols.length

  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index
}

export default charsStartIndex
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/cloneArrayBuffer.ts 1`] = `
"/**
 * Creates a clone of \`arrayBuffer\`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer: ArrayBuffer): ArrayBuffer {
  const result = new arrayBuffer.constructor(arrayBuffer.byteLength)
  new Uint8Array(result).set(new Uint8Array(arrayBuffer))
  return result
}

export default cloneArrayBuffer
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/cloneBuffer.ts 1`] = `
"import root from './root.js'

/** Detect free variable \`exports\`. */
const freeExports = typeof exports == 'object' && exports !== null && !exports.nodeType && exports

/** Detect free variable \`module\`. */
const freeModule = freeExports && typeof module == 'object' && module !== null && !module.nodeType && module

/** Detect the popular CommonJS extension \`module.exports\`. */
const moduleExports = freeModule && freeModule.exports === freeExports

/** Built-in value references. */
const Buffer = moduleExports ? root.Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined

/**
 * Creates a clone of \`buffer\`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer: Buffer, isDeep: boolean): Buffer {
  if (isDeep) {
    return buffer.slice()
  }
  const length = buffer.length
  const result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length)

  buffer.copy(result)
  return result
}

export default cloneBuffer
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/cloneDataView.ts 1`] = `
"import cloneArrayBuffer from './cloneArrayBuffer.js'

/**
 * Creates a clone of \`dataView\`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView: Object, isDeep: boolean): Object {
  const buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength)
}

export default cloneDataView
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/cloneRegExp.ts 1`] = `
"/** Used to match \`RegExp\` flags from their coerced string values. */
const reFlags = /\\\\w*$/

/**
 * Creates a clone of \`regexp\`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp: Object): Object {
  const result = new regexp.constructor(regexp.source, reFlags.exec(regexp))
  result.lastIndex = regexp.lastIndex
  return result
}

export default cloneRegExp
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/cloneSymbol.ts 1`] = `
"/** Used to convert symbols to primitives and strings. */
const symbolValueOf = Symbol.prototype.valueOf

/**
 * Creates a clone of the \`symbol\` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol: Object): Object {
  return Object(symbolValueOf.call(symbol))
}

export default cloneSymbol
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/cloneTypedArray.ts 1`] = `
"import cloneArrayBuffer from './cloneArrayBuffer.js'

/**
 * Creates a clone of \`typedArray\`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray: Object, isDeep: boolean): Object {
  const buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length)
}

export default cloneTypedArray
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/compareAscending.ts 1`] = `
"import isSymbol from '../isSymbol.js'

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for \`value\`.
 */
function compareAscending(value: any, other: any): number {
  if (value !== other) {
    const valIsDefined = value !== undefined
    const valIsNull = value === null
    const valIsReflexive = value === value
    const valIsSymbol = isSymbol(value)

    const othIsDefined = other !== undefined
    const othIsNull = other === null
    const othIsReflexive = other === other
    const othIsSymbol = isSymbol(other)

    const val = typeof value == 'string'
      ? value.localeCompare(other)
      : -other

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && val > 0) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && val < 0) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1
    }
  }
  return 0
}

export default compareAscending
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/compareMultiple.ts 1`] = `
"import compareAscending from './compareAscending.js'

/**
 * Used by \`orderBy\` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If \`orders\` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of \\"desc\\" for descending or \\"asc\\" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {(string|function)[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for \`object\`.
 */
function compareMultiple(object: Object, other: Object, orders: string[] | function[]): number {
  let index = -1
  const objCriteria = object.criteria
  const othCriteria = other.criteria
  const length = objCriteria.length
  const ordersLength = orders.length

  while (++index < length) {
    const order = index < ordersLength ? orders[index] : null
    const cmpFn = (order && typeof order === 'function') ? order: compareAscending
    const result = cmpFn(objCriteria[index], othCriteria[index])
    if (result) {
      if (order && typeof order !== 'function') {
        return result * (order == 'desc' ? -1 : 1)
      }
      return result
    }
  }
  // Fixes an \`Array#sort\` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // \`object\` and \`other\`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index
}

export default compareMultiple
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/composeArgs.ts 1`] = `
"/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The \`partials\` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args: any[], partials: any[], holders: any[], isCurried: any): any[] {
  const argsLength = args.length
  const holdersLength = holders.length
  const leftLength = partials.length

  let argsIndex = -1
  let leftIndex = -1
  let rangeLength = Math.max(argsLength - holdersLength, 0)

  const result = new Array(leftLength + rangeLength)
  const isUncurried = !isCurried

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex]
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex]
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++]
  }
  return result
}

export default composeArgs
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/composeArgsRight.ts 1`] = `
"/**
 * This function is like \`composeArgs\` except that the arguments composition
 * is tailored for \`partialRight\`.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The \`partials\` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args: any[], partials: any[], holders: any[], isCurried: any): any[] {
  let argsIndex = -1
  let holdersIndex = -1
  let rightIndex = -1

  const argsLength = args.length
  const holdersLength = holders.length
  const rightLength = partials.length
  const rangeLength = Math.max(argsLength - holdersLength, 0)
  const result = new Array(rangeLength + rightLength)
  const isUncurried = !isCurried

  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex]
  }
  const offset = argsIndex
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex]
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset + holders[holdersIndex]] = args[argsIndex++]
    }
  }
  return result
}

export default composeArgsRight
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/copyArray.ts 1`] = `
"/**
 * Copies the values of \`source\` to \`array\`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns \`array\`.
 */
function copyArray(source: any[], array: any[]): any[] {
  let index = -1
  const length = source.length

  array || (array = new Array(length))
  while (++index < length) {
    array[index] = source[index]
  }
  return array
}

export default copyArray
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/copyObject.ts 1`] = `
"import assignValue from './assignValue.js'
import baseAssignValue from './baseAssignValue.js'

/**
 * Copies properties of \`source\` to \`object\`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns \`object\`.
 */
function copyObject(source: Object, props: any[], object: Object, customizer: Function): Object {
  const isNew = !object
  object || (object = {})

  for (const key of props) {
    let newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined

    if (newValue === undefined) {
      newValue = source[key]
    }
    if (isNew) {
      baseAssignValue(object, key, newValue)
    } else {
      assignValue(object, key, newValue)
    }
  }
  return object
}

export default copyObject
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/copySymbols.ts 1`] = `
"import copyObject from './copyObject.js'
import getSymbols from './getSymbols.js'

/**
 * Copies own symbols of \`source\` to \`object\`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns \`object\`.
 */
function copySymbols(source: Object, object: Object): Object {
  return copyObject(source, getSymbols(source), object)
}

export default copySymbols
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/copySymbolsIn.ts 1`] = `
"import copyObject from './copyObject.js'
import getSymbolsIn from './getSymbolsIn.js'

/**
 * Copies own and inherited symbols of \`source\` to \`object\`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns \`object\`.
 */
function copySymbolsIn(source: Object, object: Object): Object {
  return copyObject(source, getSymbolsIn(source), object)
}

export default copySymbolsIn
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/createAssigner.ts 1`] = `
"import isIterateeCall from './isIterateeCall.js';

/**
 * Creates a function like \`assign\`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner: Function): Function {
  return (object, ...sources) => {
    let index = -1;
    let length = sources.length;
    let customizer = length > 1 ? sources[length - 1] : undefined;
    const guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      const source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  };
}

export default createAssigner;"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/createCaseFirst.ts 1`] = `
"import castSlice from './castSlice.js'
import hasUnicode from './hasUnicode.js'
import stringToArray from './stringToArray.js'

/**
 * Creates a function like \`lowerFirst\`.
 *
 * @private
 * @param {string} methodName The name of the \`String\` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName: string): Function {
  return (string) => {
    const strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined

    const chr = strSymbols
      ? strSymbols[0]
      : string[0]

    const trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1)

    return chr[methodName]() + trailing
  }
}

export default createCaseFirst
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/createMathOperation.ts 1`] = `
"import baseToNumber from './baseToNumber.js'
import baseToString from './baseToString.js'

/**
 * Creates a function that performs a mathematical operation on two values.
 *
 * @private
 * @param {Function} operator The function to perform the operation.
 * @param {number} [defaultValue] The value used for \`undefined\` arguments.
 * @returns {Function} Returns the new mathematical operation function.
 */
function createMathOperation(operator: Function, defaultValue: number): Function {
  return (value, other) => {
    if (value === undefined && other === undefined) {
      return defaultValue
    }
    if (value !== undefined && other === undefined) {
      return value
    }
    if (other !== undefined && value === undefined) {
      return other
    }
    if (typeof value === 'string' || typeof other === 'string') {
      value = baseToString(value)
      other = baseToString(other)
    }
    else {
      value = baseToNumber(value)
      other = baseToNumber(other)
    }
    return operator(value, other)
  }
}

export default createMathOperation
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/createPadding.ts 1`] = `
"import repeat from '../repeat.js'
import baseToString from './baseToString.js'
import castSlice from './castSlice.js'
import hasUnicode from './hasUnicode.js'
import stringSize from './stringSize.js'
import stringToArray from './stringToArray.js'

/**
 * Creates the padding for \`string\` based on \`length\`. The \`chars\` string
 * is truncated if the number of characters exceeds \`length\`.
 *
 * @private
 * @param {number} length The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padding for \`string\`.
 */
function createPadding(length: number, chars: string): string {
  chars = chars === undefined ? ' ' : baseToString(chars)

  const charsLength = chars.length
  if (charsLength < 2) {
    return charsLength ? repeat(chars, length) : chars
  }
  const result = repeat(chars, Math.ceil(length / stringSize(chars)))
  return hasUnicode(chars)
    ? castSlice(stringToArray(result), 0, length).join('')
    : result.slice(0, length)
}

export default createPadding
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/createRange.ts 1`] = `
"import baseRange from './baseRange.js'
import toFinite from '../toFinite.js'

/**
 * Creates a \`range\` or \`rangeRight\` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight: boolean): Function {
  return (start, end, step) => {
    // Ensure the sign of \`-0\` is preserved.
    start = toFinite(start)
    if (end === undefined) {
      end = start
      start = 0
    } else {
      end = toFinite(end)
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step)
    return baseRange(start, end, step, fromRight)
  }
}

export default createRange
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/createRound.ts 1`] = `
"/**
 * Creates a function like \`round\`.
 *
 * @private
 * @param {string} methodName The name of the \`Math\` method to use when rounding.
 * @returns {Function} Returns the new round function.
 */
function createRound(methodName: string): Function {
  const func = Math[methodName]
  return (number, precision) => {
    precision = precision == null ? 0 : (precision >= 0 ? Math.min(precision, 292) : Math.max(precision, -292))
    if (precision) {
      // Shift with exponential notation to avoid floating-point issues.
      // See [MDN](https://mdn.io/round#Examples) for more details.
      let pair = \`\${number}e\`.split('e')
      const value = func(\`\${pair[0]}e\${+pair[1] + precision}\`)

      pair = \`\${value}e\`.split('e')
      return +\`\${pair[0]}e\${+pair[1] - precision}\`
    }
    return func(number)
  }
}

export default createRound
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/createSet.ts 1`] = `
"import setToArray from './setToArray.js'

/** Used as references for various \`Number\` constants. */
const INFINITY = 1 / 0

/**
 * Creates a set object of \`values\`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
const createSet = (Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY)
  ? (values) => new Set(values)
  : () => {}

export default createSet
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/customDefaultsMerge.ts 1`] = `
"import baseMerge from './baseMerge.js'
import isObject from '../isObject.js'

/**
 * Used by \`defaultsDeep\` to customize its \`merge\` use to merge source
 * objects into destination objects that are passed thru.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to merge.
 * @param {Object} object The parent object of \`objValue\`.
 * @param {Object} source The parent object of \`srcValue\`.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsMerge(
  objValue: any,
  srcValue: any,
  key: string,
  object: Object,
  source: Object,
  stack: Object
): any {
  if (isObject(objValue) && isObject(srcValue)) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, objValue)
    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack)
    stack['delete'](srcValue)
  }
  return objValue
}

export default customDefaultsMerge
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/deburrLetter.ts 1`] = `
"import basePropertyOf from './basePropertyOf.js'

/** Used to map Latin Unicode letters to basic Latin letters. */
const deburredLetters = {
  // Latin-1 Supplement block.
  '\\\\xc0': 'A',  '\\\\xc1': 'A', '\\\\xc2': 'A', '\\\\xc3': 'A', '\\\\xc4': 'A', '\\\\xc5': 'A',
  '\\\\xe0': 'a',  '\\\\xe1': 'a', '\\\\xe2': 'a', '\\\\xe3': 'a', '\\\\xe4': 'a', '\\\\xe5': 'a',
  '\\\\xc7': 'C',  '\\\\xe7': 'c',
  '\\\\xd0': 'D',  '\\\\xf0': 'd',
  '\\\\xc8': 'E',  '\\\\xc9': 'E', '\\\\xca': 'E', '\\\\xcb': 'E',
  '\\\\xe8': 'e',  '\\\\xe9': 'e', '\\\\xea': 'e', '\\\\xeb': 'e',
  '\\\\xcc': 'I',  '\\\\xcd': 'I', '\\\\xce': 'I', '\\\\xcf': 'I',
  '\\\\xec': 'i',  '\\\\xed': 'i', '\\\\xee': 'i', '\\\\xef': 'i',
  '\\\\xd1': 'N',  '\\\\xf1': 'n',
  '\\\\xd2': 'O',  '\\\\xd3': 'O', '\\\\xd4': 'O', '\\\\xd5': 'O', '\\\\xd6': 'O', '\\\\xd8': 'O',
  '\\\\xf2': 'o',  '\\\\xf3': 'o', '\\\\xf4': 'o', '\\\\xf5': 'o', '\\\\xf6': 'o', '\\\\xf8': 'o',
  '\\\\xd9': 'U',  '\\\\xda': 'U', '\\\\xdb': 'U', '\\\\xdc': 'U',
  '\\\\xf9': 'u',  '\\\\xfa': 'u', '\\\\xfb': 'u', '\\\\xfc': 'u',
  '\\\\xdd': 'Y',  '\\\\xfd': 'y', '\\\\xff': 'y',
  '\\\\xc6': 'Ae', '\\\\xe6': 'ae',
  '\\\\xde': 'Th', '\\\\xfe': 'th',
  '\\\\xdf': 'ss',
  // Latin Extended-A block.
  '\\\\u0100': 'A',  '\\\\u0102': 'A', '\\\\u0104': 'A',
  '\\\\u0101': 'a',  '\\\\u0103': 'a', '\\\\u0105': 'a',
  '\\\\u0106': 'C',  '\\\\u0108': 'C', '\\\\u010a': 'C', '\\\\u010c': 'C',
  '\\\\u0107': 'c',  '\\\\u0109': 'c', '\\\\u010b': 'c', '\\\\u010d': 'c',
  '\\\\u010e': 'D',  '\\\\u0110': 'D', '\\\\u010f': 'd', '\\\\u0111': 'd',
  '\\\\u0112': 'E',  '\\\\u0114': 'E', '\\\\u0116': 'E', '\\\\u0118': 'E', '\\\\u011a': 'E',
  '\\\\u0113': 'e',  '\\\\u0115': 'e', '\\\\u0117': 'e', '\\\\u0119': 'e', '\\\\u011b': 'e',
  '\\\\u011c': 'G',  '\\\\u011e': 'G', '\\\\u0120': 'G', '\\\\u0122': 'G',
  '\\\\u011d': 'g',  '\\\\u011f': 'g', '\\\\u0121': 'g', '\\\\u0123': 'g',
  '\\\\u0124': 'H',  '\\\\u0126': 'H', '\\\\u0125': 'h', '\\\\u0127': 'h',
  '\\\\u0128': 'I',  '\\\\u012a': 'I', '\\\\u012c': 'I', '\\\\u012e': 'I', '\\\\u0130': 'I',
  '\\\\u0129': 'i',  '\\\\u012b': 'i', '\\\\u012d': 'i', '\\\\u012f': 'i', '\\\\u0131': 'i',
  '\\\\u0134': 'J',  '\\\\u0135': 'j',
  '\\\\u0136': 'K',  '\\\\u0137': 'k', '\\\\u0138': 'k',
  '\\\\u0139': 'L',  '\\\\u013b': 'L', '\\\\u013d': 'L', '\\\\u013f': 'L', '\\\\u0141': 'L',
  '\\\\u013a': 'l',  '\\\\u013c': 'l', '\\\\u013e': 'l', '\\\\u0140': 'l', '\\\\u0142': 'l',
  '\\\\u0143': 'N',  '\\\\u0145': 'N', '\\\\u0147': 'N', '\\\\u014a': 'N',
  '\\\\u0144': 'n',  '\\\\u0146': 'n', '\\\\u0148': 'n', '\\\\u014b': 'n',
  '\\\\u014c': 'O',  '\\\\u014e': 'O', '\\\\u0150': 'O',
  '\\\\u014d': 'o',  '\\\\u014f': 'o', '\\\\u0151': 'o',
  '\\\\u0154': 'R',  '\\\\u0156': 'R', '\\\\u0158': 'R',
  '\\\\u0155': 'r',  '\\\\u0157': 'r', '\\\\u0159': 'r',
  '\\\\u015a': 'S',  '\\\\u015c': 'S', '\\\\u015e': 'S', '\\\\u0160': 'S',
  '\\\\u015b': 's',  '\\\\u015d': 's', '\\\\u015f': 's', '\\\\u0161': 's',
  '\\\\u0162': 'T',  '\\\\u0164': 'T', '\\\\u0166': 'T',
  '\\\\u0163': 't',  '\\\\u0165': 't', '\\\\u0167': 't',
  '\\\\u0168': 'U',  '\\\\u016a': 'U', '\\\\u016c': 'U', '\\\\u016e': 'U', '\\\\u0170': 'U', '\\\\u0172': 'U',
  '\\\\u0169': 'u',  '\\\\u016b': 'u', '\\\\u016d': 'u', '\\\\u016f': 'u', '\\\\u0171': 'u', '\\\\u0173': 'u',
  '\\\\u0174': 'W',  '\\\\u0175': 'w',
  '\\\\u0176': 'Y',  '\\\\u0177': 'y', '\\\\u0178': 'Y',
  '\\\\u0179': 'Z',  '\\\\u017b': 'Z', '\\\\u017d': 'Z',
  '\\\\u017a': 'z',  '\\\\u017c': 'z', '\\\\u017e': 'z',
  '\\\\u0132': 'IJ', '\\\\u0133': 'ij',
  '\\\\u0152': 'Oe', '\\\\u0153': 'oe',
  '\\\\u0149': \\"'n\\", '\\\\u017f': 's'
}

/**
 * Used by \`deburr\` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
const deburrLetter = basePropertyOf(deburredLetters)

export default deburrLetter
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/equalArrays.ts 1`] = `
"import SetCache from './SetCache.js'
import some from '../some.js'
import cacheHas from './cacheHas.js'

/** Used to compose bitmasks for value comparisons. */
const COMPARE_PARTIAL_FLAG = 1
const COMPARE_UNORDERED_FLAG = 2

/**
 * A specialized version of \`baseIsEqualDeep\` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See \`baseIsEqual\` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed \`array\` and \`other\` objects.
 * @returns {boolean} Returns \`true\` if the arrays are equivalent, else \`false\`.
 */
function equalArrays(
  array: any[],
  other: any[],
  bitmask: number,
  customizer: Function,
  equalFunc: Function,
  stack: Object
): boolean {
  const isPartial = bitmask & COMPARE_PARTIAL_FLAG
  const arrLength = array.length
  const othLength = other.length

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false
  }
  // Assume cyclic values are equal.
  const stacked = stack.get(array)
  if (stacked && stack.get(other)) {
    return stacked == other
  }
  let index = -1
  let result = true
  const seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined

  stack.set(array, other)
  stack.set(other, array)

  // Ignore non-index properties.
  while (++index < arrLength) {
    let compared
    const arrValue = array[index]
    const othValue = other[index]

    if (customizer) {
      compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack)
    }
    if (compared !== undefined) {
      if (compared) {
        continue
      }
      result = false
      break
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!some(other, (othValue, othIndex) => {
        if (!cacheHas(seen, othIndex) &&
          (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex)
        }
      })) {
        result = false
        break
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false
      break
    }
  }
  stack['delete'](array)
  stack['delete'](other)
  return result
}

export default equalArrays
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/equalByTag.ts 1`] = `
"import eq from '../eq.js'
import equalArrays from './equalArrays.js'
import mapToArray from './mapToArray.js'
import setToArray from './setToArray.js'

/** Used to compose bitmasks for value comparisons. */
const COMPARE_PARTIAL_FLAG = 1
const COMPARE_UNORDERED_FLAG = 2

/** \`Object#toString\` result references. */
const boolTag = '[object Boolean]'
const dateTag = '[object Date]'
const errorTag = '[object Error]'
const mapTag = '[object Map]'
const numberTag = '[object Number]'
const regexpTag = '[object RegExp]'
const setTag = '[object Set]'
const stringTag = '[object String]'
const symbolTag = '[object Symbol]'

const arrayBufferTag = '[object ArrayBuffer]'
const dataViewTag = '[object DataView]'

/** Used to convert symbols to primitives and strings. */
const symbolValueOf = Symbol.prototype.valueOf

/**
 * A specialized version of \`baseIsEqualDeep\` for comparing objects of
 * the same \`toStringTag\`.
 *
 * **Note:** This function only supports comparing values with tags of
 * \`Boolean\`, \`Date\`, \`Error\`, \`Number\`, \`RegExp\`, or \`String\`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The \`toStringTag\` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See \`baseIsEqual\` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed \`object\` and \`other\` objects.
 * @returns {boolean} Returns \`true\` if the objects are equivalent, else \`false\`.
 */
function equalByTag(
  object: Object,
  other: Object,
  tag: string,
  bitmask: number,
  customizer: Function,
  equalFunc: Function,
  stack: Object
): boolean {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false
      }
      object = object.buffer
      other = other.buffer

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false
      }
      return true

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to \`1\` or \`0\` and dates to milliseconds.
      // Invalid dates are coerced to \`NaN\`.
      return eq(+object, +other)

    case errorTag:
      return object.name == other.name && object.message == other.message

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == \`\${other}\`

    case mapTag:
      let convert = mapToArray

    case setTag:
      const isPartial = bitmask & COMPARE_PARTIAL_FLAG
      convert || (convert = setToArray)

      if (object.size != other.size && !isPartial) {
        return false
      }
      // Assume cyclic values are equal.
      const stacked = stack.get(object)
      if (stacked) {
        return stacked == other
      }
      bitmask |= COMPARE_UNORDERED_FLAG

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other)
      const result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack)
      stack['delete'](object)
      return result

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other)
      }
  }
  return false
}

export default equalByTag
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/equalObjects.ts 1`] = `
"import getAllKeys from './getAllKeys.js'

/** Used to compose bitmasks for value comparisons. */
const COMPARE_PARTIAL_FLAG = 1

/** Used to check objects for own properties. */
const hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * A specialized version of \`baseIsEqualDeep\` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See \`baseIsEqual\` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed \`object\` and \`other\` objects.
 * @returns {boolean} Returns \`true\` if the objects are equivalent, else \`false\`.
 */
function equalObjects(
  object: Object,
  other: Object,
  bitmask: number,
  customizer: Function,
  equalFunc: Function,
  stack: Object
): boolean {
  const isPartial = bitmask & COMPARE_PARTIAL_FLAG
  const objProps = getAllKeys(object)
  const objLength = objProps.length
  const othProps = getAllKeys(other)
  const othLength = othProps.length

  if (objLength != othLength && !isPartial) {
    return false
  }
  let key
  let index = objLength
  while (index--) {
    key = objProps[index]
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false
    }
  }
  // Assume cyclic values are equal.
  const stacked = stack.get(object)
  if (stacked && stack.get(other)) {
    return stacked == other
  }
  let result = true
  stack.set(object, other)
  stack.set(other, object)

  let compared
  let skipCtor = isPartial
  while (++index < objLength) {
    key = objProps[index]
    const objValue = object[key]
    const othValue = other[key]

    if (customizer) {
      compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack)
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false
      break
    }
    skipCtor || (skipCtor = key == 'constructor')
  }
  if (result && !skipCtor) {
    const objCtor = object.constructor
    const othCtor = other.constructor

    // Non \`Object\` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false
    }
  }
  stack['delete'](object)
  stack['delete'](other)
  return result
}

export default equalObjects
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/freeGlobal.ts 1`] = `
"/** Detect free variable \`global\` from Node.js. */
const freeGlobal = typeof global == 'object' && global !== null && global.Object === Object && global

export default freeGlobal
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/getAllKeys.ts 1`] = `
"import getSymbols from './getSymbols.js'
import keys from '../keys.js'

/**
 * Creates an array of own enumerable property names and symbols of \`object\`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object: Object): any[] {
  const result = keys(object)
  if (!Array.isArray(object)) {
    result.push(...getSymbols(object))
  }
  return result
}

export default getAllKeys
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/getAllKeysIn.ts 1`] = `
"import getSymbolsIn from './getSymbolsIn.js'

/**
 * Creates an array of own and inherited enumerable property names and symbols of \`object\`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object: Object): any[] {
  const result = []
  for (const key in object) {
    result.push(key)
  }
  if (!Array.isArray(object)) {
    result.push(...getSymbolsIn(object))
  }
  return result
}

export default getAllKeysIn
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/getHolder.ts 1`] = `
"/**
 * Gets the argument placeholder value for \`func\`.
 *
 * @private
 * @param {Function} func The function to inspect.
 * @returns {*} Returns the placeholder value.
 */
function getHolder(func: Function): any {
  const object = func
  return object.placeholder
}

export default getHolder
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/getMatchData.ts 1`] = `
"import isStrictComparable from './isStrictComparable.js'
import keys from '../keys.js'

/**
 * Gets the property names, values, and compare flags of \`object\`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of \`object\`.
 */
function getMatchData(object: Object): any[] {
  const result = keys(object)
  let length = result.length

  while (length--) {
    const key = result[length]
    const value = object[key]
    result[length] = [key, value, isStrictComparable(value)]
  }
  return result
}

export default getMatchData
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/getSymbols.ts 1`] = `
"/** Built-in value references. */
const propertyIsEnumerable = Object.prototype.propertyIsEnumerable

/* Built-in method references for those with the same name as other \`lodash\` methods. */
const nativeGetSymbols = Object.getOwnPropertySymbols

/**
 * Creates an array of the own enumerable symbols of \`object\`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
function getSymbols(object: Object): any[] {
  if (object == null) {
    return []
  }
  object = Object(object)
  return nativeGetSymbols(object).filter((symbol) => propertyIsEnumerable.call(object, symbol))
}

export default getSymbols
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/getSymbolsIn.ts 1`] = `
"import getSymbols from './getSymbols.js'

/**
 * Creates an array of the own and inherited enumerable symbols of \`object\`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
function getSymbolsIn(object: Object): any[] {
  const result = []
  while (object) {
    result.push(...getSymbols(object))
    object = Object.getPrototypeOf(Object(object))
  }
  return result
}

export default getSymbolsIn
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/getTag.ts 1`] = `
"const toString = Object.prototype.toString

/**
 * Gets the \`toStringTag\` of \`value\`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the \`toStringTag\`.
 */
function getTag(value: any): string {
  if (value == null) {
    return value === undefined ? '[object Undefined]' : '[object Null]'
  }
  return toString.call(value)  
}

export default getTag
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/hasUnicode.ts 1`] = `
"/** Used to compose unicode character classes. */
const rsAstralRange = '\\\\\\\\ud800-\\\\\\\\udfff'
const rsComboMarksRange = '\\\\\\\\u0300-\\\\\\\\u036f'
const reComboHalfMarksRange = '\\\\\\\\ufe20-\\\\\\\\ufe2f'
const rsComboSymbolsRange = '\\\\\\\\u20d0-\\\\\\\\u20ff'
const rsComboMarksExtendedRange = '\\\\\\\\u1ab0-\\\\\\\\u1aff'
const rsComboMarksSupplementRange = '\\\\\\\\u1dc0-\\\\\\\\u1dff'
const rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange
const rsVarRange = '\\\\\\\\ufe0e\\\\\\\\ufe0f'

/** Used to compose unicode capture groups. */
const rsZWJ = '\\\\\\\\u200d'

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
const reHasUnicode = RegExp(\`[\${rsZWJ + rsAstralRange + rsComboRange + rsVarRange}]\`)

/**
 * Checks if \`string\` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns \`true\` if a symbol is found, else \`false\`.
 */
function hasUnicode(string: string): boolean {
  return reHasUnicode.test(string)
}

export default hasUnicode
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/initCloneObject.ts 1`] = `
"import isPrototype from './isPrototype.js'

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object: Object): Object {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? Object.create(Object.getPrototypeOf(object))
    : {}
}

export default initCloneObject
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/isFlattenable.ts 1`] = `
"import isArguments from '../isArguments.js'

/** Built-in value reference. */
const spreadableSymbol = Symbol.isConcatSpreadable

/**
 * Checks if \`value\` is a flattenable \`arguments\` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is flattenable, else \`false\`.
 */
function isFlattenable(value: any): boolean {
  return Array.isArray(value) || isArguments(value) ||
    !!(value && value[spreadableSymbol])
}

export default isFlattenable
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/isIndex.ts 1`] = `
"/** Used as references for various \`Number\` constants. */
const MAX_SAFE_INTEGER = 9007199254740991

/** Used to detect unsigned integer values. */
const reIsUint = /^(?:0|[1-9]\\\\d*)$/

/**
 * Checks if \`value\` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns \`true\` if \`value\` is a valid index, else \`false\`.
 */
function isIndex(value: any, length: number): boolean {
  const type = typeof value
  length = length == null ? MAX_SAFE_INTEGER : length

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length)
}

export default isIndex
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/isIterateeCall.ts 1`] = `
"import isArrayLike from '../isArrayLike.js'
import isIndex from './isIndex.js'

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns \`true\` if the arguments are from an iteratee call,
 *  else \`false\`.
 */

function isIterateeCall(value: any, index: any, object: any): boolean {
  if (!isObject(object)) {
    return false;
  }
  const type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

export default isIterateeCall
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/isKey.ts 1`] = `
"import isSymbol from '../isSymbol.js'

/** Used to match property names within property paths. */
const reIsDeepProp = /\\\\.|\\\\[(?:[^[\\\\]]*|([\\"'])(?:(?!\\\\1)[^\\\\\\\\]|\\\\\\\\.)*?\\\\1)\\\\]/
const reIsPlainProp = /^\\\\w*$/

/**
 * Checks if \`value\` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns \`true\` if \`value\` is a property name, else \`false\`.
 */
function isKey(value: any, object: Object): boolean {
  if (Array.isArray(value)) {
    return false
  }
  const type = typeof value
  if (type == 'number' || type == 'boolean' || value == null || isSymbol(value)) {
    return true
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object))
}

export default isKey
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/isPrototype.ts 1`] = `
"/** Used for built-in method references. */
const objectProto = Object.prototype

/**
 * Checks if \`value\` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a prototype, else \`false\`.
 */
function isPrototype(value: any): boolean {
  const Ctor = value && value.constructor
  const proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto

  return value === proto
}

export default isPrototype
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/isStrictComparable.ts 1`] = `
"import isObject from '../isObject.js'

/**
 * Checks if \`value\` is suitable for strict equality comparisons, i.e. \`===\`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` if suitable for strict
 *  equality comparisons, else \`false\`.
 */
function isStrictComparable(value: any): boolean {
  return value === value && !isObject(value)
}

export default isStrictComparable
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/iteratorToArray.ts 1`] = `
"/**
 * Converts \`iterator\` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator: Object): any[] {
  let data
  const result = []

  while (!(data = iterator.next()).done) {
    result.push(data.value)
  }
  return result
}

export default iteratorToArray
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/mapToArray.ts 1`] = `
"/**
 * Converts \`map\` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map: Object): any[] {
  let index = -1
  const result = new Array(map.size)

  map.forEach((value, key) => {
    result[++index] = [key, value]
  })
  return result
}

export default mapToArray
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/matchesStrictComparable.ts 1`] = `
"/**
 * A specialized version of \`matchesProperty\` for source values suitable
 * for strict equality comparisons, i.e. \`===\`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key: string, srcValue: any): Function {
  return (object) => {
    if (object == null) {
      return false
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)))
  }
}

export default matchesStrictComparable
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/memoizeCapped.ts 1`] = `
"import memoize from '../memoize.js'

/** Used as the maximum memoize cache size. */
const MAX_MEMOIZE_SIZE = 500

/**
 * A specialized version of \`memoize\` which clears the memoized function's
 * cache when it exceeds \`MAX_MEMOIZE_SIZE\`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func: Function): Function {
  const result = memoize(func, (key) => {
    const { cache } = result
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear()
    }
    return key
  })

  return result
}

export default memoizeCapped
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/metaMap.ts 1`] = `
"export default new WeakMap
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/nodeTypes.ts 1`] = `
"import freeGlobal from './freeGlobal.js'

/** Detect free variable \`exports\`. */
const freeExports = typeof exports == 'object' && exports !== null && !exports.nodeType && exports

/** Detect free variable \`module\`. */
const freeModule = freeExports && typeof module == 'object' && module !== null && !module.nodeType && module

/** Detect the popular CommonJS extension \`module.exports\`. */
const moduleExports = freeModule && freeModule.exports === freeExports

/** Detect free variable \`process\` from Node.js. */
const freeProcess = moduleExports && freeGlobal.process

/** Used to access faster Node.js helpers. */
const nodeTypes = ((() => {
  try {
    /* Detect public \`util.types\` helpers for Node.js v10+. */
    /* Node.js deprecation code: DEP0103. */
    const typesHelper = freeModule && freeModule.require && freeModule.require('util').types
    return typesHelper
      ? typesHelper
      /* Legacy process.binding('util') for Node.js earlier than v10. */
      : freeProcess && freeProcess.binding && freeProcess.binding('util')
  } catch (e) {}
})())

export default nodeTypes
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/parent.ts 1`] = `
"import baseGet from './baseGet.js'
import slice from '../slice.js'

/**
 * Gets the parent value at \`path\` of \`object\`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object: Object, path: any[]): any {
  return path.length < 2 ? object : baseGet(object, slice(path, 0, -1))
}

export default parent
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/reEscape.ts 1`] = `
"/** Used to match template delimiters. */
const reEscape = /<%-([\\\\s\\\\S]+?)%>/g

export default reEscape
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/reEvaluate.ts 1`] = `
"/** Used to match template delimiters. */
const reEvaluate = /<%([\\\\s\\\\S]+?)%>/g

export default reEvaluate
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/reInterpolate.ts 1`] = `
"/** Used to match template delimiters. */
const reInterpolate = /<%=([\\\\s\\\\S]+?)%>/g

export default reInterpolate
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/root.ts 1`] = `
"import freeGlobal from './freeGlobal.js'

/** Detect free variable \`self\`. */
const freeSelf = typeof self == 'object' && self !== null && self.Object === Object && self

/** Used as a reference to the global object. */
const root = freeGlobal || freeSelf || Function('return this')()

export default root
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/setToArray.ts 1`] = `
"/**
 * Converts \`set\` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set: Object): any[] {
  let index = -1
  const result = new Array(set.size)

  set.forEach((value) => {
    result[++index] = value
  })
  return result
}

export default setToArray
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/setToPairs.ts 1`] = `
"/**
 * Converts \`set\` to its value-value pairs.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the value-value pairs.
 */
function setToPairs(set: Object): any[] {
  let index = -1
  const result = new Array(set.size)

  set.forEach((value) => {
    result[++index] = [value, value]
  })
  return result
}

export default setToPairs
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/setToString.ts 1`] = `
"/**
 * Sets the \`toString\` method of \`func\` to return \`string\`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The \`toString\` result.
 * @returns {Function} Returns \`func\`.
 */
function setToString(func: Function, string: Function): Function {
  return Object.defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': () => string,
    'writable': true
  })
}

export default setToString
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/strictIndexOf.ts 1`] = `
"/**
 * A specialized version of \`indexOf\` which performs strict equality
 * comparisons of values, i.e. \`===\`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 */
function strictIndexOf(array: any[], value: any, fromIndex: number): number {
  let index = fromIndex - 1
  const { length } = array

  while (++index < length) {
    if (array[index] === value) {
      return index
    }
  }
  return -1
}

export default strictIndexOf
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/strictLastIndexOf.ts 1`] = `
"/**
 * A specialized version of \`lastIndexOf\` which performs strict equality
 * comparisons of values, i.e. \`===\`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 */
function strictLastIndexOf(array: any[], value: any, fromIndex: number): number {
  let index = fromIndex + 1
  while (index--) {
    if (array[index] === value) {
      return index
    }
  }
  return index
}

export default strictLastIndexOf
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/stringSize.ts 1`] = `
"import asciiSize from './asciiSize.js'
import hasUnicode from './hasUnicode.js'
import unicodeSize from './unicodeSize.js'

/**
 * Gets the number of symbols in \`string\`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */
function stringSize(string: string): number {
  return hasUnicode(string) ? unicodeSize(string) : asciiSize(string)
}

export default stringSize
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/stringToArray.ts 1`] = `
"import asciiToArray from './asciiToArray.js'
import hasUnicode from './hasUnicode.js'
import unicodeToArray from './unicodeToArray.js'

/**
 * Converts \`string\` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string: string): any[] {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string)
}

export default stringToArray
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/stringToPath.ts 1`] = `
"import memoizeCapped from './memoizeCapped.js'

const charCodeOfDot = '.'.charCodeAt(0)
const reEscapeChar = /\\\\\\\\(\\\\\\\\)?/g
const rePropName = RegExp(
  // Match anything that isn't a dot or bracket.
  '[^.[\\\\\\\\]]+' + '|' +
  // Or match property names within brackets.
  '\\\\\\\\[(?:' +
    // Match a non-string expression.
    '([^\\"\\\\'].*)' + '|' +
    // Or match strings (supports escaping characters).
    '([\\"\\\\'])((?:(?!\\\\\\\\2)[^\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*?)\\\\\\\\2' +
  ')\\\\\\\\]'+ '|' +
  // Or match \\"\\" as the space between consecutive dots or empty brackets.
  '(?=(?:\\\\\\\\.|\\\\\\\\[\\\\\\\\])(?:\\\\\\\\.|\\\\\\\\[\\\\\\\\]|$))'
, 'g')

/**
 * Converts \`string\` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
const stringToPath = memoizeCapped((string: string): any[] => {
  const result = []
  if (string.charCodeAt(0) === charCodeOfDot) {
    result.push('')
  }
  string.replace(rePropName, (match, expression, quote, subString) => {
    let key = match
    if (quote) {
      key = subString.replace(reEscapeChar, '$1')
    }
    else if (expression) {
      key = expression.trim()
    }
    result.push(key)
  })
  return result
})

export default stringToPath
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/toKey.ts 1`] = `
"import isSymbol from '../isSymbol.js'

/** Used as references for various \`Number\` constants. */
const INFINITY = 1 / 0

/**
 * Converts \`value\` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value: any): string | symbol {
  if (typeof value == 'string' || isSymbol(value)) {
    return value
  }
  const result = \`\${value}\`
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result
}

export default toKey
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/unicodeSize.ts 1`] = `
"/** Used to compose unicode character classes. */
const rsAstralRange = '\\\\\\\\ud800-\\\\\\\\udfff'
const rsComboMarksRange = '\\\\\\\\u0300-\\\\\\\\u036f'
const reComboHalfMarksRange = '\\\\\\\\ufe20-\\\\\\\\ufe2f'
const rsComboSymbolsRange = '\\\\\\\\u20d0-\\\\\\\\u20ff'
const rsComboMarksExtendedRange = '\\\\\\\\u1ab0-\\\\\\\\u1aff'
const rsComboMarksSupplementRange = '\\\\\\\\u1dc0-\\\\\\\\u1dff'
const rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange
const rsVarRange = '\\\\\\\\ufe0e\\\\\\\\ufe0f'

/** Used to compose unicode capture groups. */
const rsAstral = \`[\${rsAstralRange}]\`
const rsCombo = \`[\${rsComboRange}]\`
const rsFitz = '\\\\\\\\ud83c[\\\\\\\\udffb-\\\\\\\\udfff]'
const rsModifier = \`(?:\${rsCombo}|\${rsFitz})\`
const rsNonAstral = \`[^\${rsAstralRange}]\`
const rsRegional = '(?:\\\\\\\\ud83c[\\\\\\\\udde6-\\\\\\\\uddff]){2}'
const rsSurrPair = '[\\\\\\\\ud800-\\\\\\\\udbff][\\\\\\\\udc00-\\\\\\\\udfff]'
const rsZWJ = '\\\\\\\\u200d'

/** Used to compose unicode regexes. */
const reOptMod = \`\${rsModifier}?\`
const rsOptVar = \`[\${rsVarRange}]?\`
const rsOptJoin = \`(?:\${rsZWJ}(?:\${[rsNonAstral, rsRegional, rsSurrPair].join('|')})\${rsOptVar + reOptMod})*\`
const rsSeq = rsOptVar + reOptMod + rsOptJoin
const rsNonAstralCombo = \`\${rsNonAstral}\${rsCombo}?\`
const rsSymbol = \`(?:\${[rsNonAstralCombo, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')})\`

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
const reUnicode = RegExp(\`\${rsFitz}(?=\${rsFitz})|\${rsSymbol + rsSeq}\`, 'g')

/**
 * Gets the size of a Unicode \`string\`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
function unicodeSize(string: string): number {
  let result = reUnicode.lastIndex = 0
  while (reUnicode.test(string)) {
    ++result
  }
  return result
}

export default unicodeSize
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/unicodeToArray.ts 1`] = `
"/** Used to compose unicode character classes. */
const rsAstralRange = '\\\\\\\\ud800-\\\\\\\\udfff'
const rsComboMarksRange = '\\\\\\\\u0300-\\\\\\\\u036f'
const reComboHalfMarksRange = '\\\\\\\\ufe20-\\\\\\\\ufe2f'
const rsComboSymbolsRange = '\\\\\\\\u20d0-\\\\\\\\u20ff'
const rsComboMarksExtendedRange = '\\\\\\\\u1ab0-\\\\\\\\u1aff'
const rsComboMarksSupplementRange = '\\\\\\\\u1dc0-\\\\\\\\u1dff'
const rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange
const rsVarRange = '\\\\\\\\ufe0e\\\\\\\\ufe0f'

/** Used to compose unicode capture groups. */
const rsAstral = \`[\${rsAstralRange}]\`
const rsCombo = \`[\${rsComboRange}]\`
const rsFitz = '\\\\\\\\ud83c[\\\\\\\\udffb-\\\\\\\\udfff]'
const rsModifier = \`(?:\${rsCombo}|\${rsFitz})\`
const rsNonAstral = \`[^\${rsAstralRange}]\`
const rsRegional = '(?:\\\\\\\\ud83c[\\\\\\\\udde6-\\\\\\\\uddff]){2}'
const rsSurrPair = '[\\\\\\\\ud800-\\\\\\\\udbff][\\\\\\\\udc00-\\\\\\\\udfff]'
const rsZWJ = '\\\\\\\\u200d'

/** Used to compose unicode regexes. */
const reOptMod = \`\${rsModifier}?\`
const rsOptVar = \`[\${rsVarRange}]?\`
const rsOptJoin = \`(?:\${rsZWJ}(?:\${[rsNonAstral, rsRegional, rsSurrPair].join('|')})\${rsOptVar + reOptMod})*\`
const rsSeq = rsOptVar + reOptMod + rsOptJoin
const rsNonAstralCombo = \`\${rsNonAstral}\${rsCombo}?\`
const rsSymbol = \`(?:\${[rsNonAstralCombo, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')})\`

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
const reUnicode = RegExp(\`\${rsFitz}(?=\${rsFitz})|\${rsSymbol + rsSeq}\`, 'g')

/**
 * Converts a Unicode \`string\` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string: string): any[] {
  return string.match(reUnicode) || []
}

export default unicodeToArray
"
`;

exports[`E2E: lodash transforms all lodash internals to TypeScript: internal/unicodeWords.ts 1`] = `
"/** Used to compose unicode character classes. */
const rsAstralRange = '\\\\\\\\ud800-\\\\\\\\udfff'
const rsComboMarksRange = '\\\\\\\\u0300-\\\\\\\\u036f'
const reComboHalfMarksRange = '\\\\\\\\ufe20-\\\\\\\\ufe2f'
const rsComboSymbolsRange = '\\\\\\\\u20d0-\\\\\\\\u20ff'
const rsComboMarksExtendedRange = '\\\\\\\\u1ab0-\\\\\\\\u1aff'
const rsComboMarksSupplementRange = '\\\\\\\\u1dc0-\\\\\\\\u1dff'
const rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange
const rsDingbatRange = '\\\\\\\\u2700-\\\\\\\\u27bf'
const rsLowerRange = 'a-z\\\\\\\\xdf-\\\\\\\\xf6\\\\\\\\xf8-\\\\\\\\xff'
const rsMathOpRange = '\\\\\\\\xac\\\\\\\\xb1\\\\\\\\xd7\\\\\\\\xf7'
const rsNonCharRange = '\\\\\\\\x00-\\\\\\\\x2f\\\\\\\\x3a-\\\\\\\\x40\\\\\\\\x5b-\\\\\\\\x60\\\\\\\\x7b-\\\\\\\\xbf'
const rsPunctuationRange = '\\\\\\\\u2000-\\\\\\\\u206f'
const rsSpaceRange = ' \\\\\\\\t\\\\\\\\x0b\\\\\\\\f\\\\\\\\xa0\\\\\\\\ufeff\\\\\\\\n\\\\\\\\r\\\\\\\\u2028\\\\\\\\u2029\\\\\\\\u1680\\\\\\\\u180e\\\\\\\\u2000\\\\\\\\u2001\\\\\\\\u2002\\\\\\\\u2003\\\\\\\\u2004\\\\\\\\u2005\\\\\\\\u2006\\\\\\\\u2007\\\\\\\\u2008\\\\\\\\u2009\\\\\\\\u200a\\\\\\\\u202f\\\\\\\\u205f\\\\\\\\u3000'
const rsUpperRange = 'A-Z\\\\\\\\xc0-\\\\\\\\xd6\\\\\\\\xd8-\\\\\\\\xde'
const rsVarRange = '\\\\\\\\ufe0e\\\\\\\\ufe0f'
const rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange

/** Used to compose unicode capture groups. */
const rsApos = \\"['\\\\u2019]\\"
const rsBreak = \`[\${rsBreakRange}]\`
const rsCombo = \`[\${rsComboRange}]\`
const rsDigit = '\\\\\\\\d'
const rsDingbat = \`[\${rsDingbatRange}]\`
const rsLower = \`[\${rsLowerRange}]\`
const rsMisc = \`[^\${rsAstralRange}\${rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange}]\`
const rsFitz = '\\\\\\\\ud83c[\\\\\\\\udffb-\\\\\\\\udfff]'
const rsModifier = \`(?:\${rsCombo}|\${rsFitz})\`
const rsNonAstral = \`[^\${rsAstralRange}]\`
const rsRegional = '(?:\\\\\\\\ud83c[\\\\\\\\udde6-\\\\\\\\uddff]){2}'
const rsSurrPair = '[\\\\\\\\ud800-\\\\\\\\udbff][\\\\\\\\udc00-\\\\\\\\udfff]'
const rsUpper = \`[\${rsUpperRange}]\`
const rsZWJ = '\\\\\\\\u200d'

/** Used to compose unicode regexes. */
const rsMiscLower = \`(?:\${rsLower}|\${rsMisc})\`
const rsMiscUpper = \`(?:\${rsUpper}|\${rsMisc})\`
const rsOptContrLower = \`(?:\${rsApos}(?:d|ll|m|re|s|t|ve))?\`
const rsOptContrUpper = \`(?:\${rsApos}(?:D|LL|M|RE|S|T|VE))?\`
const reOptMod = \`\${rsModifier}?\`
const rsOptVar = \`[\${rsVarRange}]?\`
const rsOptJoin = \`(?:\${rsZWJ}(?:\${[rsNonAstral, rsRegional, rsSurrPair].join('|')})\${rsOptVar + reOptMod})*\`
const rsOrdLower = '\\\\\\\\d*(?:1st|2nd|3rd|(?![123])\\\\\\\\dth)(?=\\\\\\\\b|[A-Z_])'
const rsOrdUpper = '\\\\\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\\\\\dTH)(?=\\\\\\\\b|[a-z_])'
const rsSeq = rsOptVar + reOptMod + rsOptJoin
const rsEmoji = \`(?:\${[rsDingbat, rsRegional, rsSurrPair].join('|')})\${rsSeq}\`

/**
 * Splits a Unicode \`string\` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of \`string\`.
 */
const unicodeWords = RegExp.prototype.exec.bind(RegExp([
  \`\${rsUpper}?\${rsLower}+\${rsOptContrLower}(?=\${[rsBreak, rsUpper, '$'].join('|')})\`,
  \`\${rsMiscUpper}+\${rsOptContrUpper}(?=\${[rsBreak, rsUpper + rsMiscLower, '$'].join('|')})\`,
  \`\${rsUpper}?\${rsMiscLower}+\${rsOptContrLower}\`,
  \`\${rsUpper}+\${rsOptContrUpper}\`,
  rsOrdUpper,
  rsOrdLower,
  \`\${rsDigit}+\`,
  rsEmoji
].join('|'), 'g'))

export default unicodeWords
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: add.ts 1`] = `
"import createMathOperation from './.internal/createMathOperation.js'

/**
 * Adds two numbers.
 *
 * @since 3.4.0
 * @category Math
 * @param {number} augend The first number in an addition.
 * @param {number} addend The second number in an addition.
 * @returns {number} Returns the total.
 * @example
 *
 * add(6, 4)
 * // => 10
 */
const add = createMathOperation((augend: number, addend: number): number => augend + addend, 0)

export default add
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: after.ts 1`] = `
"/**
 * The opposite of \`before\`. This method creates a function that invokes
 * \`func\` once it's called \`n\` or more times.
 *
 * @since 0.1.0
 * @category Function
 * @param {number} n The number of calls before \`func\` is invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * const saves = ['profile', 'settings']
 * const done = after(saves.length, () => console.log('done saving!'))
 *
 * forEach(saves, type => asyncSave({ 'type': type, 'complete': done }))
 * // => Logs 'done saving!' after the two async saves have completed.
 */
function after(n: number, func: Function): Function {
  if (typeof func != 'function') {
    throw new TypeError('Expected a function')
  }
  return function(...args) {
    if (--n < 1) {
      return func.apply(this, args)
    }
  }
}

export default after
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: at.ts 1`] = `
"import baseAt from './.internal/baseAt.js'

/**
 * Creates an array of values corresponding to \`paths\` of \`object\`.
 *
 * @since 1.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Array} Returns the picked values.
 * @example
 *
 * const object = { 'a': [{ 'b': { 'c': 3 } }, 4] }
 *
 * at(object, ['a[0].b.c', 'a[1]'])
 * // => [3, 4]
 */
const at = (...paths: Object): any[] => baseAt(paths)

export default at
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: attempt.ts 1`] = `
"import isError from './isError.js'

/**
 * Attempts to invoke \`func\`, returning either the result or the caught error
 * object. Any additional arguments are provided to \`func\` when it's invoked.
 *
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke \`func\` with.
 * @returns {*} Returns the \`func\` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * const elements = attempt(selector =>
 *   document.querySelectorAll(selector), '>_>')
 *
 * if (isError(elements)) {
 *   elements = []
 * }
 */
function attempt(func: Function, ...args: any[]): any {
  try {
    return func(...args)
  } catch (e) {
    return isError(e) ? e : new Error(e)
  }
}

export default attempt
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: before.ts 1`] = `
"/**
 * Creates a function that invokes \`func\`, with the \`this\` binding and arguments
 * of the created function, while it's called less than \`n\` times. Subsequent
 * calls to the created function return the result of the last \`func\` invocation.
 *
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which \`func\` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', before(5, addContactToList))
 * // => Allows adding up to 4 contacts to the list.
 */
function before(n: number, func: Function): Function {
  let result
  if (typeof func != 'function') {
    throw new TypeError('Expected a function')
  }
  return function(...args) {
    if (--n > 0) {
      result = func.apply(this, args)
    }
    if (n <= 1) {
      func = undefined
    }
    return result
  }
}

export default before
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: camelCase.ts 1`] = `
"import upperFirst from './upperFirst.js'
import words from './words.js'

/**
 * Converts \`string\` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @see lowerCase, kebabCase, snakeCase, startCase, upperCase, upperFirst
 * @example
 *
 * camelCase('Foo Bar')
 * // => 'fooBar'
 *
 * camelCase('--foo-bar--')
 * // => 'fooBar'
 *
 * camelCase('__FOO_BAR__')
 * // => 'fooBar'
 */
const camelCase = (string) => (
  words(\`\${string}\`.replace(/['\\\\u2019]/g, '')).reduce((result, word, index) => {
    word = word.toLowerCase()
    return result + (index ? upperFirst(word) : word)
  }, '')
)

export default camelCase
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: capitalize.ts 1`] = `
"import upperFirst from './upperFirst.js'

/**
 * Converts the first character of \`string\` to upper case and the remaining
 * to lower case.
 *
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * capitalize('FRED')
 * // => 'Fred'
 */
const capitalize = (string: string): string => upperFirst(string.toLowerCase())


export default capitalize
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: castArray.ts 1`] = `
"
/**
 * Casts \`value\` as an array if it's not one.
 *
 * @since 4.4.0
 * @category Lang
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast array.
 * @example
 *
 * castArray(1)
 * // => [1]
 *
 * castArray({ 'a': 1 })
 * // => [{ 'a': 1 }]
 *
 * castArray('abc')
 * // => ['abc']
 *
 * castArray(null)
 * // => [null]
 *
 * castArray(undefined)
 * // => [undefined]
 *
 * castArray()
 * // => []
 *
 * const array = [1, 2, 3]
 * console.log(castArray(array) === array)
 * // => true
 */
function castArray(...args: any): any[] {
  if (!args.length) {
    return []
  }
  const value = args[0]
  return Array.isArray(value) ? value : [value]
}

export default castArray
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: ceil.ts 1`] = `
"import createRound from './.internal/createRound.js'

/**
 * Computes \`number\` rounded up to \`precision\`. (Round up: the smallest integer greater than or equal to a given number.)
 *
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round up.
 * @param {number} [precision=0] The precision to round up to.
 * @returns {number} Returns the rounded up number.
 * @example
 *
 * ceil(4.006)
 * // => 5
 *
 * ceil(6.004, 2)
 * // => 6.01
 *
 * ceil(6040, -2)
 * // => 6100
 */
const ceil = createRound('ceil')

export default ceil
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: chunk.ts 1`] = `
"import slice from './slice.js'

/**
 * Creates an array of elements split into groups the length of \`size\`.
 * If \`array\` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * chunk(['a', 'b', 'c', 'd'], 2)
 * // => [['a', 'b'], ['c', 'd']]
 *
 * chunk(['a', 'b', 'c', 'd'], 3)
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk(array: any[], size: number): any[] {
  size = Math.max(size, 0)
  const length = array == null ? 0 : array.length
  if (!length || size < 1) {
    return []
  }
  let index = 0
  let resIndex = 0
  const result = new Array(Math.ceil(length / size))

  while (index < length) {
    result[resIndex++] = slice(array, index, (index += size))
  }
  return result
}

export default chunk
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: clamp.as.ts 1`] = `
"/**
 * Clamps \`number\` within the inclusive \`lower\` and \`upper\` bounds.
 *
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * clamp(-10, -5, 5)
 * // => -5
 *
 * clamp(10, -5, 5)
 * // => 5
 */
export function clamp(number: f64, lower: f64, upper: f64): f64 {
  number = +number
  lower = +lower
  upper = +upper
  lower = lower === lower ? lower : 0
  upper = upper === upper ? upper : 0
  if (number === number) {
    number = number <= upper ? number : upper
    number = number >= lower ? number : lower
  }
  return number
}

"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: clamp.namedexport.ts 1`] = `
"/**
 * Clamps \`number\` within the inclusive \`lower\` and \`upper\` bounds.
 *
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * clamp(-10, -5, 5)
 * // => -5
 *
 * clamp(10, -5, 5)
 * // => 5
 */
export function clamp(number: number, lower: number, upper: number): number {
  number = +number
  lower = +lower
  upper = +upper
  lower = lower === lower ? lower : 0
  upper = upper === upper ? upper : 0
  if (number === number) {
    number = number <= upper ? number : upper
    number = number >= lower ? number : lower
  }
  return number
}

"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: clamp.ts 1`] = `
"/**
 * Clamps \`number\` within the inclusive \`lower\` and \`upper\` bounds.
 *
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * clamp(-10, -5, 5)
 * // => -5
 *
 * clamp(10, -5, 5)
 * // => 5
 */
function clamp(number: number, lower: number, upper: number): number {
  number = +number
  lower = +lower
  upper = +upper
  lower = lower === lower ? lower : 0
  upper = upper === upper ? upper : 0
  if (number === number) {
    number = number <= upper ? number : upper
    number = number >= lower ? number : lower
  }
  return number
}

export default clamp
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: clamp.wasm 1`] = `
" asm   \`||||\`   p    Amemory table clamp  	 A 
gb   !  ! !  a| D        !  a| D        !    a@   e|   !    f|   !    "
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: clone.ts 1`] = `
"import baseClone from './.internal/baseClone.js'

/** Used to compose bitmasks for cloning. */
const CLONE_SYMBOLS_FLAG = 4

/**
 * Creates a shallow clone of \`value\`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, \`Object\` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of \`arguments\` objects are cloned
 * as plain objects. Object inheritance is preserved. An empty object is
 * returned for uncloneable values such as error objects, functions, DOM nodes,
 * and WeakMaps.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see cloneDeep
 * @example
 *
 * const objects = [{ 'a': 1 }, { 'b': 2 }]
 *
 * const shallow = clone(objects)
 * console.log(shallow[0] === objects[0])
 * // => true
 */
function clone(value: any): any {
  return baseClone(value, CLONE_SYMBOLS_FLAG)
}

export default clone
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: cloneDeep.ts 1`] = `
"import baseClone from './.internal/baseClone.js'

/** Used to compose bitmasks for cloning. */
const CLONE_DEEP_FLAG = 1
const CLONE_SYMBOLS_FLAG = 4

/**
 * This method is like \`clone\` except that it recursively clones \`value\`.
 * Object inheritance is preserved.
 *
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see clone
 * @example
 *
 * const objects = [{ 'a': 1 }, { 'b': 2 }]
 *
 * const deep = cloneDeep(objects)
 * console.log(deep[0] === objects[0])
 * // => false
 */
function cloneDeep(value: any): any {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
}

export default cloneDeep
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: cloneDeepWith.ts 1`] = `
"import baseClone from './.internal/baseClone.js'

/** Used to compose bitmasks for cloning. */
const CLONE_DEEP_FLAG = 1
const CLONE_SYMBOLS_FLAG = 4

/**
 * This method is like \`cloneWith\` except that it recursively clones \`value\`.
 * The customizer is invoked with up to four arguments
 * (value [, index|key, object, stack]).
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the deep cloned value.
 * @see cloneWith
 * @example
 *
 * function customizer(value) {
 *   if (isElement(value)) {
 *     return value.cloneNode(true)
 *   }
 * }
 *
 * const el = cloneDeepWith(document.body, customizer)
 *
 * console.log(el === document.body)
 * // => false
 * console.log(el.nodeName)
 * // => 'BODY'
 * console.log(el.childNodes.length)
 * // => 20
 */
function cloneDeepWith(value: any, customizer: Function): any {
  customizer = typeof customizer == 'function' ? customizer : undefined
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer)
}

export default cloneDeepWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: cloneWith.ts 1`] = `
"import baseClone from './.internal/baseClone.js'

/** Used to compose bitmasks for cloning. */
const CLONE_SYMBOLS_FLAG = 4

/**
 * This method is like \`clone\` except that it accepts \`customizer\` which
 * is invoked to produce the cloned value. If \`customizer\` returns \`undefined\`,
 * cloning is handled by the method instead. The \`customizer\` is invoked with
 * one argument (value).
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the cloned value.
 * @see cloneDeepWith
 * @example
 *
 * function customizer(value) {
 *   if (isElement(value)) {
 *     return value.cloneNode(false)
 *   }
 * }
 *
 * const el = cloneWith(document.body, customizer)
 *
 * console.log(el === document.body)
 * // => false
 * console.log(el.nodeName)
 * // => 'BODY'
 * console.log(el.childNodes.length)
 * // => 0
 */
function cloneWith(value: any, customizer: Function): any {
  customizer = typeof customizer == 'function' ? customizer : undefined
  return baseClone(value, CLONE_SYMBOLS_FLAG, customizer)
}

export default cloneWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: compact.ts 1`] = `
"/**
 * Creates an array with all falsey values removed. The values \`false\`, \`null\`,
 * \`0\`, \`\\"\\"\`, \`undefined\`, and \`NaN\` are falsey.
 *
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * compact([0, 1, false, 2, '', 3])
 * // => [1, 2, 3]
 */
function compact(array: any[]): any[] {
  let resIndex = 0
  const result = []

  if (array == null) {
    return result
  }

  for (const value of array) {
    if (value) {
      result[resIndex++] = value
    }
  }
  return result
}

export default compact
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: cond.ts 1`] = `
"import map from './map.js'

/**
 * Creates a function that iterates over \`pairs\` and invokes the corresponding
 * function of the first predicate to return truthy. The predicate-function
 * pairs are invoked with the \`this\` binding and arguments of the created
 * function.
 *
 * @since 4.0.0
 * @category Util
 * @param {Array} pairs The predicate-function pairs.
 * @returns {Function} Returns the new composite function.
 * @example
 *
 * const func = cond([
 *   [matches({ 'a': 1 }),         () => 'matches A'],
 *   [conforms({ 'b': isNumber }), () => 'matches B'],
 *   [() => true,                  () => 'no match']
 * ])
 *
 * func({ 'a': 1, 'b': 2 })
 * // => 'matches A'
 *
 * func({ 'a': 0, 'b': 1 })
 * // => 'matches B'
 *
 * func({ 'a': '1', 'b': '2' })
 * // => 'no match'
 */
function cond(pairs: any[]): Function {
  const length = pairs == null ? 0 : pairs.length

  pairs = !length ? [] : map(pairs, (pair) => {
    if (typeof pair[1] != 'function') {
      throw new TypeError('Expected a function')
    }
    return [pair[0], pair[1]]
  })

  return (...args) => {
    for (const pair of pairs) {
      if (pair[0].apply(this, args)) {
        return pair[1].apply(this, args)
      }
    }
  }
}

export default cond
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: conforms.ts 1`] = `
"import baseClone from './.internal/baseClone.js'
import baseConforms from './.internal/baseConforms.js'

/** Used to compose bitmasks for cloning. */
const CLONE_DEEP_FLAG = 1

/**
 * Creates a function that invokes the predicate properties of \`source\` with
 * the corresponding property values of a given object, returning \`true\` if
 * all predicates return truthy, else \`false\`.
 *
 * **Note:** The created function is equivalent to \`conformsTo\` with
 * \`source\` partially applied.
 *
 * @since 4.0.0
 * @category Util
 * @param {Object} source The object of property predicates to conform to.
 * @returns {Function} Returns the new spec function.
 * @example
 *
 * const objects = [
 *   { 'a': 2, 'b': 1 },
 *   { 'a': 1, 'b': 2 }
 * ]
 *
 * filter(objects, conforms({ 'b': function(n) { return n > 1 } }))
 * // => [{ 'a': 1, 'b': 2 }]
 */
function conforms(source: Object): Function {
  return baseConforms(baseClone(source, CLONE_DEEP_FLAG))
}

export default conforms
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: conformsTo.ts 1`] = `
"import baseConformsTo from './.internal/baseConformsTo.js'
import keys from './keys.js'

/**
 * Checks if \`object\` conforms to \`source\` by invoking the predicate
 * properties of \`source\` with the corresponding property values of \`object\`.
 *
 * **Note:** This method is equivalent to \`conforms\` when \`source\` is
 * partially applied.
 *
 * @since 4.14.0
 * @category Lang
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property predicates to conform to.
 * @returns {boolean} Returns \`true\` if \`object\` conforms, else \`false\`.
 * @example
 *
 * const object = { 'a': 1, 'b': 2 }
 *
 * conformsTo(object, { 'b': function(n) { return n > 1 } })
 * // => true
 *
 * conformsTo(object, { 'b': function(n) { return n > 2 } })
 * // => false
 */
function conformsTo(object: Object, source: Object): boolean {
  return source == null || baseConformsTo(object, source, keys(source))
}

export default conformsTo
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: countBy.ts 1`] = `
"import baseAssignValue from './.internal/baseAssignValue.js'
import reduce from './reduce.js'

/** Used to check objects for own properties. */
const hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Creates an object composed of keys generated from the results of running
 * each element of \`collection\` thru \`iteratee\`. The corresponding value of
 * each key is the number of times the key was returned by \`iteratee\`. The
 * iteratee is invoked with one argument: (value).
 *
 * @since 0.5.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * const users = [
 *   { 'user': 'barney', 'active': true },
 *   { 'user': 'betty', 'active': true },
 *   { 'user': 'fred', 'active': false }
 * ]
 *
 * countBy(users, 'active');
 * // => { 'true': 2, 'false': 1 }
 */
function countBy(collection: any[] | Object, iteratee: Function): Object {
  return reduce(collection, (result, value, key) => {
    key = iteratee(value)
    if (hasOwnProperty.call(result, key)) {
      ++result[key]
    } else {
      baseAssignValue(result, key, 1)
    }
    return result
  }, {})
}

export default countBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: create.ts 1`] = `
"/**
 * Creates an object that inherits from the \`prototype\` object. If a
 * \`properties\` object is given, its own enumerable string keyed properties
 * are assigned to the created object.
 *
 * @since 2.3.0
 * @category Object
 * @param {Object} prototype The object to inherit from.
 * @param {Object} [properties] The properties to assign to the object.
 * @returns {Object} Returns the new object.
 * @example
 *
 * function Shape() {
 *   this.x = 0
 *   this.y = 0
 * }
 *
 * function Circle() {
 *   Shape.call(this)
 * }
 *
 * Circle.prototype = create(Shape.prototype, {
 *   'constructor': Circle
 * })
 *
 * const circle = new Circle
 * circle instanceof Circle
 * // => true
 *
 * circle instanceof Shape
 * // => true
 */
function create(prototype: Object, properties: Object): Object {
  prototype = prototype === null ? null : Object(prototype)
  const result = Object.create(prototype)
  return properties == null ? result : Object.assign(result, properties)
}

export default create
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: debounce.ts 1`] = `
"import isObject from './isObject.js'
import root from './.internal/root.js'

/**
 * Creates a debounced function that delays invoking \`func\` until after \`wait\`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked, or until the next browser frame is drawn. The debounced function
 * comes with a \`cancel\` method to cancel delayed \`func\` invocations and a
 * \`flush\` method to immediately invoke them. Provide \`options\` to indicate
 * whether \`func\` should be invoked on the leading and/or trailing edge of the
 * \`wait\` timeout. The \`func\` is invoked with the last arguments provided to the
 * debounced function. Subsequent calls to the debounced function return the
 * result of the last \`func\` invocation.
 *
 * **Note:** If \`leading\` and \`trailing\` options are \`true\`, \`func\` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the \`wait\` timeout.
 *
 * If \`wait\` is \`0\` and \`leading\` is \`false\`, \`func\` invocation is deferred
 * until the next tick, similar to \`setTimeout\` with a timeout of \`0\`.
 *
 * If \`wait\` is omitted in an environment with \`requestAnimationFrame\`, \`func\`
 * invocation will be deferred until the next frame is drawn (typically about
 * 16ms).
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between \`debounce\` and \`throttle\`.
 *
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0]
 *  The number of milliseconds to delay; if omitted, \`requestAnimationFrame\` is
 *  used (if available).
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time \`func\` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', debounce(calculateLayout, 150))
 *
 * // Invoke \`sendMail\` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }))
 *
 * // Ensure \`batchLog\` is invoked once after 1 second of debounced calls.
 * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })
 * const source = new EventSource('/stream')
 * jQuery(source).on('message', debounced)
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel)
 *
 * // Check for pending invocations.
 * const status = debounced.pending() ? \\"Pending...\\" : \\"Ready\\"
 */
function debounce(func: Function, wait: number, options: Object): Function {
  let lastArgs,
    lastThis,
    maxWait,
    result,
    timerId,
    lastCallTime

  let lastInvokeTime = 0
  let leading = false
  let maxing = false
  let trailing = true

  // Bypass \`requestAnimationFrame\` by explicitly setting \`wait=0\`.
  const useRAF = (!wait && wait !== 0 && typeof root.requestAnimationFrame === 'function')

  if (typeof func !== 'function') {
    throw new TypeError('Expected a function')
  }
  wait = +wait || 0
  if (isObject(options)) {
    leading = !!options.leading
    maxing = 'maxWait' in options
    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait
    trailing = 'trailing' in options ? !!options.trailing : trailing
  }

  function invokeFunc(time) {
    const args = lastArgs
    const thisArg = lastThis

    lastArgs = lastThis = undefined
    lastInvokeTime = time
    result = func.apply(thisArg, args)
    return result
  }

  function startTimer(pendingFunc, wait) {
    if (useRAF) {
      root.cancelAnimationFrame(timerId);
      return root.requestAnimationFrame(pendingFunc)
    }
    return setTimeout(pendingFunc, wait)
  }

  function cancelTimer(id) {
    if (useRAF) {
      return root.cancelAnimationFrame(id)
    }
    clearTimeout(id)
  }

  function leadingEdge(time) {
    // Reset any \`maxWait\` timer.
    lastInvokeTime = time
    // Start the timer for the trailing edge.
    timerId = startTimer(timerExpired, wait)
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result
  }

  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime
    const timeSinceLastInvoke = time - lastInvokeTime
    const timeWaiting = wait - timeSinceLastCall

    return maxing
      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting
  }

  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime
    const timeSinceLastInvoke = time - lastInvokeTime

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the \`maxWait\` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait))
  }

  function timerExpired() {
    const time = Date.now()
    if (shouldInvoke(time)) {
      return trailingEdge(time)
    }
    // Restart the timer.
    timerId = startTimer(timerExpired, remainingWait(time))
  }

  function trailingEdge(time) {
    timerId = undefined

    // Only invoke if we have \`lastArgs\` which means \`func\` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time)
    }
    lastArgs = lastThis = undefined
    return result
  }

  function cancel() {
    if (timerId !== undefined) {
      cancelTimer(timerId)
    }
    lastInvokeTime = 0
    lastArgs = lastCallTime = lastThis = timerId = undefined
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(Date.now())
  }

  function pending() {
    return timerId !== undefined
  }

  function debounced(...args) {
    const time = Date.now()
    const isInvoking = shouldInvoke(time)

    lastArgs = args
    lastThis = this
    lastCallTime = time

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime)
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = startTimer(timerExpired, wait)
        return invokeFunc(lastCallTime)
      }
    }
    if (timerId === undefined) {
      timerId = startTimer(timerExpired, wait)
    }
    return result
  }
  debounced.cancel = cancel
  debounced.flush = flush
  debounced.pending = pending
  return debounced
}

export default debounce
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: deburr.ts 1`] = `
"import deburrLetter from './.internal/deburrLetter.js'

/** Used to match Latin Unicode letters (excluding mathematical operators). */
const reLatin = /[\\\\xc0-\\\\xd6\\\\xd8-\\\\xf6\\\\xf8-\\\\xff\\\\u0100-\\\\u017f]/g

/** Used to compose unicode character classes. */
const rsComboMarksRange = '\\\\\\\\u0300-\\\\\\\\u036f'
const reComboHalfMarksRange = '\\\\\\\\ufe20-\\\\\\\\ufe2f'
const rsComboSymbolsRange = '\\\\\\\\u20d0-\\\\\\\\u20ff'
const rsComboMarksExtendedRange = '\\\\\\\\u1ab0-\\\\\\\\u1aff'
const rsComboMarksSupplementRange = '\\\\\\\\u1dc0-\\\\\\\\u1dff'
const rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange

/** Used to compose unicode capture groups. */
const rsCombo = \`[\${rsComboRange}]\`

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
const reComboMark = RegExp(rsCombo, 'g')

/**
 * Deburrs \`string\` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * deburr('déjà vu')
 * // => 'deja vu'
 */
function deburr(string: string): string {
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '')
}

export default deburr
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: defaultTo.ts 1`] = `
"/**
 * Checks \`value\` to determine whether a default value should be returned in
 * its place. The \`defaultValue\` is returned if \`value\` is \`NaN\`, \`null\`,
 * or \`undefined\`.
 *
 * @since 4.14.0
 * @category Util
 * @param {*} value The value to check.
 * @param {*} defaultValue The default value.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * defaultTo(1, 10)
 * // => 1
 *
 * defaultTo(undefined, 10)
 * // => 10
 */
function defaultTo(value: any, defaultValue: any): any {
  return (value == null || value !== value) ? defaultValue : value
}

export default defaultTo
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: defaultToAny.ts 1`] = `
"import arrayReduce from './.internal/arrayReduce.js'
import defaultTo from './defaultTo.js'

/**
 * This method is like \`defaultTo\` except that it accepts multiple default values and returns the first one that is not
 * \`NaN\`, \`null\`, or \`undefined\`.
 *
 * @since 5.0.0
 * @category Util
 * @param {*} value The value to check.
 * @param {...*} defaultValues The default values.
 * @returns {*} Returns the resolved value.
 * @see _.defaultTo
 * @example
 *
 * defaultToAny(1, 10, 20)
 * // => 1
 *
 * defaultToAny(undefined, 10, 20)
 * // => 10
 *
 * defaultToAny(undefined, null, 20)
 * // => 20
 *
 * defaultToAny(undefined, null, NaN)
 * // => NaN
 */
function defaultToAny(value: any, ...defaultValues: any[]): any {
  return arrayReduce(defaultValues, defaultTo, value)
}

export default defaultToAny
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: defaults.ts 1`] = `
"import eq from './eq.js'

/** Used for built-in method references. */
const objectProto = Object.prototype

/** Used to check objects for own properties. */
const hasOwnProperty = objectProto.hasOwnProperty

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to \`undefined\`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates \`object\`.
 *
 * @since 0.1.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns \`object\`.
 * @see defaultsDeep
 * @example
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 })
 * // => { 'a': 1, 'b': 2 }
 */
function defaults(object: Object, ...sources: Object[]): Object {
  object = Object(object)
  sources.forEach((source) => {
    if (source != null) {
      source = Object(source)
      for (const key in source) {
        const value = object[key]
        if (value === undefined ||
            (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
          object[key] = source[key]
        }
      }
    }
  })
  return object
}

export default defaults
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: defaultsDeep.ts 1`] = `
"import customDefaultsMerge from './.internal/customDefaultsMerge.js'
import mergeWith from './mergeWith.js'

/**
 * This method is like \`defaults\` except that it recursively assigns
 * default properties.
 *
 * **Note:** This method mutates \`object\`.
 *
 * @since 3.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns \`object\`.
 * @see defaults
 * @example
 *
 * defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } })
 * // => { 'a': { 'b': 2, 'c': 3 } }
 */
function defaultsDeep(...args: Object): Object {
  args.push(undefined, customDefaultsMerge)
  return mergeWith.apply(undefined, args)
}

export default defaultsDeep
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: defer.ts 1`] = `
"/**
 * Defers invoking the \`func\` until the current call stack has cleared. Any
 * additional arguments are provided to \`func\` when it's invoked.
 *
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to defer.
 * @param {...*} [args] The arguments to invoke \`func\` with.
 * @returns {number} Returns the timer id.
 * @example
 *
 * defer(text => console.log(text), 'deferred')
 * // => Logs 'deferred' after one millisecond.
 */
function defer(func: Function, ...args: any[]): number {
  if (typeof func != 'function') {
    throw new TypeError('Expected a function')
  }
  return setTimeout(func, 1, ...args)
}

export default defer
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: delay.ts 1`] = `
"/**
 * Invokes \`func\` after \`wait\` milliseconds. Any additional arguments are
 * provided to \`func\` when it's invoked.
 *
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {...*} [args] The arguments to invoke \`func\` with.
 * @returns {number} Returns the timer id.
 * @example
 *
 * delay(text => console.log(text), 1000, 'later')
 * // => Logs 'later' after one second.
 */
function delay(func: Function, wait: number, ...args: any[]): number {
  if (typeof func != 'function') {
    throw new TypeError('Expected a function')
  }
  return setTimeout(func, +wait || 0, ...args)
}

export default delay
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: difference.ts 1`] = `
"import baseDifference from './.internal/baseDifference.js'
import baseFlatten from './.internal/baseFlatten.js'
import isArrayLikeObject from './isArrayLikeObject.js'

/**
 * Creates an array of \`array\` values not included in the other given arrays
 * using [\`SameValueZero\`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike \`pullAll\`, this method returns a new array.
 *
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see union, unionBy, unionWith, without, xor, xorBy, xorWith,
 * @example
 *
 * difference([2, 1], [2, 3])
 * // => [1]
 */
function difference(array: any[], ...values: any[][]): any[] {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : []
}

export default difference
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: differenceBy.ts 1`] = `
"import baseDifference from './.internal/baseDifference.js'
import baseFlatten from './.internal/baseFlatten.js'
import isArrayLikeObject from './isArrayLikeObject.js'
import last from './last.js'

/**
 * This method is like \`difference\` except that it accepts \`iteratee\` which
 * is invoked for each element of \`array\` and \`values\` to generate the criterion
 * by which they're compared. The order and references of result values are
 * determined by the first array. The iteratee is invoked with one argument:
 * (value).
 *
 * **Note:** Unlike \`pullAllBy\`, this method returns a new array.
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor)
 * // => [1.2]
 */
function differenceBy(array: any[], ...values: any[][]): any[] {
  let iteratee = last(values)
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined
  }
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), iteratee)
    : []
}

export default differenceBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: differenceWith.ts 1`] = `
"import baseDifference from './.internal/baseDifference.js'
import baseFlatten from './.internal/baseFlatten.js'
import isArrayLikeObject from './isArrayLikeObject.js'
import last from './last.js'

/**
 * This method is like \`difference\` except that it accepts \`comparator\`
 * which is invoked to compare elements of \`array\` to \`values\`. The order and
 * references of result values are determined by the first array. The comparator
 * is invoked with two arguments: (arrVal, othVal).
 *
 * **Note:** Unlike \`pullAllWith\`, this method returns a new array.
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * const objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 *
 * differenceWith(objects, [{ 'x': 1, 'y': 2 }], isEqual)
 * // => [{ 'x': 2, 'y': 1 }]
 */
function differenceWith(array: any[], ...values: any[][]): any[] {
  let comparator = last(values)
  if (isArrayLikeObject(comparator)) {
    comparator = undefined
  }
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
    : []
}

export default differenceWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: divide.ts 1`] = `
"import createMathOperation from './.internal/createMathOperation.js'

/**
 * Divide two numbers.
 *
 * @since 4.7.0
 * @category Math
 * @param {number} dividend The first number in a division.
 * @param {number} divisor The second number in a division.
 * @returns {number} Returns the quotient.
 * @example
 *
 * divide(6, 4)
 * // => 1.5
 */
const divide = createMathOperation((dividend: number, divisor: number): number => dividend / divisor, 1)

export default divide
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: drop.ts 1`] = `
"import slice from './slice.js'

/**
 * Creates a slice of \`array\` with \`n\` elements dropped from the beginning.
 *
 * @since 0.5.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @returns {Array} Returns the slice of \`array\`.
 * @example
 *
 * drop([1, 2, 3])
 * // => [2, 3]
 *
 * drop([1, 2, 3], 2)
 * // => [3]
 *
 * drop([1, 2, 3], 5)
 * // => []
 *
 * drop([1, 2, 3], 0)
 * // => [1, 2, 3]
 */
function drop(array: any[], n = 1): any[] {
  const length = array == null ? 0 : array.length
  return length
    ? slice(array, n < 0 ? 0 : n, length)
    : []
}

export default drop
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: dropRight.ts 1`] = `
"import slice from './slice.js'

/**
 * Creates a slice of \`array\` with \`n\` elements dropped from the end.
 *
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @returns {Array} Returns the slice of \`array\`.
 * @example
 *
 * dropRight([1, 2, 3])
 * // => [1, 2]
 *
 * dropRight([1, 2, 3], 2)
 * // => [1]
 *
 * dropRight([1, 2, 3], 5)
 * // => []
 *
 * dropRight([1, 2, 3], 0)
 * // => [1, 2, 3]
 */
function dropRight(array: any[], n = 1): any[] {
  const length = array == null ? 0 : array.length
  return length ? slice(array, 0, n < 0 ? 0 : -n) : []
}

export default dropRight
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: dropRightWhile.ts 1`] = `
"import baseWhile from './.internal/baseWhile.js'

/**
 * Creates a slice of \`array\` excluding elements dropped from the end.
 * Elements are dropped until \`predicate\` returns falsey. The predicate is
 * invoked with three arguments: (value, index, array).
 *
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the slice of \`array\`.
 * @example
 *
 * const users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': true },
 *   { 'user': 'pebbles', 'active': true }
 * ]
 *
 * dropRightWhile(users, ({ active }) => active)
 * // => objects for ['barney']
 */
function dropRightWhile(array: any[], predicate: Function): any[] {
  return (array != null && array.length)
    ? baseWhile(array, predicate, true, true)
    : []
}

export default dropRightWhile
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: dropWhile.ts 1`] = `
"import baseWhile from './.internal/baseWhile.js'

/**
 * Creates a slice of \`array\` excluding elements dropped from the beginning.
 * Elements are dropped until \`predicate\` returns falsey. The predicate is
 * invoked with three arguments: (value, index, array).
 *
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the slice of \`array\`.
 * @example
 *
 * const users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': true },
 *   { 'user': 'pebbles', 'active': false }
 * ]
 *
 * dropWhile(users, ({ active }) => active)
 * // => objects for ['pebbles']
 */
function dropWhile(array: any[], predicate: Function): any[] {
  return (array != null && array.length)
    ? baseWhile(array, predicate, true)
    : []
}

export default dropWhile
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: each.ts 1`] = `
"export { default } from './forEach.js'
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: eachRight.ts 1`] = `
"export { default } from './forEachRight.js'
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: endsWith.ts 1`] = `
"/**
 * Checks if \`string\` ends with the given target string.
 *
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=string.length] The position to search up to.
 * @returns {boolean} Returns \`true\` if \`string\` ends with \`target\`,
 *  else \`false\`.
 * @see includes, startsWith
 * @example
 *
 * endsWith('abc', 'c')
 * // => true
 *
 * endsWith('abc', 'b')
 * // => false
 *
 * endsWith('abc', 'b', 2)
 * // => true
 */
function endsWith(string: string, target: string, position: number): boolean {
  const { length } = string
  position = position === undefined ? length : +position
  if (position < 0 || position != position) {
    position = 0
  }
  else if (position > length) {
    position = length
  }
  const end = position
  position -= target.length
  return position >= 0 && string.slice(position, end) == target
}

export default endsWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: eq.ts 1`] = `
"/**
 * Performs a
 * [\`SameValueZero\`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns \`true\` if the values are equivalent, else \`false\`.
 * @example
 *
 * const object = { 'a': 1 }
 * const other = { 'a': 1 }
 *
 * eq(object, object)
 * // => true
 *
 * eq(object, other)
 * // => false
 *
 * eq('a', 'a')
 * // => true
 *
 * eq('a', Object('a'))
 * // => false
 *
 * eq(NaN, NaN)
 * // => true
 */
function eq(value: any, other: any): boolean {
  return value === other || (value !== value && other !== other)
}

export default eq
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: eqDeep.ts 1`] = `
"import baseIsEqual from './.internal/baseIsEqual.js'

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, \`Object\` objects, regexes,
 * sets, strings, symbols, and typed arrays. \`Object\` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. \`===\`.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns \`true\` if the values are equivalent, else \`false\`.
 * @example
 *
 * const object = { 'a': 1 }
 * const other = { 'a': 1 }
 *
 * isEqual(object, other)
 * // => true
 *
 * object === other
 * // => false
 */
function isEqual(value: any, other: any): boolean {
  return baseIsEqual(value, other)
}

export default isEqual
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: escape.ts 1`] = `
"/** Used to map characters to HTML entities. */
const htmlEscapes = {
  '&': '&amp',
  '<': '&lt',
  '>': '&gt',
  '\\"': '&quot',
  \\"'\\": '&#39'
}

/** Used to match HTML entities and HTML characters. */
const reUnescapedHtml = /[&<>\\"']/g
const reHasUnescapedHtml = RegExp(reUnescapedHtml.source)

/**
 * Converts the characters \\"&\\", \\"<\\", \\">\\", '\\"', and \\"'\\" in \`string\` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the \\">\\" character is escaped for symmetry, characters like
 * \\">\\" and \\"/\\" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under \\"semi-related fun fact\\") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @since 0.1.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @see escapeRegExp, unescape
 * @example
 *
 * escape('fred, barney, & pebbles')
 * // => 'fred, barney, &amp pebbles'
 */
function escape(string: string): string {
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, (chr) => htmlEscapes[chr])
    : string
}

export default escape
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: escapeRegExp.ts 1`] = `
"/**
 * Used to match \`RegExp\`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
const reRegExpChar = /[\\\\\\\\^$.*+?()[\\\\]{}|]/g
const reHasRegExpChar = RegExp(reRegExpChar.source)

/**
 * Escapes the \`RegExp\` special characters \\"^\\", \\"$\\", \\"\\\\\\", \\".\\", \\"*\\", \\"+\\",
 * \\"?\\", \\"(\\", \\")\\", \\"[\\", \\"]\\", \\"{\\", \\"}\\", and \\"|\\" in \`string\`.
 *
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @see escape, escapeRegExp, unescape
 * @example
 *
 * escapeRegExp('[lodash](https://lodash.com/)')
 * // => '\\\\[lodash\\\\]\\\\(https://lodash\\\\.com/\\\\)'
 */
function escapeRegExp(string: string): string {
  return (string && reHasRegExpChar.test(string))
    ? string.replace(reRegExpChar, '\\\\\\\\$&')
    : string
}

export default escapeRegExp
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: every.ts 1`] = `
"/**
 * Checks if \`predicate\` returns truthy for **all** elements of \`array\`.
 * Iteration is stopped once \`predicate\` returns falsey. The predicate is
 * invoked with three arguments: (value, index, array).
 *
 * **Note:** This method returns \`true\` for
 * [empty arrays](https://en.wikipedia.org/wiki/Empty_set) because
 * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
 * elements of empty arrays.
 *
 * @since 5.0.0
 * @category Array
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns \`true\` if all elements pass the predicate check,
 *  else \`false\`.
 * @example
 *
 * every([true, 1, null, 'yes'], Boolean)
 * // => false
 */
function every(array: any[], predicate: Function): boolean {
  let index = -1
  const length = array == null ? 0 : array.length

  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false
    }
  }
  return true
}

export default every
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: everyValue.ts 1`] = `
"/**
 * Checks if \`predicate\` returns truthy for **all** properties of \`object\`.
 * Iteration is stopped once \`predicate\` returns falsey. The predicate is
 * invoked with three arguments: (value, key, object).
 *
 * **Note:** This method returns \`true\` for
 * [empty objects](https://en.wikipedia.org/wiki/Empty_set) because
 * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
 * elements of empty objects.
 *
 * @since 5.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns \`true\` if all properties pass the predicate check,
 *  else \`false\`.
 * @example
 *
 * everyValue({ 'a': 0, 'b': 'yes', 'c': false }, Boolean)
 * // => false
 */
function everyValue(object: Object, predicate: Function): boolean {
  object = Object(object)
  const props = Object.keys(object)

  for (const key of props) {
    if (!predicate(object[key], key, object)) {
      return false
    }
  }
  return true
}

export default everyValue
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: filter.ts 1`] = `
"/**
 * Iterates over elements of \`array\`, returning an array of all elements
 * \`predicate\` returns truthy for. The predicate is invoked with three
 * arguments: (value, index, array).
 *
 * **Note:** Unlike \`remove\`, this method returns a new array.
 *
 * @since 5.0.0
 * @category Array
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see pull, pullAll, pullAllBy, pullAllWith, pullAt, remove, reject
 * @example
 *
 * const users = [
 *   { 'user': 'barney', 'active': true },
 *   { 'user': 'fred',   'active': false }
 * ]
 *
 * filter(users, ({ active }) => active)
 * // => objects for ['barney']
 */
function filter(array: any[], predicate: Function): any[] {
  let index = -1
  let resIndex = 0
  const length = array == null ? 0 : array.length
  const result = []

  while (++index < length) {
    const value = array[index]
    if (predicate(value, index, array)) {
      result[resIndex++] = value
    }
  }
  return result
}

export default filter
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: filterObject.ts 1`] = `
"/**
 * Iterates over properties of \`object\`, returning an array of all elements
 * \`predicate\` returns truthy for. The predicate is invoked with three
 * arguments: (value, key, object).
 *
 * If you want an object in return, consider \`pickBy\`.
 *
 * @since 5.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see pickBy, pull, pullAll, pullAllBy, pullAllWith, pullAt, remove, reject
 * @example
 *
 * const object = { 'a': 5, 'b': 8, 'c': 10 }
 *
 * filterObject(object, (n) => !(n % 5))
 * // => [5, 10]
 */
function filterObject(object: Object, predicate: Function): any[] {
  object = Object(object)
  const result = []

  Object.keys(object).forEach((key) => {
    const value = object[key]
    if (predicate(value, key, object)) {
      result.push(value)
    }
  })
  return result
}

export default filterObject
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: findKey.ts 1`] = `
"/**
 * This method is like \`find\` except that it returns the key of the first
 * element \`predicate\` returns truthy for instead of the element itself.
 *
 * @since 1.1.0
 * @category Object
 * @param {Object} object The object to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {string|undefined} Returns the key of the matched element,
 *  else \`undefined\`.
 * @see find, findIndex, findLast, findLastIndex, findLastKey
 * @example
 *
 * const users = {
 *   'barney':  { 'age': 36, 'active': true },
 *   'fred':    { 'age': 40, 'active': false },
 *   'pebbles': { 'age': 1,  'active': true }
 * }
 *
 * findKey(users, ({ age }) => age < 40)
 * // => 'barney' (iteration order is not guaranteed)
 */
function findKey(object: Object, predicate: Function): string | undefined {
  let result
  if (object == null) {
    return result
  }
  Object.keys(object).some((key) => {
    const value = object[key]
    if (predicate(value, key, object)) {
      result = key
      return true
    }
  })
  return result
}

export default findKey
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: findLast.ts 1`] = `
"import findLastIndex from './findLastIndex.js'
import isArrayLike from './isArrayLike.js'

/**
 * This method is like \`find\` except that it iterates over elements of
 * \`collection\` from right to left.
 *
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} [fromIndex=collection.length-1] The index to search from.
 * @returns {*} Returns the matched element, else \`undefined\`.
 * @see find, findIndex, findKey, findLastIndex, findLastKey
 * @example
 *
 * findLast([1, 2, 3, 4], n => n % 2 == 1)
 * // => 3
 */
function findLast(collection: any[] | Object, predicate: Function, fromIndex: number): any {
  let iteratee
  const iterable = Object(collection)
  if (!isArrayLike(collection)) {
    collection = Object.keys(collection)
    iteratee = predicate
    predicate = key => iteratee(iterable[key], key, iterable)
  }
  const index = findLastIndex(collection, predicate, fromIndex)
  return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
}

export default findLast
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: findLastIndex.ts 1`] = `
"import baseFindIndex from './.internal/baseFindIndex.js'

/**
 * This method is like \`findIndex\` except that it iterates over elements
 * of \`collection\` from right to left.
 *
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the found element, else \`-1\`.
 * @see find, findIndex, findKey, findLast, findLastKey
 * @example
 *
 * const users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ]
 *
 * findLastIndex(users, ({ user }) => user == 'pebbles')
 * // => 2
 */
function findLastIndex(array: any[], predicate: Function, fromIndex: number): number {
  const length = array == null ? 0 : array.length
  if (!length) {
    return -1
  }
  let index = length - 1
  if (fromIndex !== undefined) {
    index = fromIndex < 0
      ? Math.max(length + fromIndex, 0)
      : Math.min(fromIndex, length - 1)
  }
  return baseFindIndex(array, predicate, index, true)
}

export default findLastIndex
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: findLastKey.ts 1`] = `
"import baseFindKey from './.internal/baseFindKey.js'
import baseForOwnRight from './.internal/baseForOwnRight.js'

/**
 * This method is like \`findKey\` except that it iterates over elements of
 * a collection in the opposite order.
 *
 * @since 2.0.0
 * @category Object
 * @param {Object} object The object to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {string|undefined} Returns the key of the matched element,
 *  else \`undefined\`.
 * @see find, findIndex, findKey, findLast, findLastIndex
 * @example
 *
 * const users = {
 *   'barney':  { 'age': 36, 'active': true },
 *   'fred':    { 'age': 40, 'active': false },
 *   'pebbles': { 'age': 1,  'active': true }
 * }
 *
 * findLastKey(users, ({ age }) => age < 40)
 * // => returns 'pebbles' assuming \`findKey\` returns 'barney'
 */
function findLastKey(object: Object, predicate: Function): string | undefined {
  return baseFindKey(object, predicate, baseForOwnRight)
}

export default findLastKey
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: first.ts 1`] = `
"export { default } from './head.js'
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: flatMap.ts 1`] = `
"import baseFlatten from './.internal/baseFlatten.js'
import map from './map.js'

/**
 * Creates a flattened array of values by running each element in \`collection\`
 * thru \`iteratee\` and flattening the mapped results. The iteratee is invoked
 * with three arguments: (value, index|key, collection).
 *
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new flattened array.
 * @see flatMapDeep, flatMapDepth, flatten, flattenDeep, flattenDepth, map, mapKeys, mapValues
 * @example
 *
 * function duplicate(n) {
 *   return [n, n]
 * }
 *
 * flatMap([1, 2], duplicate)
 * // => [1, 1, 2, 2]
 */
function flatMap(collection: any[] | Object, iteratee: Function): any[] {
  return baseFlatten(map(collection, iteratee), 1)
}

export default flatMap
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: flatMapDeep.ts 1`] = `
"import baseFlatten from './.internal/baseFlatten.js'
import map from './map.js'

/** Used as references for various \`Number\` constants. */
const INFINITY = 1 / 0

/**
 * This method is like \`flatMap\` except that it recursively flattens the
 * mapped results.
 *
 * @since 4.7.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new flattened array.
 * @see flatMap, flatMapDepth, flatten, flattenDeep, flattenDepth, map, mapKeys, mapValues
 * @example
 *
 * function duplicate(n) {
 *   return [[[n, n]]]
 * }
 *
 * flatMapDeep([1, 2], duplicate)
 * // => [1, 1, 2, 2]
 */
function flatMapDeep(collection: any[] | Object, iteratee: Function): any[] {
  return baseFlatten(map(collection, iteratee), INFINITY)
}

export default flatMapDeep
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: flatMapDepth.ts 1`] = `
"import baseFlatten from './.internal/baseFlatten.js'
import map from './map.js'

/**
 * This method is like \`flatMap\` except that it recursively flattens the
 * mapped results up to \`depth\` times.
 *
 * @since 4.7.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {number} [depth=1] The maximum recursion depth.
 * @returns {Array} Returns the new flattened array.
 * @see flatMap, flatMapDeep, flatten, flattenDeep, flattenDepth, map, mapKeys, mapValues
 * @example
 *
 * function duplicate(n) {
 *   return [[[n, n]]]
 * }
 *
 * flatMapDepth([1, 2], duplicate, 2)
 * // => [[1, 1], [2, 2]]
 */
function flatMapDepth(collection: any[] | Object, iteratee: Function, depth: number): any[] {
  depth = depth === undefined ? 1 : +depth
  return baseFlatten(map(collection, iteratee), depth)
}

export default flatMapDepth
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: flatten.ts 1`] = `
"import baseFlatten from './.internal/baseFlatten.js'

/**
 * Flattens \`array\` a single level deep.
 *
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @see flatMap, flatMapDeep, flatMapDepth, flattenDeep, flattenDepth
 * @example
 *
 * flatten([1, [2, [3, [4]], 5]])
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array: any[]): any[] {
  const length = array == null ? 0 : array.length
  return length ? baseFlatten(array, 1) : []
}

export default flatten
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: flattenDeep.ts 1`] = `
"import baseFlatten from './.internal/baseFlatten.js'

/** Used as references for various \`Number\` constants. */
const INFINITY = 1 / 0

/**
 * Recursively flattens \`array\`.
 *
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @see flatMap, flatMapDeep, flatMapDepth, flatten, flattenDepth
 * @example
 *
 * flattenDeep([1, [2, [3, [4]], 5]])
 * // => [1, 2, 3, 4, 5]
 */
function flattenDeep(array: any[]): any[] {
  const length = array == null ? 0 : array.length
  return length ? baseFlatten(array, INFINITY) : []
}

export default flattenDeep
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: flattenDepth.ts 1`] = `
"import baseFlatten from './.internal/baseFlatten.js'

/**
 * Recursively flatten \`array\` up to \`depth\` times.
 *
 * @since 4.4.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @param {number} [depth=1] The maximum recursion depth.
 * @returns {Array} Returns the new flattened array.
 * @see flatMap, flatMapDeep, flatMapDepth, flattenDeep
 * @example
 *
 * const array = [1, [2, [3, [4]], 5]]
 *
 * flattenDepth(array, 1)
 * // => [1, 2, [3, [4]], 5]
 *
 * flattenDepth(array, 2)
 * // => [1, 2, 3, [4], 5]
 */
function flattenDepth(array: any[], depth: number): any[] {
  const length = array == null ? 0 : array.length
  if (!length) {
    return []
  }
  depth = depth === undefined ? 1 : +depth
  return baseFlatten(array, depth)
}

export default flattenDepth
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: flip.ts 1`] = `
"/**
 * Creates a function that invokes \`func\` with arguments reversed.
 *
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to flip arguments for.
 * @returns {Function} Returns the new flipped function.
 * @see reverse
 * @example
 *
 * const flipped = flip((...args) => args)
 *
 * flipped('a', 'b', 'c', 'd')
 * // => ['d', 'c', 'b', 'a']
 */
function flip(func: Function): Function {
  if (typeof func != 'function') {
    throw new TypeError('Expected a function')
  }
  return function(...args) {
    return func.apply(this, args.reverse())
  }
}

export default flip
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: floor.ts 1`] = `
"import createRound from './.internal/createRound.js'

/**
 * Computes \`number\` rounded down to \`precision\`.
 *
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round down.
 * @param {number} [precision=0] The precision to round down to.
 * @returns {number} Returns the rounded down number.
 * @example
 *
 * floor(4.006)
 * // => 4
 *
 * floor(0.046, 2)
 * // => 0.04
 *
 * floor(4060, -2)
 * // => 4000
 */
const floor = createRound('floor')

export default floor
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: flow.ts 1`] = `
"/**
 * Composes a function that returns the result of invoking the given functions
 * with the \`this\` binding of the created function, where each successive
 * invocation is supplied the return value of the previous.
 *
 * @since 3.0.0
 * @category Util
 * @param {Function[]} [funcs] The functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see flowRight
 * @example
 *
 * function square(n) {
 *   return n * n
 * }
 *
 * const addSquare = flow([add, square])
 * addSquare(1, 2)
 * // => 9
 */
function flow(funcs: Function[]): Function {
  const length = funcs ? funcs.length : 0
  let index = length
  while (index--) {
    if (typeof funcs[index] != 'function') {
      throw new TypeError('Expected a function')
    }
  }
  return function(...args) {
    let index = 0
    let result = length ? funcs[index].apply(this, args) : args[0]
    while (++index < length) {
      result = funcs[index].call(this, result)
    }
    return result
  }
}

export default flow
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: flowRight.ts 1`] = `
"import flow from './flow.js'

/**
 * This method is like \`flow\` except that it composes a function that
 * invokes the given functions from right to left.
 *
 * @since 3.0.0
 * @category Util
 * @param {Function[]} [funcs] The functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see flow
 * @example
 *
 * function square(n) {
 *   return n * n
 * }
 *
 * const addSquare = flowRight([square, add])
 * addSquare(1, 2)
 * // => 9
 */
function flowRight(funcs: Function[]): Function {
  return flow(funcs.reverse())
}

export default flowRight
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: forEach.ts 1`] = `
"import arrayEach from './.internal/arrayEach.js'
import baseEach from './.internal/baseEach.js'

/**
 * Iterates over elements of \`collection\` and invokes \`iteratee\` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning \`false\`.
 *
 * **Note:** As with other \\"Collections\\" methods, objects with a \\"length\\"
 * property are iterated like arrays. To avoid this behavior use \`forIn\`
 * or \`forOwn\` for object iteration.
 *
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns \`collection\`.
 * @see forEachRight, forIn, forInRight, forOwn, forOwnRight
 * @example
 *
 * forEach([1, 2], value => console.log(value))
 * // => Logs \`1\` then \`2\`.
 *
 * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection: any[] | Object, iteratee: Function): any[] | Object {
  const func = Array.isArray(collection) ? arrayEach : baseEach
  return func(collection, iteratee)
}

export default forEach
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: forEachRight.ts 1`] = `
"import arrayEachRight from './.internal/arrayEachRight.js'
import baseEachRight from './.internal/baseEachRight.js'

/**
 * This method is like \`forEach\` except that it iterates over elements of
 * \`collection\` from right to left.
 *
 * @since 2.0.0
 * @alias eachRight
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns \`collection\`.
 * @see forEach, forIn, forInRight, forOwn, forOwnRight
 * @example
 *
 * forEachRight([1, 2], value => console.log(value))
 * // => Logs \`2\` then \`1\`.
 */
function forEachRight(collection: any[] | Object, iteratee: Function): any[] | Object {
  const func = Array.isArray(collection) ? arrayEachRight : baseEachRight
  return func(collection, iteratee)
}

export default forEachRight
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: forOwn.ts 1`] = `
"/**
 * Iterates over own enumerable string keyed properties of an object and
 * invokes \`iteratee\` for each property. The iteratee is invoked with three
 * arguments: (value, key, object). Iteratee functions may exit iteration
 * early by explicitly returning \`false\`.
 *
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @see forEach, forEachRight, forIn, forInRight, forOwnRight
 * @example
 *
 * function Foo() {
 *   this.a = 1
 *   this.b = 2
 * }
 *
 * Foo.prototype.c = 3
 *
 * forOwn(new Foo, function(value, key) {
 *   console.log(key)
 * })
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forOwn(object: Object, iteratee: Function) {
  object = Object(object)
  Object.keys(object).forEach((key) => iteratee(object[key], key, object))
}

export default forOwn
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: forOwnRight.ts 1`] = `
"/**
 * This method is like \`forOwn\` except that it iterates over properties of
 * \`object\` in the opposite order.
 *
 * @since 2.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns \`object\`.
 * @see forEach, forEachRight, forIn, forInRight, forOwn
 * @example
 *
 * function Foo() {
 *   this.a = 1
 *   this.b = 2
 * }
 *
 * Foo.prototype.c = 3
 *
 * forOwnRight(new Foo, function(value, key) {
 *   console.log(key)
 * })
 * // => Logs 'b' then 'a' assuming \`forOwn\` logs 'a' then 'b'.
 */
function forOwnRight(object: Object, iteratee: Function): Object {
  if (object == null) {
    return
  }
  const props = Object.keys(object)
  let length = props.length
  while (length--) {
    iteratee(object[props[length]], iteratee, object)
  }
}

export default forOwnRight
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: fromEntries.ts 1`] = `
"/**
 * The inverse of \`entries\`is method returns an object composed
 * from key-value \`pairs\`.
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} pairs The key-value pairs.
 * @returns {Object} Returns the new object.
 * @example
 *
 * fromEntries([['a', 1], ['b', 2]])
 * // => { 'a': 1, 'b': 2 }
 */
function fromEntries(pairs: any[]): Object {
  const result = {}
  if (pairs == null) {
    return result
  }
  for (const pair of pairs) {
    result[pair[0]] = pair[1]
  }
  return result
}

export default fromEntries
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: functions.ts 1`] = `
"/**
 * Creates an array of function property names from own enumerable properties
 * of \`object\`.
 *
 * @since 0.1.0
 * @category Object
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the function names.
 * @see functionsIn
 * @example
 *
 * function Foo() {
 *   this.a = () => 'a'
 *   this.b = () => 'b'
 * }
 *
 * Foo.prototype.c = () => 'c'
 *
 * functions(new Foo)
 * // => ['a', 'b']
 */
function functions(object: Object): any[] {
  if (object == null) {
    return []
  }
  return Object.keys(object).filter((key) => typeof object[key] == 'function')
}

export default functions
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: get.ts 1`] = `
"import baseGet from './.internal/baseGet.js'

/**
 * Gets the value at \`path\` of \`object\`. If the resolved value is
 * \`undefined\`, the \`defaultValue\` is returned in its place.
 *
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for \`undefined\` resolved values.
 * @returns {*} Returns the resolved value.
 * @see has, hasIn, set, unset
 * @example
 *
 * const object = { 'a': [{ 'b': { 'c': 3 } }] }
 *
 * get(object, 'a[0].b.c')
 * // => 3
 *
 * get(object, ['a', '0', 'b', 'c'])
 * // => 3
 *
 * get(object, 'a.b.c', 'default')
 * // => 'default'
 */
function get(object: Object, path: any[] | string, defaultValue: any): any {
  const result = object == null ? undefined : baseGet(object, path)
  return result === undefined ? defaultValue : result
}

export default get
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: groupBy.ts 1`] = `
"import baseAssignValue from './.internal/baseAssignValue.js'
import reduce from './reduce.js'

/** Used to check objects for own properties. */
const hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Creates an object composed of keys generated from the results of running
 * each element of \`collection\` thru \`iteratee\`. The order of grouped values
 * is determined by the order they occur in \`collection\`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * groupBy([6.1, 4.2, 6.3], Math.floor)
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 */
function groupBy(collection: any[] | Object, iteratee: Function): Object {
  return reduce(collection, (result, value, key) => {
    key = iteratee(value)
    if (hasOwnProperty.call(result, key)) {
      result[key].push(value)
    } else {
      baseAssignValue(result, key, [value])
    }
    return result
  }, {})
}

export default groupBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: gt.ts 1`] = `
"/**
 * Checks if \`value\` is greater than \`other\`.
 *
 * @since 3.9.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns \`true\` if \`value\` is greater than \`other\`,
 *  else \`false\`.
 * @see gte, lt, lte
 * @example
 *
 * gt(3, 1)
 * // => true
 *
 * gt(3, 3)
 * // => false
 *
 * gt(1, 3)
 * // => false
 */
function gt(value: any, other: any): boolean {
  if (!(typeof value == 'string' && typeof other == 'string')) {
    value = +value
    other = +other
  }
  return value > other
}

export default gt
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: gte.ts 1`] = `
"/**
 * Checks if \`value\` is greater than or equal to \`other\`.
 *
 * @since 3.9.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns \`true\` if \`value\` is greater than or equal to
 *  \`other\`, else \`false\`.
 * @see gt, lt, lte
 * @example
 *
 * gte(3, 1)
 * // => true
 *
 * gte(3, 3)
 * // => true
 *
 * gte(1, 3)
 * // => false
 */
function gte(value: any, other: any): boolean {
  if (!(typeof value == 'string' && typeof other == 'string')) {
    value = +value
    other = +other
  }
  return value >= other
}

export default gte
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: has.ts 1`] = `
"/** Used to check objects for own properties. */
const hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Checks if \`key\` is a direct property of \`object\`.
 *
 * @since 0.1.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {string} key The key to check.
 * @returns {boolean} Returns \`true\` if \`key\` exists, else \`false\`.
 * @see hasIn, hasPath, hasPathIn
 * @example
 *
 * const object = { 'a': { 'b': 2 } }
 * const other = create({ 'a': create({ 'b': 2 }) })
 *
 * has(object, 'a')
 * // => true
 *
 * has(other, 'a')
 * // => false
 */
function has(object: Object, key: string): boolean {
  return object != null && hasOwnProperty.call(object, key)
}

export default has
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: hasIn.ts 1`] = `
"/**
 * Checks if \`path\` is a direct or inherited property of \`object\`.
 *
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {string} key The key to check.
 * @returns {boolean} Returns \`true\` if \`key\` exists, else \`false\`.
 * @see has, hasPath, hasPathIn
 * @example
 *
 * const object = create({ 'a': create({ 'b': 2 }) })
 *
 * hasIn(object, 'a')
 * // => true
 *
 * hasIn(object, 'b')
 * // => false
 */
function hasIn(object: Object, key: string): boolean {
  return object != null && key in Object(object)
}

export default hasIn
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: hasPath.ts 1`] = `
"import castPath from './.internal/castPath.js'
import isArguments from './isArguments.js'
import isIndex from './.internal/isIndex.js'
import isLength from './isLength.js'
import toKey from './.internal/toKey.js'

/** Used to check objects for own properties. */
const hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Checks if \`path\` is a direct property of \`object\`.
 *
 * @since 5.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns \`true\` if \`path\` exists, else \`false\`.
 * @see has, hasIn, hasPathIn
 * @example
 *
 * const object = { 'a': { 'b': 2 } }
 * const other = create({ 'a': create({ 'b': 2 }) })
 *
 * hasPath(object, 'a.b')
 * // => true
 *
 * hasPath(object, ['a', 'b'])
 * // => true
 */
function hasPath(object: Object, path: any[] | string): boolean {
  path = castPath(path, object)

  let index = -1
  let { length } = path
  let result = false
  let key

  while (++index < length) {
    key = toKey(path[index])
    if (!(result = object != null && hasOwnProperty.call(object, key))) {
      break
    }
    object = object[key]
  }
  if (result || ++index != length) {
    return result
  }
  length = object == null ? 0 : object.length
  return !!length && isLength(length) && isIndex(key, length) &&
    (Array.isArray(object) || isArguments(object))
}

export default hasPath
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: hasPathIn.ts 1`] = `
"import castPath from './.internal/castPath.js'
import isArguments from './isArguments.js'
import isIndex from './.internal/isIndex.js'
import isLength from './isLength.js'
import toKey from './.internal/toKey.js'

/**
 * Checks if \`path\` is a direct property of \`object\`.
 *
 * @since 5.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns \`true\` if \`path\` exists, else \`false\`.
 * @see has, hasIn hasPath
 * @example
 *
 * const object = { 'a': { 'b': 2 } }
 * const other = create({ 'a': create({ 'b': 2 }) })
 *
 * hasPathIn(object, 'a.b')
 * // => true
 *
 * hasPathIn(object, ['a', 'b'])
 * // => true
 */
function hasPathIn(object: Object, path: any[] | string): boolean {
  path = castPath(path, object)

  let index = -1
  let { length } = path
  let result = false
  let key

  while (++index < length) {
    key = toKey(path[index])
    if (!(result = object != null && key in Object(object))) {
      break
    }
    object = object[key]
  }
  if (result || ++index != length) {
    return result
  }
  length = object == null ? 0 : object.length
  return !!length && isLength(length) && isIndex(key, length) &&
    (Array.isArray(object) || isArguments(object))
}

export default hasPathIn
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: head.ts 1`] = `
"/**
 * Gets the first element of \`array\`.
 *
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of \`array\`.
 * @see last
 * @example
 *
 * head([1, 2, 3])
 * // => 1
 *
 * head([])
 * // => undefined
 */
function head(array: any[]): any {
  return (array != null && array.length)
    ? array[0]
    : undefined
}

export default head
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: inRange.ts 1`] = `
"import baseInRange from './.internal/baseInRange.js'

/**
 * Checks if \`number\` is between \`start\` and up to, but not including, \`end\`. If
 * \`end\` is not specified, it's set to \`start\` with \`start\` then set to \`0\`.
 * If \`start\` is greater than \`end\` the params are swapped to support
 * negative ranges.
 *
 * @since 3.3.0
 * @category Number
 * @param {number} number The number to check.
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns \`true\` if \`number\` is in the range, else \`false\`.
 * @see range, rangeRight
 * @example
 *
 * inRange(3, 2, 4)
 * // => true
 *
 * inRange(4, 8)
 * // => true
 *
 * inRange(4, 2)
 * // => false
 *
 * inRange(2, 2)
 * // => false
 *
 * inRange(1.2, 2)
 * // => true
 *
 * inRange(5.2, 4)
 * // => false
 *
 * inRange(-3, -2, -6)
 * // => true
 */
function inRange(number: number, start: number, end: number): boolean {
  if (end === undefined) {
    end = start
    start = 0
  }
  return baseInRange(+number, +start, +end)
}

export default inRange
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: indexOf.ts 1`] = `
"import baseIndexOf from './.internal/baseIndexOf.js'

/**
 * Gets the index at which the first occurrence of \`value\` is found in \`array\`
 * using [\`SameValueZero\`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. If \`fromIndex\` is negative, it's used as the
 * offset from the end of \`array\`.
 *
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 * @example
 *
 * indexOf([1, 2, 1, 2], 2)
 * // => 1
 *
 * // Search from the \`fromIndex\`.
 * indexOf([1, 2, 1, 2], 2, 2)
 * // => 3
 */
function indexOf(array: any[], value: any, fromIndex: number): number {
  const length = array == null ? 0 : array.length
  if (!length) {
    return -1
  }
  let index = fromIndex == null ? 0 : +fromIndex
  if (index < 0) {
    index = Math.max(length + index, 0)
  }
  return baseIndexOf(array, value, index)
}

export default indexOf
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: initial.ts 1`] = `
"import slice from './slice.js'

/**
 * Gets all but the last element of \`array\`.
 *
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of \`array\`.
 * @example
 *
 * initial([1, 2, 3])
 * // => [1, 2]
 */
function initial(array: any[]): any[] {
  const length = array == null ? 0 : array.length
  return length ? slice(array, 0, -1) : []
}

export default initial
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: intersection.ts 1`] = `
"import map from './map.js'
import baseIntersection from './.internal/baseIntersection.js'
import castArrayLikeObject from './.internal/castArrayLikeObject.js'

/**
 * Creates an array of unique values that are included in all given arrays
 * using [\`SameValueZero\`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * intersection([2, 1], [2, 3])
 * // => [2]
 */
function intersection(...arrays: any[][]): any[] {
  const mapped = map(arrays, castArrayLikeObject)
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped)
    : []
}

export default intersection
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: intersectionBy.ts 1`] = `
"import map from './map.js'
import baseIntersection from './.internal/baseIntersection.js'
import castArrayLikeObject from './.internal/castArrayLikeObject.js'
import last from './last.js'

/**
 * This method is like \`intersection\` except that it accepts \`iteratee\`
 * which is invoked for each element of each \`arrays\` to generate the criterion
 * by which they're compared. The order and references of result values are
 * determined by the first array. The iteratee is invoked with one argument:
 * (value).
 *
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor)
 * // => [2.1]
 */
function intersectionBy(...arrays: any[][]): any[] {
  let iteratee = last(arrays)
  const mapped = map(arrays, castArrayLikeObject)

  if (iteratee === last(mapped)) {
    iteratee = undefined
  } else {
    mapped.pop()
  }
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped, iteratee)
    : []
}

export default intersectionBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: intersectionWith.ts 1`] = `
"import map from './map.js'
import baseIntersection from './.internal/baseIntersection.js'
import castArrayLikeObject from './.internal/castArrayLikeObject.js'
import last from './last.js'

/**
 * This method is like \`intersection\` except that it accepts \`comparator\`
 * which is invoked to compare elements of \`arrays\`. The order and references
 * of result values are determined by the first array. The comparator is
 * invoked with two arguments: (arrVal, othVal).
 *
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * const objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 * const others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }]
 *
 * intersectionWith(objects, others, isEqual)
 * // => [{ 'x': 1, 'y': 2 }]
 */
function intersectionWith(...arrays: any[][]): any[] {
  let comparator = last(arrays)
  const mapped = map(arrays, castArrayLikeObject)

  comparator = typeof comparator == 'function' ? comparator : undefined
  if (comparator) {
    mapped.pop()
  }
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped, undefined, comparator)
    : []
}

export default intersectionWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: invert.ts 1`] = `
"const toString = Object.prototype.toString

/**
 * Creates an object composed of the inverted keys and values of \`object\`.
 * If \`object\` contains duplicate values, subsequent values overwrite
 * property assignments of previous values.
 *
 * @since 0.7.0
 * @category Object
 * @param {Object} object The object to invert.
 * @returns {Object} Returns the new inverted object.
 * @example
 *
 * const object = { 'a': 1, 'b': 2, 'c': 1 }
 *
 * invert(object)
 * // => { '1': 'c', '2': 'b' }
 */
function invert(object: Object): Object {
  const result = {}
  Object.keys(object).forEach((key) => {
    let value = object[key]
    if (value != null && typeof value.toString != 'function') {
      value = toString.call(value)
    }
    result[value] = key
  })
  return result
}

export default invert
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: invertBy.ts 1`] = `
"/** Used to check objects for own properties. */
const hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * This method is like \`invert\` except that the inverted object is generated
 * from the results of running each element of \`object\` thru \`iteratee\`. The
 * corresponding inverted value of each inverted key is an array of keys
 * responsible for generating the inverted value. The iteratee is invoked
 * with one argument: (value).
 *
 * @since 4.1.0
 * @category Object
 * @param {Object} object The object to invert.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {Object} Returns the new inverted object.
 * @example
 *
 * const object = { 'a': 1, 'b': 2, 'c': 1 }
 *
 * invertBy(object, value => \`group\${value}\`)
 * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
 */
function invertBy(object: Object, iteratee: Function): Object {
  const result = {}
  Object.keys(object).forEach((key) => {
    const value = iteratee(object[key])
    if (hasOwnProperty.call(result, value)) {
      result[value].push(key)
    } else {
      result[value] = [key]
    }
  })
  return result
}

export default invertBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: invoke.ts 1`] = `
"import castPath from './.internal/castPath.js'
import last from './last.js'
import parent from './.internal/parent.js'
import toKey from './.internal/toKey.js'

/**
 * Invokes the method at \`path\` of \`object\`.
 *
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {Array} [args] The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 * @example
 *
 * const object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] }
 *
 * invoke(object, 'a[0].b.c.slice', [1, 3])
 * // => [2, 3]
 */
function invoke(object: Object, path: any[] | string, args: any[]): any {
  path = castPath(path, object)
  object = parent(object, path)
  const func = object == null ? object : object[toKey(last(path))]
  return func == null ? undefined : func.apply(object, args)
}

export default invoke
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: invokeMap.ts 1`] = `
"import baseEach from './.internal/baseEach.js'
import invoke from './invoke.js'
import isArrayLike from './isArrayLike.js'

/**
 * Invokes the method at \`path\` of each element in \`collection\`, returning
 * an array of the results of each invoked method. Any additional arguments
 * are provided to each invoked method. If \`path\` is a function, it's invoked
 * for, and \`this\` bound to, each element in \`collection\`.
 *
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|string} path The path of the method to invoke or
 *  the function invoked per iteration.
 * @param {Array} [args] The arguments to invoke each method with.
 * @returns {Array} Returns the array of results.
 * @example
 *
 * invokeMap([[5, 1, 7], [3, 2, 1]], 'sort')
 * // => [[1, 5, 7], [1, 2, 3]]
 *
 * invokeMap([123, 456], String.prototype.split, [''])
 * // => [['1', '2', '3'], ['4', '5', '6']]
 */
function invokeMap(collection: any[] | Object, path: any[] | Function | string, args: any[]): any[] {
  let index = -1
  const isFunc = typeof path == 'function'
  const result = isArrayLike(collection) ? new Array(collection.length) : []

  baseEach(collection, (value) => {
    result[++index] = isFunc ? path.apply(value, args) : invoke(value, path, args)
  })
  return result
}

export default invokeMap
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isArguments.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isObjectLike from './isObjectLike.js'

/**
 * Checks if \`value\` is likely an \`arguments\` object.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an \`arguments\` object, else \`false\`.
 * @example
 *
 * isArguments(function() { return arguments }())
 * // => true
 *
 * isArguments([1, 2, 3])
 * // => false
 */
function isArguments(value: any): boolean {
  return isObjectLike(value) && getTag(value) == '[object Arguments]'
}

export default isArguments
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isArrayBuffer.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isObjectLike from './isObjectLike.js'
import nodeTypes from './.internal/nodeTypes.js'

/* Node.js helper references. */
const nodeIsArrayBuffer = nodeTypes && nodeTypes.isArrayBuffer

/**
 * Checks if \`value\` is classified as an \`ArrayBuffer\` object.
 *
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an array buffer, else \`false\`.
 * @example
 *
 * isArrayBuffer(new ArrayBuffer(2))
 * // => true
 *
 * isArrayBuffer(new Array(2))
 * // => false
 */
const isArrayBuffer = nodeIsArrayBuffer
  ? (value) => nodeIsArrayBuffer(value)
  : (value) => isObjectLike(value) && getTag(value) == '[object ArrayBuffer]'

export default isArrayBuffer
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isArrayLike.ts 1`] = `
"import isLength from './isLength.js'

/**
 * Checks if \`value\` is array-like. A value is considered array-like if it's
 * not a function and has a \`value.length\` that's an integer greater than or
 * equal to \`0\` and less than or equal to \`Number.MAX_SAFE_INTEGER\`.
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is array-like, else \`false\`.
 * @example
 *
 * isArrayLike([1, 2, 3])
 * // => true
 *
 * isArrayLike(document.body.children)
 * // => true
 *
 * isArrayLike('abc')
 * // => true
 *
 * isArrayLike(Function)
 * // => false
 */
function isArrayLike(value: any): boolean {
  return value != null && typeof value != 'function' && isLength(value.length)
}

export default isArrayLike
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isArrayLikeObject.ts 1`] = `
"import isArrayLike from './isArrayLike.js'
import isObjectLike from './isObjectLike.js'

/**
 * This method is like \`isArrayLike\` except that it also checks if \`value\`
 * is an object.
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an array-like object,
 *  else \`false\`.
 * @example
 *
 * isArrayLikeObject([1, 2, 3])
 * // => true
 *
 * isArrayLikeObject(document.body.children)
 * // => true
 *
 * isArrayLikeObject('abc')
 * // => false
 *
 * isArrayLikeObject(Function)
 * // => false
 */
function isArrayLikeObject(value: any): boolean {
  return isObjectLike(value) && isArrayLike(value)
}

export default isArrayLikeObject
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isBoolean.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isObjectLike from './isObjectLike.js'

/**
 * Checks if \`value\` is classified as a boolean primitive or object.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a boolean, else \`false\`.
 * @example
 *
 * isBoolean(false)
 * // => true
 *
 * isBoolean(null)
 * // => false
 */
function isBoolean(value: any): boolean {
  return value === true || value === false ||
    (isObjectLike(value) && getTag(value) == '[object Boolean]')
}

export default isBoolean
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isBuffer.ts 1`] = `
"import root from './.internal/root.js'

/** Detect free variable \`exports\`. */
const freeExports = typeof exports == 'object' && exports !== null && !exports.nodeType && exports

/** Detect free variable \`module\`. */
const freeModule = freeExports && typeof module == 'object' && module !== null && !module.nodeType && module

/** Detect the popular CommonJS extension \`module.exports\`. */
const moduleExports = freeModule && freeModule.exports === freeExports

/** Built-in value references. */
const Buffer = moduleExports ? root.Buffer : undefined

/* Built-in method references for those with the same name as other \`lodash\` methods. */
const nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined

/**
 * Checks if \`value\` is a buffer.
 *
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a buffer, else \`false\`.
 * @example
 *
 * isBuffer(new Buffer(2))
 * // => true
 *
 * isBuffer(new Uint8Array(2))
 * // => false
 */
const isBuffer = nativeIsBuffer || ((): boolean => false)

export default isBuffer
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isDate.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isObjectLike from './isObjectLike.js'
import nodeTypes from './.internal/nodeTypes.js'

/* Node.js helper references. */
const nodeIsDate = nodeTypes && nodeTypes.isDate

/**
 * Checks if \`value\` is classified as a \`Date\` object.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a date object, else \`false\`.
 * @example
 *
 * isDate(new Date)
 * // => true
 *
 * isDate('Mon April 23 2012')
 * // => false
 */
const isDate = nodeIsDate
  ? (value) => nodeIsDate(value)
  : (value) => isObjectLike(value) && getTag(value) == '[object Date]'

export default isDate
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isElement.ts 1`] = `
"import isObjectLike from './isObjectLike.js'
import isPlainObject from './isPlainObject.js'

/**
 * Checks if \`value\` is likely a DOM element.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a DOM element, else \`false\`.
 * @example
 *
 * isElement(document.body)
 * // => true
 *
 * isElement('<body>')
 * // => false
 */
function isElement(value: any): boolean {
  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value)
}

export default isElement
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isEmpty.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isArguments from './isArguments.js'
import isArrayLike from './isArrayLike.js'
import isBuffer from './isBuffer.js'
import isPrototype from './.internal/isPrototype.js'
import isTypedArray from './isTypedArray.js'

/** Used to check objects for own properties. */
const hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Checks if \`value\` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as \`arguments\` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a \`length\` of \`0\`.
 * Similarly, maps and sets are considered empty if they have a \`size\` of \`0\`.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is empty, else \`false\`.
 * @example
 *
 * isEmpty(null)
 * // => true
 *
 * isEmpty(true)
 * // => true
 *
 * isEmpty(1)
 * // => true
 *
 * isEmpty([1, 2, 3])
 * // => false
 *
 * isEmpty('abc')
 * // => false
 *
 * isEmpty({ 'a': 1 })
 * // => false
 */
function isEmpty(value: any): boolean {
  if (value == null) {
    return true
  }
  if (isArrayLike(value) &&
      (Array.isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length
  }
  const tag = getTag(value)
  if (tag == '[object Map]' || tag == '[object Set]') {
    return !value.size
  }
  if (isPrototype(value)) {
    return !Object.keys(value).length
  }
  for (const key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false
    }
  }
  return true
}

export default isEmpty
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isEqualWith.ts 1`] = `
"import baseIsEqual from './.internal/baseIsEqual.js'

/**
 * This method is like \`isEqual\` except that it accepts \`customizer\` which
 * is invoked to compare values. If \`customizer\` returns \`undefined\`, comparisons
 * are handled by the method instead. The \`customizer\` is invoked with up to
 * six arguments: (objValue, othValue [, index|key, object, other, stack]).
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns \`true\` if the values are equivalent, else \`false\`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value)
 * }
 *
 * function customizer(objValue, othValue) {
 *   if (isGreeting(objValue) && isGreeting(othValue)) {
 *     return true
 *   }
 * }
 *
 * const array = ['hello', 'goodbye']
 * const other = ['hi', 'goodbye']
 *
 * isEqualWith(array, other, customizer)
 * // => true
 */
function isEqualWith(value: any, other: any, customizer: Function): boolean {
  customizer = typeof customizer == 'function' ? customizer : undefined
  const result = customizer ? customizer(value, other) : undefined
  return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result
}

export default isEqualWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isError.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isObjectLike from './isObjectLike.js'
import isPlainObject from './isPlainObject.js'

/**
 * Checks if \`value\` is an \`Error\`, \`EvalError\`, \`RangeError\`, \`ReferenceError\`,
 * \`SyntaxError\`, \`TypeError\`, or \`URIError\` object.
 *
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an error object, else \`false\`.
 * @example
 *
 * isError(new Error)
 * // => true
 *
 * isError(Error)
 * // => false
 */
function isError(value: any): boolean {
  if (!isObjectLike(value)) {
    return false
  }
  const tag = getTag(value)
  return tag == '[object Error]' || tag == '[object DOMException]' ||
    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value))
}

export default isError
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isFunction.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isObject from './isObject.js'

/**
 * Checks if \`value\` is classified as a \`Function\` object.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a function, else \`false\`.
 * @example
 *
 * isFunction(_)
 * // => true
 *
 * isFunction(/abc/)
 * // => false
 */
function isFunction(value: any): boolean {
  if (!isObject(value)) {
    return false
  }
  // The use of \`Object#toString\` avoids issues with the \`typeof\` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  const tag = getTag(value)
  return tag == '[object Function]' || tag == '[object AsyncFunction]' ||
    tag == '[object GeneratorFunction]' || tag == '[object Proxy]'
}

export default isFunction
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isLength.ts 1`] = `
"/** Used as references for various \`Number\` constants. */
const MAX_SAFE_INTEGER = 9007199254740991

/**
 * Checks if \`value\` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [\`ToLength\`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a valid length, else \`false\`.
 * @example
 *
 * isLength(3)
 * // => true
 *
 * isLength(Number.MIN_VALUE)
 * // => false
 *
 * isLength(Infinity)
 * // => false
 *
 * isLength('3')
 * // => false
 */
function isLength(value: any): boolean {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER
}

export default isLength
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isMap.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isObjectLike from './isObjectLike.js'
import nodeTypes from './.internal/nodeTypes.js'

/* Node.js helper references. */
const nodeIsMap = nodeTypes && nodeTypes.isMap

/**
 * Checks if \`value\` is classified as a \`Map\` object.
 *
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a map, else \`false\`.
 * @example
 *
 * isMap(new Map)
 * // => true
 *
 * isMap(new WeakMap)
 * // => false
 */
const isMap = nodeIsMap
  ? (value) => nodeIsMap(value)
  : (value) => isObjectLike(value) && getTag(value) == '[object Map]'

export default isMap
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isMatch.ts 1`] = `
"import baseIsMatch from './.internal/baseIsMatch.js'
import getMatchData from './.internal/getMatchData.js'

/**
 * Performs a partial deep comparison between \`object\` and \`source\` to
 * determine if \`object\` contains equivalent property values.
 *
 * **Note:** This method is equivalent to \`matches\` when \`source\` is
 * partially applied.
 *
 * Partial comparisons will match empty array and empty object \`source\`
 * values against any array or object value, respectively. See \`isEqual\`
 * for a list of supported value comparisons.
 *
 * @since 3.0.0
 * @category Lang
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @returns {boolean} Returns \`true\` if \`object\` is a match, else \`false\`.
 * @example
 *
 * const object = { 'a': 1, 'b': 2 }
 *
 * isMatch(object, { 'b': 2 })
 * // => true
 *
 * isMatch(object, { 'b': 1 })
 * // => false
 */
function isMatch(object: Object, source: Object): boolean {
  return object === source || baseIsMatch(object, source, getMatchData(source))
}

export default isMatch
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isMatchWith.ts 1`] = `
"import baseIsMatch from './.internal/baseIsMatch.js'
import getMatchData from './.internal/getMatchData.js'

/**
 * This method is like \`isMatch\` except that it accepts \`customizer\` which
 * is invoked to compare values. If \`customizer\` returns \`undefined\`, comparisons
 * are handled by the method instead. The \`customizer\` is invoked with five
 * arguments: (objValue, srcValue, index|key, object, source).
 *
 * @since 4.0.0
 * @category Lang
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns \`true\` if \`object\` is a match, else \`false\`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value)
 * }
 *
 * function customizer(objValue, srcValue) {
 *   if (isGreeting(objValue) && isGreeting(srcValue)) {
 *     return true
 *   }
 * }
 *
 * const object = { 'greeting': 'hello' }
 * const source = { 'greeting': 'hi' }
 *
 * isMatchWith(object, source, customizer)
 * // => true
 */
function isMatchWith(object: Object, source: Object, customizer: Function): boolean {
  customizer = typeof customizer == 'function' ? customizer : undefined
  return baseIsMatch(object, source, getMatchData(source), customizer)
}

export default isMatchWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isNative.ts 1`] = `
"import isObject from './isObject.js'

/**
 * Used to match \`RegExp\`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
const reRegExpChar = /[\\\\\\\\^$.*+?()[\\\\]{}|]/g

/** Used to detect if a method is native. */
const reIsNative = RegExp(\`^\${
  Function.prototype.toString.call(Object.prototype.hasOwnProperty)
    .replace(reRegExpChar, '\\\\\\\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\\\\\\\\\\()| for .+?(?=\\\\\\\\\\\\])/g, '$1.*?')
}$\`)

/**
 * Checks if \`value\` is a pristine native function.
 *
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a native function,
 *  else \`false\`.
 * @example
 *
 * isNative(Array.prototype.push)
 * // => true
 *
 * isNative(isDate)
 * // => false
 */
function isNative(value: any): boolean {
  return isObject(value) && reIsNative.test(value)
}

export default isNative
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isNil.ts 1`] = `
"/**
 * Checks if \`value\` is \`null\` or \`undefined\`.
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is nullish, else \`false\`.
 * @example
 *
 * isNil(null)
 * // => true
 *
 * isNil(void 0)
 * // => true
 *
 * isNil(NaN)
 * // => false
 */
function isNil(value: any): boolean {
  return value == null
}

export default isNil
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isNull.ts 1`] = `
"/**
 * Checks if \`value\` is \`null\`.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is \`null\`, else \`false\`.
 * @example
 *
 * isNull(null)
 * // => true
 *
 * isNull(void 0)
 * // => false
 */
function isNull(value: any): boolean {
  return value === null
}

export default isNull
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isNumber.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isObjectLike from './isObjectLike.js'

/**
 * Checks if \`value\` is classified as a \`Number\` primitive or object.
 *
 * **Note:** To exclude \`Infinity\`, \`-Infinity\`, and \`NaN\`, which are
 * classified as numbers, use the \`Number.isFinite\` method.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a number, else \`false\`.
 * @see isInteger, toInteger, toNumber
 * @example
 *
 * isNumber(3)
 * // => true
 *
 * isNumber(Number.MIN_VALUE)
 * // => true
 *
 * isNumber(Infinity)
 * // => true
 *
 * isNumber('3')
 * // => false
 */
function isNumber(value: any): boolean {
  return typeof value == 'number' ||
    (isObjectLike(value) && getTag(value) == '[object Number]')
}

export default isNumber
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isObject.ts 1`] = `
"/**
 * Checks if \`value\` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of \`Object\`. (e.g. arrays, functions, objects, regexes, \`new Number(0)\`, and \`new String('')\`)
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an object, else \`false\`.
 * @example
 *
 * isObject({})
 * // => true
 *
 * isObject([1, 2, 3])
 * // => true
 *
 * isObject(Function)
 * // => true
 *
 * isObject(null)
 * // => false
 */
function isObject(value: any): boolean {
  const type = typeof value
  return value != null && (type == 'object' || type == 'function')
}

export default isObject
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isObjectLike.ts 1`] = `
"/**
 * Checks if \`value\` is object-like. A value is object-like if it's not \`null\`
 * and has a \`typeof\` result of \\"object\\".
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is object-like, else \`false\`.
 * @example
 *
 * isObjectLike({})
 * // => true
 *
 * isObjectLike([1, 2, 3])
 * // => true
 *
 * isObjectLike(Function)
 * // => false
 *
 * isObjectLike(null)
 * // => false
 */
function isObjectLike(value: any): boolean {
  return typeof value == 'object' && value !== null
}

export default isObjectLike
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isPlainObject.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isObjectLike from './isObjectLike.js'

/**
 * Checks if \`value\` is a plain object, that is, an object created by the
 * \`Object\` constructor or one with a \`[[Prototype]]\` of \`null\`.
 *
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a plain object, else \`false\`.
 * @example
 *
 * function Foo() {
 *   this.a = 1
 * }
 *
 * isPlainObject(new Foo)
 * // => false
 *
 * isPlainObject([1, 2, 3])
 * // => false
 *
 * isPlainObject({ 'x': 0, 'y': 0 })
 * // => true
 *
 * isPlainObject(Object.create(null))
 * // => true
 */
function isPlainObject(value: any): boolean {
  if (!isObjectLike(value) || getTag(value) != '[object Object]') {
    return false
  }
  if (Object.getPrototypeOf(value) === null) {
    return true
  }
  let proto = value
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto)
  }
  return Object.getPrototypeOf(value) === proto
}

export default isPlainObject
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isRegExp.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isObjectLike from './isObjectLike.js'
import nodeTypes from './.internal/nodeTypes.js'

/* Node.js helper references. */
const nodeIsRegExp = nodeTypes && nodeTypes.isRegExp

/**
 * Checks if \`value\` is classified as a \`RegExp\` object.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a regexp, else \`false\`.
 * @example
 *
 * isRegExp(/abc/)
 * // => true
 *
 * isRegExp('/abc/')
 * // => false
 */
const isRegExp = nodeIsRegExp
  ? (value) => nodeIsRegExp(value)
  : (value) => isObjectLike(value) && getTag(value) == '[object RegExp]'

export default isRegExp
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isSet.ts 1`] = `
"import getTag from './.internal/getTag.js'
import nodeTypes from './.internal/nodeTypes.js'
import isObjectLike from './isObjectLike.js'

/* Node.js helper references. */
const nodeIsSet = nodeTypes && nodeTypes.isSet

/**
 * Checks if \`value\` is classified as a \`Set\` object.
 *
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a set, else \`false\`.
 * @example
 *
 * isSet(new Set)
 * // => true
 *
 * isSet(new WeakSet)
 * // => false
 */
const isSet = nodeIsSet
  ? (value) => nodeIsSet(value)
  : (value) => isObjectLike(value) && getTag(value) == '[object Set]'

export default isSet
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isString.ts 1`] = `
"import getTag from './.internal/getTag.js'

/**
 * Checks if \`value\` is classified as a \`String\` primitive or object.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a string, else \`false\`.
 * @example
 *
 * isString('abc')
 * // => true
 *
 * isString(1)
 * // => false
 */
function isString(value: any): boolean {
  const type = typeof value
  return type == 'string' || (type == 'object' && value != null && !Array.isArray(value) && getTag(value) == '[object String]')
}

export default isString
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isSymbol.ts 1`] = `
"import getTag from './.internal/getTag.js'

/**
 * Checks if \`value\` is classified as a \`Symbol\` primitive or object.
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a symbol, else \`false\`.
 * @example
 *
 * isSymbol(Symbol.iterator)
 * // => true
 *
 * isSymbol('abc')
 * // => false
 */
function isSymbol(value: any): boolean {
  const type = typeof value
  return type == 'symbol' || (type == 'object' && value != null && getTag(value) == '[object Symbol]')
}

export default isSymbol
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isTypedArray.ts 1`] = `
"import getTag from './.internal/getTag.js'
import nodeTypes from './.internal/nodeTypes.js'
import isObjectLike from './isObjectLike.js'

/** Used to match \`toStringTag\` values of typed arrays. */
const reTypedTag = /^\\\\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)\\\\]$/

/* Node.js helper references. */
const nodeIsTypedArray = nodeTypes && nodeTypes.isTypedArray

/**
 * Checks if \`value\` is classified as a typed array.
 *
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a typed array, else \`false\`.
 * @example
 *
 * isTypedArray(new Uint8Array)
 * // => true
 *
 * isTypedArray([])
 * // => false
 */
const isTypedArray = nodeIsTypedArray
  ? (value) => nodeIsTypedArray(value)
  : (value) => isObjectLike(value) && reTypedTag.test(getTag(value))

export default isTypedArray
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isUndefined.ts 1`] = `
"/**
 * Checks if \`value\` is \`undefined\`.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is \`undefined\`, else \`false\`.
 * @example
 *
 * isUndefined(void 0)
 * // => true
 *
 * isUndefined(null)
 * // => false
 */
function isUndefined(value: any): boolean {
  return value === undefined
}

export default isUndefined
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isWeakMap.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isObjectLike from './isObjectLike.js'

/**
 * Checks if \`value\` is classified as a \`WeakMap\` object.
 *
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a weak map, else \`false\`.
 * @example
 *
 * isWeakMap(new WeakMap)
 * // => true
 *
 * isWeakMap(new Map)
 * // => false
 */
function isWeakMap(value: any): boolean {
  return isObjectLike(value) && getTag(value) == '[object WeakMap]'
}

export default isWeakMap
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: isWeakSet.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isObjectLike from './isObjectLike.js'

/**
 * Checks if \`value\` is classified as a \`WeakSet\` object.
 *
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a weak set, else \`false\`.
 * @example
 *
 * isWeakSet(new WeakSet)
 * // => true
 *
 * isWeakSet(new Set)
 * // => false
 */
function isWeakSet(value: any): boolean {
  return isObjectLike(value) && getTag(value) == '[object WeakSet]'
}

export default isWeakSet
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: kebabCase.ts 1`] = `
"import words from './words.js'

/**
 * Converts \`string\` to
 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @see camelCase, lowerCase, snakeCase, startCase, upperCase, upperFirst
 * @example
 *
 * kebabCase('Foo Bar')
 * // => 'foo-bar'
 *
 * kebabCase('fooBar')
 * // => 'foo-bar'
 *
 * kebabCase('__FOO_BAR__')
 * // => 'foo-bar'
 */
const kebabCase = (string) => (
  words(\`\${string}\`.replace(/['\\\\u2019]/g, '')).reduce((result, word, index) => (
    result + (index ? '-' : '') + word.toLowerCase()
  ), '')
)

export default kebabCase
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: keyBy.ts 1`] = `
"import baseAssignValue from './.internal/baseAssignValue.js'
import reduce from './reduce.js'

/**
 * Creates an object composed of keys generated from the results of running
 * each element of \`collection\` thru \`iteratee\`. The corresponding value of
 * each key is the last element responsible for generating the key. The
 * iteratee is invoked with one argument: (value).
 *
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @see groupBy, partition
 * @example
 *
 * const array = [
 *   { 'dir': 'left', 'code': 97 },
 *   { 'dir': 'right', 'code': 100 }
 * ]
 *
 * keyBy(array, ({ code }) => String.fromCharCode(code))
 * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
 */
function keyBy(collection: any[] | Object, iteratee: Function): Object {
  return reduce(collection, (result, value, key) => (
    baseAssignValue(result, iteratee(value), value), result
  ), {})
}

export default keyBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: keys.ts 1`] = `
"import arrayLikeKeys from './.internal/arrayLikeKeys.js'
import isArrayLike from './isArrayLike.js'

/**
 * Creates an array of the own enumerable property names of \`object\`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @since 0.1.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @see values, valuesIn
 * @example
 *
 * function Foo() {
 *   this.a = 1
 *   this.b = 2
 * }
 *
 * Foo.prototype.c = 3
 *
 * keys(new Foo)
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * keys('hi')
 * // => ['0', '1']
 */
function keys(object: Object): any[] {
  return isArrayLike(object)
    ? arrayLikeKeys(object)
    : Object.keys(Object(object))
}

export default keys
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: keysIn.ts 1`] = `
"/**
 * Creates an array of the own and inherited enumerable property names of \`object\`.
 *
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object: Object): any[] {
  const result = []
  for (const key in object) {
    result.push(key)
  }
  return result
}

export default keysIn

"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: last.ts 1`] = `
"/**
 * Gets the last element of \`array\`.
 *
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of \`array\`.
 * @example
 *
 * last([1, 2, 3])
 * // => 3
 */
function last(array: any[]): any {
  const length = array == null ? 0 : array.length
  return length ? array[length - 1] : undefined
}

export default last
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: lastIndexOf.ts 1`] = `
"import baseFindIndex from './.internal/baseFindIndex.js'
import baseIsNaN from './.internal/baseIsNaN.js'
import strictLastIndexOf from './.internal/strictLastIndexOf.js'

/**
 * This method is like \`indexOf\` except that it iterates over elements of
 * \`array\` from right to left.
 *
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 * @example
 *
 * lastIndexOf([1, 2, 1, 2], 2)
 * // => 3
 *
 * // Search from the \`fromIndex\`.
 * lastIndexOf([1, 2, 1, 2], 2, 2)
 * // => 1
 */
function lastIndexOf(array: any[], value: any, fromIndex: number): number {
  const length = array == null ? 0 : array.length
  if (!length) {
    return -1
  }
  let index = length
  if (fromIndex !== undefined) {
    index = index < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1)
  }
  return value === value
    ? strictLastIndexOf(array, value, index)
    : baseFindIndex(array, baseIsNaN, index, true)
}

export default lastIndexOf
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: lowerCase.ts 1`] = `
"import words from './words.js'

const reQuotes = /['\\\\u2019]/g

/**
 * Converts \`string\`, as space separated words, to lower case.
 *
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the lower cased string.
 * @see camelCase, kebabCase, snakeCase, startCase, upperCase, upperFirst
 * @example
 *
 * lowerCase('--Foo-Bar--')
 * // => 'foo bar'
 *
 * lowerCase('fooBar')
 * // => 'foo bar'
 *
 * lowerCase('__FOO_BAR__')
 * // => 'foo bar'
 */
const lowerCase = (string) => (
  words(\`\${string}\`.replace(reQuotes, '')).reduce((result, word, index) => (
    result + (index ? ' ' : '') + word.toLowerCase()
  ), '')
)

export default lowerCase
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: lowerFirst.ts 1`] = `
"import createCaseFirst from './.internal/createCaseFirst.js'

/**
 * Converts the first character of \`string\` to lower case.
 *
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * lowerFirst('Fred')
 * // => 'fred'
 *
 * lowerFirst('FRED')
 * // => 'fRED'
 */
const lowerFirst = createCaseFirst('toLowerCase')

export default lowerFirst
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: lt.ts 1`] = `
"/**
 * Checks if \`value\` is less than \`other\`.
 *
 * @since 3.9.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns \`true\` if \`value\` is less than \`other\`,
 *  else \`false\`.
 * @see gt, gte, lte
 * @example
 *
 * lt(1, 3)
 * // => true
 *
 * lt(3, 3)
 * // => false
 *
 * lt(3, 1)
 * // => false
 */
function lt(value: any, other: any): boolean {
  if (!(typeof value == 'string' && typeof other == 'string')) {
    value = +value
    other = +other
  }
  return value < other
}

export default lt
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: lte.ts 1`] = `
"/**
 * Checks if \`value\` is less than or equal to \`other\`.
 *
 * @since 3.9.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns \`true\` if \`value\` is less than or equal to
 *  \`other\`, else \`false\`.
 * @see gt, gte, lt
 * @example
 *
 * lte(1, 3)
 * // => true
 *
 * lte(3, 3)
 * // => true
 *
 * lte(3, 1)
 * // => false
 */
function lte(value: any, other: any): boolean {
  if (!(typeof value == 'string' && typeof other == 'string')) {
    value = +value
    other = +other
  }
  return value <= other
}

export default lte
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: map.ts 1`] = `
"/**
 * Creates an array of values by running each element of \`array\` thru \`iteratee\`.
 * The iteratee is invoked with three arguments: (value, index, array).
 *
 * @since 5.0.0
 * @category Array
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n
 * }
 *
 * map([4, 8], square)
 * // => [16, 64]
 */
function map(array: any[], iteratee: Function): any[] {
  let index = -1
  const length = array == null ? 0 : array.length
  const result = new Array(length)

  while (++index < length) {
    result[index] = iteratee(array[index], index, array)
  }
  return result
}

export default map
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: mapKey.ts 1`] = `
"/**
 * The opposite of \`mapValue\` this method creates an object with the
 * same values as \`object\` and keys generated by running each own enumerable
 * string keyed property of \`object\` thru \`iteratee\`. The iteratee is invoked
 * with three arguments: (value, key, object).
 *
 * @since 3.8.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see mapValue
 * @example
 *
 * mapKey({ 'a': 1, 'b': 2 }, function(value, key) {
 *   return key + value
 * })
 * // => { 'a1': 1, 'b2': 2 }
 */
function mapKey(object: Object, iteratee: Function): Object {
  object = Object(object)
  const result = {}

  Object.keys(object).forEach((key) => {
    const value = object[key]
    result[iteratee(value, key, object)] = value
  })
  return result
}

export default mapKey
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: mapObject.ts 1`] = `
"/**
 * Creates an array of values by running each property of \`object\` thru
 * \`iteratee\`. The iteratee is invoked with three arguments: (value, key, object).
 *
 * @since 5.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n
 * }
 *
 * map({ 'a': 4, 'b': 8 }, square)
 * // => [16, 64] (iteration order is not guaranteed)
 */
function mapObject(object: Object, iteratee: Function): any[] {
  const props = Object.keys(object)
  const result = new Array(props.length)

  props.forEach((key, index) => {
    result[index] = iteratee(object[key], key, object)
  })
  return result
}

export default mapObject
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: mapValue.ts 1`] = `
"/**
 * Creates an object with the same keys as \`object\` and values generated
 * by running each own enumerable string keyed property of \`object\` thru
 * \`iteratee\`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see mapKeys
 * @example
 *
 * const users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * }
 *
 * mapValue(users, ({ age }) => age)
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValue(object: Object, iteratee: Function): Object {
  object = Object(object)
  const result = {}

  Object.keys(object).forEach((key) => {
    result[key] = iteratee(object[key], key, object)
  })
  return result
}

export default mapValue
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: matches.ts 1`] = `
"import baseClone from './.internal/baseClone.js'
import baseMatches from './.internal/baseMatches.js'

/** Used to compose bitmasks for cloning. */
const CLONE_DEEP_FLAG = 1

/**
 * Creates a function that performs a partial deep comparison between a given
 * object and \`source\`, returning \`true\` if the given object has equivalent
 * property values, else \`false\`.
 *
 * **Note:** The created function is equivalent to \`isMatch\` with \`source\`
 * partially applied.
 *
 * Partial comparisons will match empty array and empty object \`source\`
 * values against any array or object value, respectively. See \`isEqual\`
 * for a list of supported value comparisons.
 *
 * @since 3.0.0
 * @category Util
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 * @example
 *
 * const objects = [
 *   { 'a': 1, 'b': 2, 'c': 3 },
 *   { 'a': 4, 'b': 5, 'c': 6 }
 * ]
 *
 * filter(objects, matches({ 'a': 4, 'c': 6 }))
 * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
 */
function matches(source: Object): Function {
  return baseMatches(baseClone(source, CLONE_DEEP_FLAG))
}

export default matches
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: matchesProperty.ts 1`] = `
"import baseClone from './.internal/baseClone.js'
import baseMatchesProperty from './.internal/baseMatchesProperty.js'

/** Used to compose bitmasks for cloning. */
const CLONE_DEEP_FLAG = 1

/**
 * Creates a function that performs a partial deep comparison between the
 * value at \`path\` of a given object to \`srcValue\`, returning \`true\` if the
 * object value is equivalent, else \`false\`.
 *
 * **Note:** Partial comparisons will match empty array and empty object
 * \`srcValue\` values against any array or object value, respectively. See
 * \`isEqual\` for a list of supported value comparisons.
 *
 * @since 3.2.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 * @example
 *
 * const objects = [
 *   { 'a': 1, 'b': 2, 'c': 3 },
 *   { 'a': 4, 'b': 5, 'c': 6 }
 * ]
 *
 * find(objects, matchesProperty('a', 4))
 * // => { 'a': 4, 'b': 5, 'c': 6 }
 */
function matchesProperty(path: any[] | string, srcValue: any): Function {
  return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG))
}

export default matchesProperty
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: maxBy.ts 1`] = `
"import isSymbol from './isSymbol.js'

/**
 * This method is like \`max\` except that it accepts \`iteratee\` which is
 * invoked for each element in \`array\` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * const objects = [{ 'n': 1 }, { 'n': 2 }]
 *
 * maxBy(objects, ({ n }) => n)
 * // => { 'n': 2 }
 */
function maxBy(array: any[], iteratee: Function): any {
  let result
  if (array == null) {
    return result
  }
  let computed
  for (const value of array) {
    const current = iteratee(value)

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol(current))
          : (current > computed)
        )) {
      computed = current
      result = value
    }
  }
  return result
}

export default maxBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: mean.ts 1`] = `
"import baseMean from './meanBy.js'

/**
 * Computes the mean of the values in \`array\`.
 *
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the mean.
 * @example
 *
 * mean([4, 2, 8, 6])
 * // => 5
 */
function mean(array: any[]): number {
  return baseMean(array, (value) => value)
}

export default mean
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: meanBy.ts 1`] = `
"import baseSum from './.internal/baseSum.js'

/** Used as references for various \`Number\` constants. */
const NAN = 0 / 0

/**
 * This method is like \`mean\` except that it accepts \`iteratee\` which is
 * invoked for each element in \`array\` to generate the value to be averaged.
 * The iteratee is invoked with one argument: (value).
 *
 * @since 4.7.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {number} Returns the mean.
 * @example
 *
 * const objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }]
 *
 * meanBy(objects, ({ n }) => n)
 * // => 5
 */
function meanBy(array: any[], iteratee: Function): number {
  const length = array == null ? 0 : array.length
  return length ? (baseSum(array, iteratee) / length) : NAN
}

export default meanBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: memoize.ts 1`] = `
"/**
 * Creates a function that memoizes the result of \`func\`. If \`resolver\` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The \`func\`
 * is invoked with the \`this\` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the \`cache\` property on the memoized
 * function. Its creation may be customized by replacing the \`memoize.Cache\`
 * constructor with one whose instances implement the
 * [\`Map\`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of \`clear\`, \`delete\`, \`get\`, \`has\`, and \`set\`.
 *
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * const object = { 'a': 1, 'b': 2 }
 * const other = { 'c': 3, 'd': 4 }
 *
 * const values = memoize(values)
 * values(object)
 * // => [1, 2]
 *
 * values(other)
 * // => [3, 4]
 *
 * object.a = 2
 * values(object)
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b'])
 * values(object)
 * // => ['a', 'b']
 *
 * // Replace \`memoize.Cache\`.
 * memoize.Cache = WeakMap
 */
function memoize(func: Function, resolver: Function): Function {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError('Expected a function')
  }
  const memoized = function(...args) {
    const key = resolver ? resolver.apply(this, args) : args[0]
    const cache = memoized.cache

    if (cache.has(key)) {
      return cache.get(key)
    }
    const result = func.apply(this, args)
    memoized.cache = cache.set(key, result) || cache
    return result
  }
  memoized.cache = new (memoize.Cache || Map)
  return memoized
}

memoize.Cache = Map

export default memoize
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: merge.ts 1`] = `
"import baseMerge from './.internal/baseMerge.js'
import createAssigner from './.internal/createAssigner.js'

/**
 * This method is like \`assign\` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to \`undefined\` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates \`object\`.
 *
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns \`object\`.
 * @example
 *
 * const object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * }
 *
 * const other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * }
 *
 * merge(object, other)
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
const merge = createAssigner((object: Object, source: Object[], srcIndex: any): Object => {
  baseMerge(object, source, srcIndex)
})

export default merge
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: mergeWith.ts 1`] = `
"import baseMerge from './.internal/baseMerge.js'
import createAssigner from './.internal/createAssigner.js'

/**
 * This method is like \`merge\` except that it accepts \`customizer\` which
 * is invoked to produce the merged values of the destination and source
 * properties. If \`customizer\` returns \`undefined\`, merging is handled by the
 * method instead. The \`customizer\` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates \`object\`.
 *
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns \`object\`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (Array.isArray(objValue)) {
 *     return objValue.concat(srcValue)
 *   }
 * }
 *
 * const object = { 'a': [1], 'b': [2] }
 * const other = { 'a': [3], 'b': [4] }
 *
 * mergeWith(object, other, customizer)
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
const mergeWith = createAssigner((object: Object, source: Object[], srcIndex: Function, customizer: any): Object => {
  baseMerge(object, source, srcIndex, customizer)
})

export default mergeWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: method.ts 1`] = `
"import invoke from './invoke.js'

/**
 * Creates a function that invokes the method at \`path\` of a given object.
 * Any additional arguments are provided to the invoked method.
 *
 * @since 3.7.0
 * @category Util
 * @param {Array|string} path The path of the method to invoke.
 * @param {Array} [args] The arguments to invoke the method with.
 * @returns {Function} Returns the new invoker function.
 * @example
 *
 * const objects = [
 *   { 'a': { 'b': () => 2 } },
 *   { 'a': { 'b': () => 1 } }
 * ]
 *
 * map(objects, method('a.b'))
 * // => [2, 1]
 *
 * map(objects, method(['a', 'b']))
 * // => [2, 1]
 */
function method(path: any[] | string, args: any[]): Function {
  return (object) => invoke(object, path, args)
}

export default method
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: methodOf.ts 1`] = `
"import invoke from './invoke.js'

/**
 * The opposite of \`method\` this method creates a function that invokes
 * the method at a given path of \`object\`. Any additional arguments are
 * provided to the invoked method.
 *
 * @since 3.7.0
 * @category Util
 * @param {Object} object The object to query.
 * @param {Array} [args] The arguments to invoke the method with.
 * @returns {Function} Returns the new invoker function.
 * @example
 *
 * const array = times(3, i => () => i)
 * const object = { 'a': array, 'b': array, 'c': array }
 *
 * map(['a[2]', 'c[0]'], methodOf(object))
 * // => [2, 0]
 *
 * map([['a', '2'], ['c', '0']], methodOf(object))
 * // => [2, 0]f
 */
function methodOf(object: Object, args: any[]): Function {
  return (path) => invoke(object, path, args)
}

export default methodOf
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: minBy.ts 1`] = `
"import isSymbol from './isSymbol.js'

/**
 * This method is like \`min\` except that it accepts \`iteratee\` which is
 * invoked for each element in \`array\` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * const objects = [{ 'n': 1 }, { 'n': 2 }]
 *
 * minBy(objects, ({ n }) => n)
 * // => { 'n': 1 }
 */
function minBy(array: any[], iteratee: Function): any {
  let result
  if (array == null) {
    return result
  }
  let computed
  for (const value of array) {
    const current = iteratee(value)

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol(current))
          : (current < computed)
        )) {
      computed = current
      result = value
    }
  }
  return result
}

export default minBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: multiply.ts 1`] = `
"import createMathOperation from './.internal/createMathOperation.js'

/**
 * Multiply two numbers.
 *
 * @since 4.7.0
 * @category Math
 * @param {number} multiplier The first number in a multiplication.
 * @param {number} multiplicand The second number in a multiplication.
 * @returns {number} Returns the product.
 * @example
 *
 * multiply(6, 4)
 * // => 24
 */
const multiply = createMathOperation((multiplier: number, multiplicand: number): number => multiplier * multiplicand, 1)

export default multiply
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: negate.ts 1`] = `
"/**
 * Creates a function that negates the result of the predicate \`func\`. The
 * \`func\` predicate is invoked with the \`this\` binding and arguments of the
 * created function.
 *
 * @since 3.0.0
 * @category Function
 * @param {Function} predicate The predicate to negate.
 * @returns {Function} Returns the new negated function.
 * @example
 *
 * function isEven(n) {
 *   return n % 2 == 0
 * }
 *
 * filter([1, 2, 3, 4, 5, 6], negate(isEven))
 * // => [1, 3, 5]
 */
function negate(predicate: Function): Function {
  if (typeof predicate != 'function') {
    throw new TypeError('Expected a function')
  }
  return function(...args) {
    return !predicate.apply(this, args)
  }
}

export default negate
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: nth.ts 1`] = `
"import isIndex from './.internal/isIndex.js'

/**
 * Gets the element at index \`n\` of \`array\`. If \`n\` is negative, the nth
 * element from the end is returned.
 *
 * @since 4.11.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=0] The index of the element to return.
 * @returns {*} Returns the nth element of \`array\`.
 * @example
 *
 * const array = ['a', 'b', 'c', 'd']
 *
 * nth(array, 1)
 * // => 'b'
 *
 * nth(array, -2)
 * // => 'c'
 */
function nth(array: any[], n: number): any {
  const length = array == null ? 0 : array.length
  if (!length) {
    return
  }
  n += n < 0 ? length : 0
  return isIndex(n, length) ? array[n] : undefined
}

export default nth
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: nthArg.ts 1`] = `
"import nth from './nth.js'

/**
 * Creates a function that gets the argument at index \`n\`. If \`n\` is negative,
 * the nth argument from the end is returned.
 *
 * @since 4.0.0
 * @category Util
 * @param {number} [n=0] The index of the argument to return.
 * @returns {Function} Returns the new pass-thru function.
 * @example
 *
 * const func = nthArg(1)
 * func('a', 'b', 'c', 'd')
 * // => 'b'
 *
 * const func = nthArg(-2)
 * func('a', 'b', 'c', 'd')
 * // => 'c'
 */
function nthArg(n: number): Function {
  return (...args) => nth(args, n)
}

export default nthArg
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: once.ts 1`] = `
"import before from './before.js'

/**
 * Creates a function that is restricted to invoking \`func\` once. Repeat calls
 * to the function return the value of the first invocation. The \`func\` is
 * invoked with the \`this\` binding and arguments of the created function.
 *
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * const initialize = once(createApplication)
 * initialize()
 * initialize()
 * // => \`createApplication\` is invoked once
 */
function once(func: Function): Function {
  return before(2, func)
}

export default once
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: orderBy.ts 1`] = `
"import baseOrderBy from './.internal/baseOrderBy.js'

/**
 * This method is like \`sortBy\` except that it allows specifying the sort
 * orders of the iteratees to sort by. If \`orders\` is unspecified, all values
 * are sorted in ascending order. Otherwise, specify an order of \\"desc\\" for
 * descending or \\"asc\\" for ascending sort order of corresponding values.
 * You may also specify a compare function for an order.
 *
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[identity]]
 *  The iteratees to sort by.
 * @param {(string|function)[]} [orders] The sort orders of \`iteratees\`.
 * @returns {Array} Returns the new sorted array.
 * @see reverse
 * @example
 *
 * const users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 34 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 36 }
 * ]
 *
 * // Sort by \`user\` in ascending order and by \`age\` in descending order.
 * orderBy(users, ['user', 'age'], ['asc', 'desc'])
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * // Sort by \`user\` then by \`age\` using custom compare functions for each
 * orderBy(users, ['user', 'age'], [
 *   (a, b) => a.localeCompare(b, 'de', { sensitivity: 'base' }),
 *   (a, b) => a - b,
 * ])
 *
 */
function orderBy(
  collection: any[] | Object,
  iteratees: any[][] | Function[] | Object[] | string[],
  orders: string[] | function[]
): any[] {
  if (collection == null) {
    return []
  }
  if (!Array.isArray(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees]
  }
  if (!Array.isArray(orders)) {
    orders = orders == null ? [] : [orders]
  }
  return baseOrderBy(collection, iteratees, orders)
}

export default orderBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: over.ts 1`] = `
"import map from './map.js'

/**
 * Creates a function that invokes \`iteratees\` with the arguments it receives
 * and returns their results.
 *
 * @since 4.0.0
 * @category Util
 * @param {Function[]} [iteratees=[identity]]
 *  The iteratees to invoke.
 * @returns {Function} Returns the new function.
 * @example
 *
 * const func = over([Math.max, Math.min])
 *
 * func(1, 2, 3, 4)
 * // => [4, 1]
 */
function over(iteratees: Function[]): Function {
  return function(...args) {
    return map(iteratees, (iteratee) => iteratee.apply(this, args))
  }
}

export default over
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: overArgs.ts 1`] = `
"
/**
 * Creates a function that invokes \`func\` with its arguments transformed.
 *
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to wrap.
 * @param {Function[]} [transforms=[identity]]
 *  The argument transforms.
 * @returns {Function} Returns the new function.
 * @example
 *
 * function doubled(n) {
 *   return n * 2
 * }
 *
 * function square(n) {
 *   return n * n
 * }
 *
 * const func = overArgs((x, y) => [x, y], [square, doubled])
 *
 * func(9, 3)
 * // => [81, 6]
 *
 * func(10, 5)
 * // => [100, 10]
 */
function overArgs(func: Function, transforms: Function[]): Function {
  const funcsLength = transforms.length
  return function(...args) {
    let index = -1
    const length = Math.min(args.length, funcsLength)
    while (++index < length) {
      args[index] = transforms[index].call(this, args[index])
    }
    return func.apply(this, args)
  }
}

export default overArgs
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: overEvery.ts 1`] = `
"import every from './every.js'

/**
 * Creates a function that checks if **all** of the \`predicates\` return
 * truthy when invoked with the arguments it receives.
 *
 * @since 4.0.0
 * @category Util
 * @param {Function[]} [predicates=[identity]]
 *  The predicates to check.
 * @returns {Function} Returns the new function.
 * @example
 *
 * const func = overEvery([Boolean, isFinite])
 *
 * func('1')
 * // => true
 *
 * func(null)
 * // => false
 *
 * func(NaN)
 * // => false
 */
function overEvery(iteratees: Function[]): Function {
  return function(...args) {
    return every(iteratees, (iteratee) => iteratee.apply(this, args))
  }
}

export default overEvery
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: overSome.ts 1`] = `
"import some from './some.js'

/**
 * Creates a function that checks if **any** of the \`predicates\` return
 * truthy when invoked with the arguments it receives.
 *
 * @since 4.0.0
 * @category Util
 * @param {Function[]} [predicates=[identity]]
 *  The predicates to check.
 * @returns {Function} Returns the new function.
 * @example
 *
 * const func = overSome([Boolean, isFinite])
 *
 * func('1')
 * // => true
 *
 * func(null)
 * // => true
 *
 * func(NaN)
 * // => false
 */
function overSome(iteratees: Function[]): Function {
  return function(...args) {
    return some(iteratees, (iteratee) => iteratee.apply(this, args))
  }
}

export default overSome
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: pad.ts 1`] = `
"import createPadding from './.internal/createPadding.js'
import stringSize from './.internal/stringSize.js'

/**
 * Pads \`string\` on the left and right sides if it's shorter than \`length\`.
 * Padding characters are truncated if they can't be evenly divided by \`length\`.
 *
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * pad('abc', 8)
 * // => '  abc   '
 *
 * pad('abc', 8, '_-')
 * // => '_-abc_-_'
 *
 * pad('abc', 2)
 * // => 'abc'
 */
function pad(string: string, length: number, chars: string): string {
  const strLength = length ? stringSize(string) : 0
  if (!length || strLength >= length) {
    return string
  }
  const mid = (length - strLength) / 2
  return (
    createPadding(Math.floor(mid), chars) +
    string +
    createPadding(Math.ceil(mid), chars)
  )
}

export default pad
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: padEnd.ts 1`] = `
"import createPadding from './.internal/createPadding.js'
import stringSize from './.internal/stringSize.js'

/**
 * Pads \`string\` on the right side if it's shorter than \`length\`. Padding
 * characters are truncated if they exceed \`length\`.
 *
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * padEnd('abc', 6)
 * // => 'abc   '
 *
 * padEnd('abc', 6, '_-')
 * // => 'abc_-_'
 *
 * padEnd('abc', 2)
 * // => 'abc'
 */
function padEnd(string: string, length: number, chars: string): string {
  const strLength = length ? stringSize(string) : 0
  return (length && strLength < length)
    ? (string + createPadding(length - strLength, chars))
    : string
}

export default padEnd
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: padStart.ts 1`] = `
"import createPadding from './.internal/createPadding.js'
import stringSize from './.internal/stringSize.js'

/**
 * Pads \`string\` on the left side if it's shorter than \`length\`. Padding
 * characters are truncated if they exceed \`length\`.
 *
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * padStart('abc', 6)
 * // => '   abc'
 *
 * padStart('abc', 6, '_-')
 * // => '_-_abc'
 *
 * padStart('abc', 2)
 * // => 'abc'
 */
function padStart(string: string, length: number, chars: string): string {
  const strLength = length ? stringSize(string) : 0
  return (length && strLength < length)
    ? (createPadding(length - strLength, chars) + string)
    : string
}

export default padStart
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: parseInt.ts 1`] = `
"import root from './.internal/root.js'

/** Used to match leading and trailing whitespace. */
const reTrimStart = /^\\\\s+/

/* Built-in method references for those with the same name as other \`lodash\` methods. */
const nativeParseInt = root.parseInt

/**
 * Converts \`string\` to an integer of the specified radix. If \`radix\` is
 * \`undefined\` or \`0\`, a \`radix\` of \`10\` is used unless \`string\` is a
 * hexadecimal, in which case a \`radix\` of \`16\` is used.
 *
 * **Note:** This method aligns with the
 * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of \`parseInt\`.
 *
 * @since 1.1.0
 * @category String
 * @param {string} string The string to convert.
 * @param {number} [radix=10] The radix to interpret \`string\` by.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * parseInt('08')
 * // => 8
 */
function parseInt(string: string, radix: number): number {
  if (radix == null) {
    radix = 0
  } else if (radix) {
    radix = +radix
  }
  return nativeParseInt(\`\${string}\`.replace(reTrimStart, ''), radix || 0)
}

export default parseInt
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: partition.ts 1`] = `
"import reduce from './reduce.js'

/**
 * Creates an array of elements split into two groups, the first of which
 * contains elements \`predicate\` returns truthy for, the second of which
 * contains elements \`predicate\` returns falsey for. The predicate is
 * invoked with one argument: (value).
 *
 * @since 3.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the array of grouped elements.
 * @see groupBy, keyBy
 * @example
 *
 * const users = [
 *   { 'user': 'barney',  'age': 36, 'active': false },
 *   { 'user': 'fred',    'age': 40, 'active': true },
 *   { 'user': 'pebbles', 'age': 1,  'active': false }
 * ]
 *
 * partition(users, ({ active }) => active)
 * // => objects for [['fred'], ['barney', 'pebbles']]
 */
function partition(collection: any[] | Object, predicate: Function): any[] {
  return reduce(collection, (result, value, key) => (
    result[predicate(value) ? 0 : 1].push(value), result
  ), [[], []])
}

export default partition
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: pick.ts 1`] = `
"import basePick from './.internal/basePick.js'

/**
 * Creates an object composed of the picked \`object\` properties.
 *
 * @since 0.1.0
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * const object = { 'a': 1, 'b': '2', 'c': 3 }
 *
 * pick(object, ['a', 'c'])
 * // => { 'a': 1, 'c': 3 }
 */
function pick(object: Object, ...paths: string[] | string[][]): Object {
  return object == null ? {} : basePick(object, paths)
}

export default pick
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: pickBy.ts 1`] = `
"import map from './map.js'
import basePickBy from './.internal/basePickBy.js'
import getAllKeysIn from './.internal/getAllKeysIn.js'

/**
 * Creates an object composed of the \`object\` properties \`predicate\` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * const object = { 'a': 1, 'b': '2', 'c': 3 }
 *
 * pickBy(object, isNumber)
 * // => { 'a': 1, 'c': 3 }
 */
function pickBy(object: Object, predicate: Function): Object {
  if (object == null) {
    return {}
  }
  const props = map(getAllKeysIn(object), (prop) => [prop])
  return basePickBy(object, props, (value, path) => predicate(value, path[0]))
}

export default pickBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: property.ts 1`] = `
"import baseProperty from './.internal/baseProperty.js'
import basePropertyDeep from './.internal/basePropertyDeep.js'
import isKey from './.internal/isKey.js'
import toKey from './.internal/toKey.js'

/**
 * Creates a function that returns the value at \`path\` of a given object.
 *
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * const objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ]
 *
 * map(objects, property('a.b'))
 * // => [2, 1]
 *
 * map(sortBy(objects, property(['a', 'b'])), 'a.b')
 * // => [1, 2]
 */
function property(path: any[] | string): Function {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)
}

export default property
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: propertyOf.ts 1`] = `
"import baseGet from './.internal/baseGet.js'

/**
 * The opposite of \`property\`s method creates a function that returns
 * the value at a given path of \`object\`.
 *
 * @since 3.0.0
 * @category Util
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * const array = [0, 1, 2]
 * const object = { 'a': array, 'b': array, 'c': array }
 *
 * map(['a[2]', 'c[0]'], propertyOf(object))
 * // => [2, 0]
 *
 * map([['a', '2'], ['c', '0']], propertyOf(object))
 * // => [2, 0]
 */
function propertyOf(object: Object): Function {
  return (path) => object == null ? undefined : baseGet(object, path)
}

export default propertyOf
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: pull.ts 1`] = `
"import pullAll from './pullAll.js'

/**
 * Removes all given values from \`array\` using
 * [\`SameValueZero\`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike \`without\`, this method mutates \`array\`. Use \`remove\`
 * to remove elements from an array by predicate.
 *
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...*} [values] The values to remove.
 * @returns {Array} Returns \`array\`.
 * @see pullAll, pullAllBy, pullAllWith, pullAt, remove, reject
 * @example
 *
 * const array = ['a', 'b', 'c', 'a', 'b', 'c']
 *
 * pull(array, 'a', 'c')
 * console.log(array)
 * // => ['b', 'b']
 */
function pull(array: any[], ...values: any[]): any[] {
  return pullAll(array, values)
}

export default pull
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: pullAll.ts 1`] = `
"import basePullAll from './.internal/basePullAll.js'

/**
 * This method is like \`pull\` except that it accepts an array of values to remove.
 *
 * **Note:** Unlike \`difference\`, this method mutates \`array\`.
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @returns {Array} Returns \`array\`.
 * @see pull, pullAllBy, pullAllWith, pullAt, remove, reject
 * @example
 *
 * const array = ['a', 'b', 'c', 'a', 'b', 'c']
 *
 * pullAll(array, ['a', 'c'])
 * console.log(array)
 * // => ['b', 'b']
 */
function pullAll(array: any[], values: any[]): any[] {
  return (array != null && array.length && values != null && values.length)
    ? basePullAll(array, values)
    : array
}

export default pullAll
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: pullAllBy.ts 1`] = `
"import basePullAll from './.internal/basePullAll.js'

/**
 * This method is like \`pullAll\` except that it accepts \`iteratee\` which is
 * invoked for each element of \`array\` and \`values\` to generate the criterion
 * by which they're compared. The iteratee is invoked with one argument: (value).
 *
 * **Note:** Unlike \`differenceBy\`, this method mutates \`array\`.
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {Array} Returns \`array\`.
 * @see pull, pullAll, pullAllWith, pullAt, remove, reject
 * @example
 *
 * const array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }]
 *
 * pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x')
 * console.log(array)
 * // => [{ 'x': 2 }]
 */
function pullAllBy(array: any[], values: any[], iteratee: Function): any[] {
  return (array != null && array.length && values != null && values.length)
    ? basePullAll(array, values, iteratee)
    : array
}

export default pullAllBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: pullAllWith.ts 1`] = `
"import basePullAll from './.internal/basePullAll.js'

/**
 * This method is like \`pullAll\` except that it accepts \`comparator\` which
 * is invoked to compare elements of \`array\` to \`values\`. The comparator is
 * invoked with two arguments: (arrVal, othVal).
 *
 * **Note:** Unlike \`differenceWith\`, this method mutates \`array\`.
 *
 * @since 4.6.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns \`array\`.
 * @see pull, pullAll, pullAllBy, pullAt, remove, reject
 * @example
 *
 * const array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }]
 *
 * pullAllWith(array, [{ 'x': 3, 'y': 4 }], isEqual)
 * console.log(array)
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
 */
function pullAllWith(array: any[], values: any[], comparator: Function): any[] {
  return (array != null && array.length && values != null && values.length)
    ? basePullAll(array, values, undefined, comparator)
    : array
}

export default pullAllWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: pullAt.ts 1`] = `
"import map from './map.js'
import baseAt from './.internal/baseAt.js'
import basePullAt from './.internal/basePullAt.js'
import compareAscending from './.internal/compareAscending.js'
import isIndex from './.internal/isIndex.js'

/**
 * Removes elements from \`array\` corresponding to \`indexes\` and returns an
 * array of removed elements.
 *
 * **Note:** Unlike \`at\`, this method mutates \`array\`.
 *
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...(number|number[])} [indexes] The indexes of elements to remove.
 * @returns {Array} Returns the new array of removed elements.
 * @see pull, pullAll, pullAllBy, pullAllWith, remove, reject
 * @example
 *
 * const array = ['a', 'b', 'c', 'd']
 * const pulled = pullAt(array, [1, 3])
 *
 * console.log(array)
 * // => ['a', 'c']
 *
 * console.log(pulled)
 * // => ['b', 'd']
 */
function pullAt(array: any[], ...indexes: number[] | number[][]): any[] {
  const length = array == null ? 0 : array.length
  const result = baseAt(array, indexes)

  basePullAt(array, map(indexes, (index) => isIndex(index, length) ? +index : index).sort(compareAscending))
  return result
}

export default pullAt
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: random.ts 1`] = `
"import toFinite from './toFinite.js'

/** Built-in method references without a dependency on \`root\`. */
const freeParseFloat = parseFloat

/**
 * Produces a random number between the inclusive \`lower\` and \`upper\` bounds.
 * If only one argument is provided a number between \`0\` and the given number
 * is returned. If \`floating\` is \`true\`, or either \`lower\` or \`upper\` are
 * floats, a floating-point number is returned instead of an integer.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @since 0.7.0
 * @category Number
 * @param {number} [lower=0] The lower bound.
 * @param {number} [upper=1] The upper bound.
 * @param {boolean} [floating] Specify returning a floating-point number.
 * @returns {number} Returns the random number.
 * @see uniqueId
 * @example
 *
 * random(0, 5)
 * // => an integer between 0 and 5
 *
 * random(5)
 * // => also an integer between 0 and 5
 *
 * random(5, true)
 * // => a floating-point number between 0 and 5
 *
 * random(1.2, 5.2)
 * // => a floating-point number between 1.2 and 5.2
 */
function random(lower: number, upper: number, floating: boolean): number {
  if (floating === undefined) {
    if (typeof upper == 'boolean') {
      floating = upper
      upper = undefined
    }
    else if (typeof lower == 'boolean') {
      floating = lower
      lower = undefined
    }
  }
  if (lower === undefined && upper === undefined) {
    lower = 0
    upper = 1
  }
  else {
    lower = toFinite(lower)
    if (upper === undefined) {
      upper = lower
      lower = 0
    } else {
      upper = toFinite(upper)
    }
  }
  if (lower > upper) {
    const temp = lower
    lower = upper
    upper = temp
  }
  if (floating || lower % 1 || upper % 1) {
    const rand = Math.random()
    const randLength = \`\${rand}\`.length - 1
    return Math.min(lower + (rand * (upper - lower + freeParseFloat(\`1e-\${randLength}\`)), upper))
  }
  return lower + Math.floor(Math.random() * (upper - lower + 1))
}

export default random
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: range.ts 1`] = `
"import createRange from './.internal/createRange.js'

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * \`start\` up to, but not including, \`end\`. A step of \`-1\` is used if a negative
 * \`start\` is specified without an \`end\` or \`step\`. If \`end\` is not specified,
 * it's set to \`start\`, and \`start\` is then set to \`0\`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @since 0.1.0
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see inRange, rangeRight
 * @example
 *
 * range(4)
 * // => [0, 1, 2, 3]
 *
 * range(-4)
 * // => [0, -1, -2, -3]
 *
 * range(1, 5)
 * // => [1, 2, 3, 4]
 *
 * range(0, 20, 5)
 * // => [0, 5, 10, 15]
 *
 * range(0, -4, -1)
 * // => [0, -1, -2, -3]
 *
 * range(1, 4, 0)
 * // => [1, 1, 1]
 *
 * range(0)
 * // => []
 */
const range = createRange()

export default range
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: rangeRight.ts 1`] = `
"import createRange from './.internal/createRange.js'

/**
 * This method is like \`range\` except that it populates values in
 * descending order.
 *
 * @since 4.0.0
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see inRange, range
 * @example
 *
 * rangeRight(4)
 * // => [3, 2, 1, 0]
 *
 * rangeRight(-4)
 * // => [-3, -2, -1, 0]
 *
 * rangeRight(1, 5)
 * // => [4, 3, 2, 1]
 *
 * rangeRight(0, 20, 5)
 * // => [15, 10, 5, 0]
 *
 * rangeRight(0, -4, -1)
 * // => [-3, -2, -1, 0]
 *
 * rangeRight(1, 4, 0)
 * // => [1, 1, 1]
 *
 * rangeRight(0)
 * // => []
 */
const rangeRight = createRange(true)

export default rangeRight
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: reduce.ts 1`] = `
"import arrayReduce from './.internal/arrayReduce.js'
import baseEach from './.internal/baseEach.js'
import baseReduce from './.internal/baseReduce.js'

/**
 * Reduces \`collection\` to a value which is the accumulated result of running
 * each element in \`collection\` thru \`iteratee\`, where each successive
 * invocation is supplied the return value of the previous. If \`accumulator\`
 * is not given, the first element of \`collection\` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * \`reduce\`, \`reduceRight\`, and \`transform\`.
 *
 * The guarded methods are:
 * \`assign\`, \`defaults\`, \`defaultsDeep\`, \`includes\`, \`merge\`, \`orderBy\`,
 * and \`sortBy\`
 *
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see reduceRight, transform
 * @example
 *
 * reduce([1, 2], (sum, n) => sum + n, 0)
 * // => 3
 *
 * reduce({ 'a': 1, 'b': 2, 'c': 1 }, (result, value, key) => {
 *   (result[value] || (result[value] = [])).push(key)
 *   return result
 * }, {})
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection: any[] | Object, iteratee: Function, accumulator: any): any {
  const func = Array.isArray(collection) ? arrayReduce : baseReduce
  const initAccum = arguments.length < 3
  return func(collection, iteratee, accumulator, initAccum, baseEach)
}

export default reduce
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: reduceRight.ts 1`] = `
"import arrayReduceRight from './.internal/arrayReduceRight.js'
import baseEachRight from './.internal/baseEachRight.js'
import baseReduce from './.internal/baseReduce.js'

/**
 * This method is like \`reduce\` except that it iterates over elements of
 * \`collection\` from right to left.
 *
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see reduce
 * @example
 *
 * const array = [[0, 1], [2, 3], [4, 5]]
 *
 * reduceRight(array, (flattened, other) => flattened.concat(other), [])
 * // => [4, 5, 2, 3, 0, 1]
 */
function reduceRight(collection: any[] | Object, iteratee: Function, accumulator: any): any {
  const func = Array.isArray(collection) ? arrayReduceRight : baseReduce
  const initAccum = arguments.length < 3
  return func(collection, iteratee, accumulator, initAccum, baseEachRight)
}

export default reduceRight
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: reject.ts 1`] = `
"import filter from './filter.js'
import filterObject from './filterObject.js'
import negate from './negate.js'

/**
 * The opposite of \`filter\` this method returns the elements of \`collection\`
 * that \`predicate\` does **not** return truthy for.
 *
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see pull, pullAll, pullAllBy, pullAllWith, pullAt, remove, filter
 * @example
 *
 * const users = [
 *   { 'user': 'barney', 'active': true },
 *   { 'user': 'fred',   'active': false }
 * ]
 *
 * reject(users, ({ active }) => active)
 * // => objects for ['fred']
 */
function reject(collection: any[] | Object, predicate: Function): any[] {
  const func = Array.isArray(collection) ? filter : filterObject
  return func(collection, negate(predicate))
}

export default reject
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: remove.ts 1`] = `
"import basePullAt from './.internal/basePullAt.js'

/**
 * Removes all elements from \`array\` that \`predicate\` returns truthy for
 * and returns an array of the removed elements. The predicate is invoked
 * with three arguments: (value, index, array).
 *
 * **Note:** Unlike \`filter\`, this method mutates \`array\`. Use \`pull\`
 * to pull elements from an array by value.
 *
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new array of removed elements.
 * @see pull, pullAll, pullAllBy, pullAllWith, pullAt, reject, filter
 * @example
 *
 * const array = [1, 2, 3, 4]
 * const evens = remove(array, n => n % 2 == 0)
 *
 * console.log(array)
 * // => [1, 3]
 *
 * console.log(evens)
 * // => [2, 4]
 */
function remove(array: any[], predicate: Function): any[] {
  const result = []
  if (!(array != null && array.length)) {
    return result
  }
  let index = -1
  const indexes = []
  const { length } = array

  while (++index < length) {
    const value = array[index]
    if (predicate(value, index, array)) {
      result.push(value)
      indexes.push(index)
    }
  }
  basePullAt(array, indexes)
  return result
}

export default remove
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: repeat.ts 1`] = `
"/**
 * Repeats the given string \`n\` times.
 *
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to repeat.
 * @param {number} [n=1] The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 * @example
 *
 * repeat('*', 3)
 * // => '***'
 *
 * repeat('abc', 2)
 * // => 'abcabc'
 *
 * repeat('abc', 0)
 * // => ''
 */
function repeat(string: string, n: number): string {
  let result = ''
  if (!string || n < 1 || n > Number.MAX_SAFE_INTEGER) {
    return result
  }
  // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do {
    if (n % 2) {
      result += string
    }
    n = Math.floor(n / 2)
    if (n) {
      string += string
    }
  } while (n)

  return result
}

export default repeat
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: replace.ts 1`] = `
"/**
 * Replaces matches for \`pattern\` in \`string\` with \`replacement\`.
 *
 * **Note:** This method is based on
 * [\`String#replace\`](https://mdn.io/String/replace).
 *
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to modify.
 * @param {RegExp|string} pattern The pattern to replace.
 * @param {Function|string} replacement The match replacement.
 * @returns {string} Returns the modified string.
 * @see truncate, trim
 * @example
 *
 * replace('Hi Fred', 'Fred', 'Barney')
 * // => 'Hi Barney'
 */
function replace(...args: string): string {
  const string = \`\${args[0]}\`
  return args.length < 3 ? string : string.replace(args[1], args[2])
}

export default replace
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: result.ts 1`] = `
"import castPath from './.internal/castPath.js'
import toKey from './.internal/toKey.js'

/**
 * This method is like \`get\` except that if the resolved value is a
 * function it's invoked with the \`this\` binding of its parent object and
 * its result is returned.
 *
 * @since 0.1.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to resolve.
 * @param {*} [defaultValue] The value returned for \`undefined\` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * const object = { 'a': [{ 'b': { 'c1': 3, 'c2': () => 4 } }] }
 *
 * result(object, 'a[0].b.c1')
 * // => 3
 *
 * result(object, 'a[0].b.c2')
 * // => 4
 *
 * result(object, 'a[0].b.c3', 'default')
 * // => 'default'
 *
 * result(object, 'a[0].b.c3', () => 'default')
 * // => 'default'
 */
function result(object: Object, path: any[] | string, defaultValue: any): any {
  path = castPath(path, object)

  let index = -1
  let length = path.length

  // Ensure the loop is entered when path is empty.
  if (!length) {
    length = 1
    object = undefined
  }
  while (++index < length) {
    let value = object == null ? undefined : object[toKey(path[index])]
    if (value === undefined) {
      index = length
      value = defaultValue
    }
    object = typeof value == 'function' ? value.call(object) : value
  }
  return object
}

export default result
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: round.ts 1`] = `
"import createRound from './.internal/createRound.js'

/**
 * Computes \`number\` rounded to \`precision\`.
 *
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round.
 * @param {number} [precision=0] The precision to round to.
 * @returns {number} Returns the rounded number.
 * @example
 *
 * round(4.006)
 * // => 4
 *
 * round(4.006, 2)
 * // => 4.01
 *
 * round(4060, -2)
 * // => 4100
 */
const round = createRound('round')

export default round
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: sample.ts 1`] = `
"/**
 * Gets a random element from \`array\`.
 *
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to sample.
 * @returns {*} Returns the random element.
 * @example
 *
 * sample([1, 2, 3, 4])
 * // => 2
 */
function sample(array: any[]): any {
  const length = array == null ? 0 : array.length
  return length ? array[Math.floor(Math.random() * length)] : undefined
}

export default sample
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: sampleSize.ts 1`] = `
"import copyArray from './.internal/copyArray.js'
import slice from './slice.js'

/**
 * Gets \`n\` random elements at unique keys from \`array\` up to the
 * size of \`array\`.
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to sample.
 * @param {number} [n=1] The number of elements to sample.
 * @returns {Array} Returns the random elements.
 * @example
 *
 * sampleSize([1, 2, 3], 2)
 * // => [3, 1]
 *
 * sampleSize([1, 2, 3], 4)
 * // => [2, 3, 1]
 */
function sampleSize(array: any[], n: number): any[] {
  n = n == null ? 1 : n
  const length = array == null ? 0 : array.length
  if (!length || n < 1) {
    return []
  }
  n = n > length ? length : n
  let index = -1
  const lastIndex = length - 1
  const result = copyArray(array)
  while (++index < n) {
    const rand = index + Math.floor(Math.random() * (lastIndex - index + 1))
    const value = result[rand]
    result[rand] = result[index]
    result[index] = value
  }
  return slice(result, 0, n)
}

export default sampleSize
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: set.ts 1`] = `
"import baseSet from './.internal/baseSet.js'

/**
 * Sets the value at \`path\` of \`object\`. If a portion of \`path\` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use \`setWith\` to customize
 * \`path\` creation.
 *
 * **Note:** This method mutates \`object\`.
 *
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns \`object\`.
 * @see has, hasIn, get, unset
 * @example
 *
 * const object = { 'a': [{ 'b': { 'c': 3 } }] }
 *
 * set(object, 'a[0].b.c', 4)
 * console.log(object.a[0].b.c)
 * // => 4
 *
 * set(object, ['x', '0', 'y', 'z'], 5)
 * console.log(object.x[0].y.z)
 * // => 5
 */
function set(object: Object, path: any[] | string, value: any): Object {
  return object == null ? object : baseSet(object, path, value)
}

export default set
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: setWith.ts 1`] = `
"import baseSet from './.internal/baseSet.js'

/**
 * This method is like \`set\` except that it accepts \`customizer\` which is
 * invoked to produce the objects of \`path\`. If \`customizer\` returns \`undefined\`
 * path creation is handled by the method instead. The \`customizer\` is invoked
 * with three arguments: (nsValue, key, nsObject).
 *
 * **Note:** This method mutates \`object\`.
 *
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns \`object\`.
 * @example
 *
 * const object = {}
 *
 * setWith(object, '[0][1]', 'a', Object)
 * // => { '0': { '1': 'a' } }
 */
function setWith(object: Object, path: any[] | string, value: any, customizer: Function): Object {
  customizer = typeof customizer == 'function' ? customizer : undefined
  return object == null ? object : baseSet(object, path, value, customizer)
}

export default setWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: shuffle.ts 1`] = `
"import copyArray from './.internal/copyArray.js'

/**
 * Creates an array of shuffled values, using a version of the
 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
 *
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to shuffle.
 * @returns {Array} Returns the new shuffled array.
 * @example
 *
 * shuffle([1, 2, 3, 4])
 * // => [4, 1, 3, 2]
 */
function shuffle(array: any[]): any[] {
  const length = array == null ? 0 : array.length
  if (!length) {
    return []
  }
  let index = -1
  const lastIndex = length - 1
  const result = copyArray(array)
  while (++index < length) {
    const rand = index + Math.floor(Math.random() * (lastIndex - index + 1))
    const value = result[rand]
    result[rand] = result[index]
    result[index] = value
  }
  return result
}

export default shuffle
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: size.ts 1`] = `
"import getTag from './.internal/getTag.js'
import isArrayLike from './isArrayLike.js'
import isString from './isString.js'
import stringSize from './.internal/stringSize.js'

/** \`Object#toString\` result references. */
const mapTag = '[object Map]'
const setTag = '[object Set]'

/**
 * Gets the size of \`collection\` by returning its length for array-like
 * values or the number of own enumerable string keyed properties for objects.
 *
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @returns {number} Returns the collection size.
 * @example
 *
 * size([1, 2, 3])
 * // => 3
 *
 * size({ 'a': 1, 'b': 2 })
 * // => 2
 *
 * size('pebbles')
 * // => 7
 */
function size(collection: any[] | Object | string): number {
  if (collection == null) {
    return 0
  }
  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length
  }
  const tag = getTag(collection)
  if (tag == mapTag || tag == setTag) {
    return collection.size
  }
  return Object.keys(collection).length
}

export default size
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: slice.ts 1`] = `
"/**
 * Creates a slice of \`array\` from \`start\` up to, but not including, \`end\`.
 *
 * **Note:** This method is used instead of
 * [\`Array#slice\`](https://mdn.io/Array/slice) to ensure dense arrays are
 * returned.
 *
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position. A negative index will be treated as an offset from the end.
 * @param {number} [end=array.length] The end position. A negative index will be treated as an offset from the end.
 * @returns {Array} Returns the slice of \`array\`.
 * @example
 *
 * var array = [1, 2, 3, 4]
 *
 * _.slice(array, 2)
 * // => [3, 4]
 */
function slice(array: any[], start: number, end: number): any[] {
  let length = array == null ? 0 : array.length
  if (!length) {
    return []
  }
  start = start == null ? 0 : start
  end = end === undefined ? length : end

  if (start < 0) {
    start = -start > length ? 0 : (length + start)
  }
  end = end > length ? length : end
  if (end < 0) {
    end += length
  }
  length = start > end ? 0 : ((end - start) >>> 0)
  start >>>= 0

  let index = -1
  const result = new Array(length)
  while (++index < length) {
    result[index] = array[index + start]
  }
  return result
}

export default slice
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: snakeCase.ts 1`] = `
"import words from './words.js'

/**
 * Converts \`string\` to
 * [snake case](https://en.wikipedia.org/wiki/Snake_case).
 *
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the snake cased string.
 * @see camelCase, lowerCase, kebabCase, startCase, upperCase, upperFirst
 * @example
 *
 * snakeCase('Foo Bar')
 * // => 'foo_bar'
 *
 * snakeCase('fooBar')
 * // => 'foo_bar'
 *
 * snakeCase('--FOO-BAR--')
 * // => 'foo_bar'
 *
 * snakeCase('foo2bar')
 * // => 'foo_2_bar'
 */
const snakeCase = (string) => (
  words(\`\${string}\`.replace(/['\\\\u2019]/g, '')).reduce((result, word, index) => (
    result + (index ? '_' : '') + word.toLowerCase()
  ), '')
)

export default snakeCase
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: some.ts 1`] = `
"/**
 * Checks if \`predicate\` returns truthy for **any** element of \`array\`.
 * Iteration is stopped once \`predicate\` returns truthy. The predicate is
 * invoked with three arguments: (value, index, array).
 *
 * @since 5.0.0
 * @category Array
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns \`true\` if any element passes the predicate check,
 *  else \`false\`.
 * @example
 *
 * some([null, 0, 'yes', false], Boolean)
 * // => true
 */
function some(array: any[], predicate: Function): boolean {
  let index = -1
  const length = array == null ? 0 : array.length

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true
    }
  }
  return false
}

export default some
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: someValue.ts 1`] = `
"/**
 * Checks if \`predicate\` returns truthy for **any** element of \`object\`.
 * Iteration is stopped once \`predicate\` returns truthy. The predicate is
 * invoked with three arguments: (value, key, object).
 *
 * @since 5.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns \`true\` if any element passes the predicate check,
 *  else \`false\`.
 * @example
 *
 * someValues({ 'a': 0, 'b': 'yes', 'c': false }, Boolean)
 * // => true
 */
function someValues(object: Object, predicate: Function): boolean {
  object = Object(object)
  const props = Object.keys(object)

  for (const key of props) {
    if (predicate(object[key], key, object)) {
      return true
    }
  }
  return false
}

export default someValues
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: sortedIndex.ts 1`] = `
"import baseSortedIndex from './.internal/baseSortedIndex.js'

/**
 * Uses a binary search to determine the lowest index at which \`value\`
 * should be inserted into \`array\` in order to maintain its sort order.
 *
 * @since 0.1.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which \`value\` should be inserted
 *  into \`array\`.
 * @example
 *
 * sortedIndex([30, 50], 40)
 * // => 1
 */
function sortedIndex(array: any[], value: any): number {
  return baseSortedIndex(array, value)
}

export default sortedIndex
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: sortedIndexBy.ts 1`] = `
"import baseSortedIndexBy from './.internal/baseSortedIndexBy.js'

/**
 * This method is like \`sortedIndex\` except that it accepts \`iteratee\`
 * which is invoked for \`value\` and each element of \`array\` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {number} Returns the index at which \`value\` should be inserted
 *  into \`array\`.
 * @example
 *
 * const objects = [{ 'n': 4 }, { 'n': 5 }]
 *
 * sortedIndexBy(objects, { 'n': 4 }, ({ n }) => n)
 * // => 0
 */
function sortedIndexBy(array: any[], value: any, iteratee: Function): number {
  return baseSortedIndexBy(array, value, iteratee)
}

export default sortedIndexBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: sortedIndexOf.ts 1`] = `
"import baseSortedIndex from './.internal/baseSortedIndex.js'
import eq from './eq.js'

/**
 * This method is like \`indexOf\` except that it performs a binary
 * search on a sorted \`array\`.
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 * @example
 *
 * sortedIndexOf([4, 5, 5, 5, 6], 5)
 * // => 1
 */
function sortedIndexOf(array: any[], value: any): number {
  const length = array == null ? 0 : array.length
  if (length) {
    const index = baseSortedIndex(array, value)
    if (index < length && eq(array[index], value)) {
      return index
    }
  }
  return -1
}

export default sortedIndexOf
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: sortedLastIndex.ts 1`] = `
"import baseSortedIndex from './.internal/baseSortedIndex.js'

/**
 * This method is like \`sortedIndex\` except that it returns the highest
 * index at which \`value\` should be inserted into \`array\` in order to
 * maintain its sort order.
 *
 * @since 3.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which \`value\` should be inserted
 *  into \`array\`.
 * @example
 *
 * sortedLastIndex([4, 5, 5, 5, 6], 5)
 * // => 4
 */
function sortedLastIndex(array: any[], value: any): number {
  return baseSortedIndex(array, value, true)
}

export default sortedLastIndex
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: sortedLastIndexBy.ts 1`] = `
"import baseSortedIndexBy from './.internal/baseSortedIndexBy.js'

/**
 * This method is like \`sortedLastIndex\` except that it accepts \`iteratee\`
 * which is invoked for \`value\` and each element of \`array\` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {number} Returns the index at which \`value\` should be inserted
 *  into \`array\`.
 * @example
 *
 * const objects = [{ 'n': 4 }, { 'n': 5 }]
 *
 * sortedLastIndexBy(objects, { 'n': 4 }, ({ n }) => n)
 * // => 1
 */
function sortedLastIndexBy(array: any[], value: any, iteratee: Function): number {
  return baseSortedIndexBy(array, value, iteratee, true)
}

export default sortedLastIndexBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: sortedLastIndexOf.ts 1`] = `
"import baseSortedIndex from './.internal/baseSortedIndex.js'
import eq from './eq.js'

/**
 * This method is like \`lastIndexOf\` except that it performs a binary
 * search on a sorted \`array\`.
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 * @example
 *
 * sortedLastIndexOf([4, 5, 5, 5, 6], 5)
 * // => 3
 */
function sortedLastIndexOf(array: any[], value: any): number {
  const length = array == null ? 0 : array.length
  if (length) {
    const index = baseSortedIndex(array, value, true) - 1
    if (eq(array[index], value)) {
      return index
    }
  }
  return -1
}

export default sortedLastIndexOf
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: sortedUniq.ts 1`] = `
"import baseSortedUniq from './.internal/baseSortedUniq.js'

/**
 * This method is like \`uniq\` except that it only works
 * for sorted arrays.
 * If the input array is known to be sorted \`sortedUniq\` is
 * faster than \`uniq\`.
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * sortedUniq([1, 1, 2])
 * // => [1, 2]
 */
function sortedUniq(array: any[]): any[] {
  return (array != null && array.length)
    ? baseSortedUniq(array)
    : []
}

export default sortedUniq
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: sortedUniqBy.ts 1`] = `
"import baseSortedUniq from './.internal/baseSortedUniq.js'

/**
 * This method is like \`uniqBy\` except that it's designed and optimized
 * for sorted arrays.
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor)
 * // => [1.1, 2.3]
 */
function sortedUniqBy(array: any[], iteratee: Function): any[] {
  return (array != null && array.length)
    ? baseSortedUniq(array, iteratee)
    : []
}

export default sortedUniqBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: split.ts 1`] = `
"import castSlice from './.internal/castSlice.js'
import hasUnicode from './.internal/hasUnicode.js'
import isRegExp from './isRegExp.js'
import stringToArray from './.internal/stringToArray.js'

/** Used as references for the maximum length and index of an array. */
const MAX_ARRAY_LENGTH = 4294967295

/**
 * Splits \`string\` by \`separator\`.
 *
 * **Note:** This method is based on
 * [\`String#split\`](https://mdn.io/String/split).
 *
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to split.
 * @param {RegExp|string} separator The separator pattern to split by.
 * @param {number} [limit] The length to truncate results to.
 * @returns {Array} Returns the string segments.
 * @example
 *
 * split('a-b-c', '-', 2)
 * // => ['a', 'b']
 */
function split(string: string, separator: RegExp | string, limit: number): any[] {
  limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0
  if (!limit) {
    return []
  }
  if (string && (
        typeof separator == 'string' ||
        (separator != null && !isRegExp(separator))
      )) {
    if (!separator && hasUnicode(string)) {
      return castSlice(stringToArray(string), 0, limit)
    }
  }
  return string.split(separator, limit)
}

export default split
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: startCase.ts 1`] = `
"import upperFirst from './upperFirst.js'
import words from './words.js'

/**
 * Converts \`string\` to
 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
 *
 * @since 3.1.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the start cased string.
 * @see camelCase, lowerCase, kebabCase, snakeCase, upperCase, upperFirst
 * @example
 *
 * startCase('--foo-bar--')
 * // => 'Foo Bar'
 *
 * startCase('fooBar')
 * // => 'Foo Bar'
 *
 * startCase('__FOO_BAR__')
 * // => 'FOO BAR'
 */
const startCase = (string) => (
  words(\`\${string}\`.replace(/['\\\\u2019]/g, '')).reduce((result, word, index) => (
    result + (index ? ' ' : '') + upperFirst(word)
  ), '')
)

export default startCase
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: startsWith.ts 1`] = `
"/**
 * Checks if \`string\` starts with the given target string.
 *
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns \`true\` if \`string\` starts with \`target\`,
 *  else \`false\`.
 * @see endsWith, includes
 * @example
 *
 * startsWith('abc', 'a')
 * // => true
 *
 * startsWith('abc', 'b')
 * // => false
 *
 * startsWith('abc', 'b', 1)
 * // => true
 */
function startsWith(string: string, target: string, position: number): boolean {
  const { length } = string
  position = position == null ? 0 : position
  if (position < 0) {
    position = 0
  }
  else if (position > length) {
    position = length
  }
  target = \`\${target}\`
  return string.slice(position, position + target.length) == target
}

export default startsWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: subtract.ts 1`] = `
"import createMathOperation from './.internal/createMathOperation.js'

/**
 * Subtract two numbers.
 *
 * @since 4.0.0
 * @category Math
 * @param {number} minuend The first number in a subtraction.
 * @param {number} subtrahend The second number in a subtraction.
 * @returns {number} Returns the difference.
 * @example
 *
 * subtract(6, 4)
 * // => 2
 */
const subtract = createMathOperation((minuend: number, subtrahend: number): number => minuend - subtrahend, 0)

export default subtract
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: sum.ts 1`] = `
"import baseSum from './.internal/baseSum.js'

/**
 * Computes the sum of the values in \`array\`.
 *
 * @since 3.4.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * sum([4, 2, 8, 6])
 * // => 20
 */
function sum(array: any[]): number {
  return (array != null && array.length)
    ? baseSum(array, (value) => value)
    : 0
}

export default sum
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: sumBy.ts 1`] = `
"import baseSum from './.internal/baseSum.js'

/**
 * This method is like \`sum\` except that it accepts \`iteratee\` which is
 * invoked for each element in \`array\` to generate the value to be summed.
 * The iteratee is invoked with one argument: (value).
 *
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {number} Returns the sum.
 * @example
 *
 * const objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }]
 *
 * sumBy(objects, ({ n }) => n)
 * // => 20
 */
function sumBy(array: any[], iteratee: Function): number {
  return (array != null && array.length)
    ? baseSum(array, iteratee)
    : 0
}

export default sumBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: tail.ts 1`] = `
"/**
 * Gets all but the first element of \`array\`.
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of \`array\`.
 * @example
 *
 * tail([1, 2, 3])
 * // => [2, 3]
 */
function tail(array: any[]): any[] {
  const length = array == null ? 0 : array.length
  if (!length) {
    return []
  }
  const [, ...result] = array
  return result
}

export default tail
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: take.ts 1`] = `
"import slice from './slice.js'

/**
 * Creates a slice of \`array\` with \`n\` elements taken from the beginning.
 *
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @returns {Array} Returns the slice of \`array\`.
 * @example
 *
 * take([1, 2, 3])
 * // => [1]
 *
 * take([1, 2, 3], 2)
 * // => [1, 2]
 *
 * take([1, 2, 3], 5)
 * // => [1, 2, 3]
 *
 * take([1, 2, 3], 0)
 * // => []
 */
function take(array: any[], n = 1): any[] {
  if (!(array != null && array.length)) {
    return []
  }
  return slice(array, 0, n < 0 ? 0 : n)
}

export default take
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: takeRight.ts 1`] = `
"import slice from './slice.js'

/**
 * Creates a slice of \`array\` with \`n\` elements taken from the end.
 *
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @returns {Array} Returns the slice of \`array\`.
 * @example
 *
 * takeRight([1, 2, 3])
 * // => [3]
 *
 * takeRight([1, 2, 3], 2)
 * // => [2, 3]
 *
 * takeRight([1, 2, 3], 5)
 * // => [1, 2, 3]
 *
 * takeRight([1, 2, 3], 0)
 * // => []
 */
function takeRight(array: any[], n = 1): any[] {
  const length = array == null ? 0 : array.length
  if (!length) {
    return []
  }
  n = length - n
  return slice(array, n < 0 ? 0 : n, length)
}

export default takeRight
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: takeRightWhile.ts 1`] = `
"import baseWhile from './.internal/baseWhile.js'

/**
 * Creates a slice of \`array\` with elements taken from the end. Elements are
 * taken until \`predicate\` returns falsey. The predicate is invoked with
 * three arguments: (value, index, array).
 *
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the slice of \`array\`.
 * @example
 *
 * const users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': true },
 *   { 'user': 'pebbles', 'active': true }
 * ]
 *
 * takeRightWhile(users, ({ active }) => active)
 * // => objects for ['fred', 'pebbles']
 */
function takeRightWhile(array: any[], predicate: Function): any[] {
  return (array != null && array.length)
    ? baseWhile(array, predicate, false, true)
    : []
}

export default takeRightWhile
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: takeWhile.ts 1`] = `
"import baseWhile from './.internal/baseWhile.js'

/**
 * Creates a slice of \`array\` with elements taken from the beginning. Elements
 * are taken until \`predicate\` returns falsey. The predicate is invoked with
 * three arguments: (value, index, array).
 *
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the slice of \`array\`.
 * @example
 *
 * const users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': true },
 *   { 'user': 'pebbles', 'active': false }
 * ]
 *
 * takeWhile(users, ({ active }) => active)
 * // => objects for ['barney', 'fred']
 */
function takeWhile(array: any[], predicate: Function): any[] {
  return (array != null && array.length)
    ? baseWhile(array, predicate)
    : []
}

export default takeWhile
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: throttle.ts 1`] = `
"import debounce from './debounce.js'
import isObject from './isObject.js'

/**
 * Creates a throttled function that only invokes \`func\` at most once per
 * every \`wait\` milliseconds (or once per browser frame). The throttled function
 * comes with a \`cancel\` method to cancel delayed \`func\` invocations and a
 * \`flush\` method to immediately invoke them. Provide \`options\` to indicate
 * whether \`func\` should be invoked on the leading and/or trailing edge of the
 * \`wait\` timeout. The \`func\` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last \`func\` invocation.
 *
 * **Note:** If \`leading\` and \`trailing\` options are \`true\`, \`func\` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the \`wait\` timeout.
 *
 * If \`wait\` is \`0\` and \`leading\` is \`false\`, \`func\` invocation is deferred
 * until the next tick, similar to \`setTimeout\` with a timeout of \`0\`.
 *
 * If \`wait\` is omitted in an environment with \`requestAnimationFrame\`, \`func\`
 * invocation will be deferred until the next frame is drawn (typically about
 * 16ms).
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between \`throttle\` and \`debounce\`.
 *
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0]
 *  The number of milliseconds to throttle invocations to; if omitted,
 *  \`requestAnimationFrame\` is used (if available).
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', throttle(updatePosition, 100))
 *
 * // Invoke \`renewToken\` when the click event is fired, but not more than once every 5 minutes.
 * const throttled = throttle(renewToken, 300000, { 'trailing': false })
 * jQuery(element).on('click', throttled)
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel)
 */
function throttle(func: Function, wait: number, options: Object): Function {
  let leading = true
  let trailing = true

  if (typeof func !== 'function') {
    throw new TypeError('Expected a function')
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading
    trailing = 'trailing' in options ? !!options.trailing : trailing
  }
  return debounce(func, wait, {
    leading,
    trailing,
    'maxWait': wait,
  })
}

export default throttle
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: times.ts 1`] = `
"/** Used as references for various \`Number\` constants. */
const MAX_SAFE_INTEGER = 9007199254740991

/** Used as references for the maximum length and index of an array. */
const MAX_ARRAY_LENGTH = 4294967295

/**
 * Invokes the iteratee \`n\` times, returning an array of the results of
 * each invocation. The iteratee is invoked with one argument: (index).
 *
 * @since 0.1.0
 * @category Util
 * @param {number} n The number of times to invoke \`iteratee\`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 * @example
 *
 * times(3, String)
 * // => ['0', '1', '2']
 *
 *  times(4, () => 0)
 * // => [0, 0, 0, 0]
 */
function times(n: number, iteratee: Function): any[] {
  if (n < 1 || n > MAX_SAFE_INTEGER) {
    return []
  }
  let index = -1
  const length = Math.min(n, MAX_ARRAY_LENGTH)
  const result = new Array(length)
  while (++index < length) {
    result[index] = iteratee(index)
  }
  index = MAX_ARRAY_LENGTH
  n -= MAX_ARRAY_LENGTH
  while (++index < n) {
    iteratee(index)
  }
  return result
}

export default times
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: toArray.ts 1`] = `
"import copyArray from './.internal/copyArray.js'
import getTag from './.internal/getTag.js'
import isArrayLike from './isArrayLike.js'
import isString from './isString.js'
import iteratorToArray from './.internal/iteratorToArray.js'
import mapToArray from './.internal/mapToArray.js'
import setToArray from './.internal/setToArray.js'
import stringToArray from './.internal/stringToArray.js'
import values from './values.js'

/** \`Object#toString\` result references. */
const mapTag = '[object Map]'
const setTag = '[object Set]'

/** Built-in value references. */
const symIterator = Symbol.iterator

/**
 * Converts \`value\` to an array.
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Array} Returns the converted array.
 * @example
 *
 * toArray({ 'a': 1, 'b': 2 })
 * // => [1, 2]
 *
 * toArray('abc')
 * // => ['a', 'b', 'c']
 *
 * toArray(1)
 * // => []
 *
 * toArray(null)
 * // => []
 */
function toArray(value: any): any[] {
  if (!value) {
    return []
  }
  if (isArrayLike(value)) {
    return isString(value) ? stringToArray(value) : copyArray(value)
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray(value[symIterator]())
  }
  const tag = getTag(value)
  const func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values)

  return func(value)
}

export default toArray
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: toFinite.ts 1`] = `
"import toNumber from './toNumber.js'

/** Used as references for various \`Number\` constants. */
const INFINITY = 1 / 0
const MAX_INTEGER = 1.7976931348623157e+308

/**
 * Converts \`value\` to a finite number.
 *
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * toFinite(3.2)
 * // => 3.2
 *
 * toFinite(Number.MIN_VALUE)
 * // => 5e-324
 *
 * toFinite(Infinity)
 * // => 1.7976931348623157e+308
 *
 * toFinite('3.2')
 * // => 3.2
 */
function toFinite(value: any): number {
  if (!value) {
    return value === 0 ? value : 0
  }
  value = toNumber(value)
  if (value === INFINITY || value === -INFINITY) {
    const sign = (value < 0 ? -1 : 1)
    return sign * MAX_INTEGER
  }
  return value === value ? value : 0
}

export default toFinite
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: toInteger.ts 1`] = `
"import toFinite from './toFinite.js'

/**
 * Converts \`value\` to an integer.
 *
 * **Note:** This method is loosely based on
 * [\`ToInteger\`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @see isInteger, isNumber, toNumber
 * @example
 *
 * toInteger(3.2)
 * // => 3
 *
 * toInteger(Number.MIN_VALUE)
 * // => 0
 *
 * toInteger(Infinity)
 * // => 1.7976931348623157e+308
 *
 * toInteger('3.2')
 * // => 3
 */
function toInteger(value: any): number {
  const result = toFinite(value)
  const remainder = result % 1

  return remainder ? result - remainder : result
}

export default toInteger
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: toLength.ts 1`] = `
"import toInteger from './toInteger.js'

/** Used as references for the maximum length and index of an array. */
const MAX_ARRAY_LENGTH = 4294967295

/**
 * Converts \`value\` to an integer suitable for use as the length of an
 * array-like object.
 *
 * **Note:** This method is based on
 * [\`ToLength\`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * toLength(3.2)
 * // => 3
 *
 * toLength(Number.MIN_VALUE)
 * // => 0
 *
 * toLength(Infinity)
 * // => 4294967295
 *
 * toLength('3.2')
 * // => 3
 */
function toLength(value: any): number {
  if (!value) {
    return 0
  }
  value = toInteger(value)
  if (value < 0) {
    return 0
  }
  if (value > MAX_ARRAY_LENGTH) {
    return MAX_ARRAY_LENGTH
  }
  return value
}

export default toLength
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: toNumber.ts 1`] = `
"import isObject from './isObject.js'
import isSymbol from './isSymbol.js'

/** Used as references for various \`Number\` constants. */
const NAN = 0 / 0

/** Used to match leading and trailing whitespace. */
const reTrim = /^\\\\s+|\\\\s+$/g

/** Used to detect bad signed hexadecimal string values. */
const reIsBadHex = /^[-+]0x[0-9a-f]+$/i

/** Used to detect binary string values. */
const reIsBinary = /^0b[01]+$/i

/** Used to detect octal string values. */
const reIsOctal = /^0o[0-7]+$/i

/** Built-in method references without a dependency on \`root\`. */
const freeParseInt = parseInt

/**
 * Converts \`value\` to a number.
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @see isInteger, toInteger, isNumber
 * @example
 *
 * toNumber(3.2)
 * // => 3.2
 *
 * toNumber(Number.MIN_VALUE)
 * // => 5e-324
 *
 * toNumber(Infinity)
 * // => Infinity
 *
 * toNumber('3.2')
 * // => 3.2
 */
function toNumber(value: any): number {
  if (typeof value == 'number') {
    return value
  }
  if (isSymbol(value)) {
    return NAN
  }
  if (isObject(value)) {
    const other = typeof value.valueOf == 'function' ? value.valueOf() : value
    value = isObject(other) ? \`\${other}\` : other
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value
  }
  value = value.replace(reTrim, '')
  const isBinary = reIsBinary.test(value)
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value)
}

export default toNumber
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: toPath.ts 1`] = `
"import map from './map.js'
import copyArray from './.internal/copyArray.js'
import isSymbol from './isSymbol.js'
import stringToPath from './.internal/stringToPath.js'
import toKey from './.internal/toKey.js'

/**
 * Converts \`value\` to a property path array.
 *
 * @since 4.0.0
 * @category Util
 * @param {*} value The value to convert.
 * @returns {Array} Returns the new property path array.
 * @example
 *
 * toPath('a.b.c')
 * // => ['a', 'b', 'c']
 *
 * toPath('a[0].b.c')
 * // => ['a', '0', 'b', 'c']
 */
function toPath(value: any): any[] {
  if (Array.isArray(value)) {
    return map(value, toKey)
  }
  return isSymbol(value) ? [value] : copyArray(stringToPath(value))
}

export default toPath
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: toPlainObject.ts 1`] = `
"/**
 * Converts \`value\` to a plain object flattening inherited enumerable string
 * keyed properties of \`value\` to own properties of the plain object.
 *
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2
 * }
 *
 * Foo.prototype.c = 3
 *
 * assign({ 'a': 1 }, new Foo)
 * // => { 'a': 1, 'b': 2 }
 *
 * assign({ 'a': 1 }, toPlainObject(new Foo))
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value: any): Object {
  value = Object(value)
  const result = {}
  for (const key in value) {
    result[key] = value[key]
  }
  return result
}

export default toPlainObject
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: toSafeInteger.ts 1`] = `
"import toInteger from './toInteger.js'

/** Used as references for various \`Number\` constants. */
const MAX_SAFE_INTEGER = 9007199254740991

/**
 * Converts \`value\` to a safe integer. A safe integer can be compared and
 * represented correctly.
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * toSafeInteger(3.2)
 * // => 3
 *
 * toSafeInteger(Number.MIN_VALUE)
 * // => 0
 *
 * toSafeInteger(Infinity)
 * // => 9007199254740991
 *
 * toSafeInteger('3.2')
 * // => 3
 */
function toSafeInteger(value: any): number {
  if (!value) {
    return value === 0 ? value : 0
  }
  value = toInteger(value)
  if (value < -MAX_SAFE_INTEGER) {
    return -MAX_SAFE_INTEGER
  }
  if (value > MAX_SAFE_INTEGER) {
    return MAX_SAFE_INTEGER
  }
  return value
}

export default toSafeInteger
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: toString.ts 1`] = `
"import map from './map.js'
import isSymbol from './isSymbol.js'

/** Used as references for various \`Number\` constants. */
const INFINITY = 1 / 0

/** Used to convert symbols to primitives and strings. */
const symbolToString = Symbol.prototype.toString

/**
 * Converts \`value\` to a string. An empty string is returned for \`null\`
 * and \`undefined\` values. The sign of \`-0\` is preserved.
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * toString(null)
 * // => ''
 *
 * toString(-0)
 * // => '-0'
 *
 * toString([1, 2, 3])
 * // => '1,2,3'
 */
function toString(value: any): string {
  if (value == null) {
    return ''
  }
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value
  }
  if (Array.isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return \`\${map(value, (other: any) => other == null ? other : toString(other))}\`;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : ''
  }
  const result = \`\${value}\`
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result
}

export default toString
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: transform.ts 1`] = `
"import arrayEach from './.internal/arrayEach.js'
import baseForOwn from './.internal/baseForOwn.js'
import isBuffer from './isBuffer.js'
import isObject from './isObject.js'
import isTypedArray from './isTypedArray.js'

/**
 * An alternative to \`reduce\` this method transforms \`object\` to a new
 * \`accumulator\` object which is the result of running each of its own
 * enumerable string keyed properties thru \`iteratee\`, with each invocation
 * potentially mutating the \`accumulator\` object. If \`accumulator\` is not
 * provided, a new object with the same \`[[Prototype]]\` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning \`false\`.
 *
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @see reduce, reduceRight
 * @example
 *
 * transform([2, 3, 4], (result, n) => {
 *   result.push(n *= n)
 *   return n % 2 == 0
 * }, [])
 * // => [4, 9]
 *
 * transform({ 'a': 1, 'b': 2, 'c': 1 }, (result, value, key) => {
 *   (result[value] || (result[value] = [])).push(key)
 * }, {})
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */
function transform(object: Object, iteratee: Function, accumulator: any): any {
  const isArr = Array.isArray(object)
  const isArrLike = isArr || isBuffer(object) || isTypedArray(object)

  if (accumulator == null) {
    const Ctor = object && object.constructor
    if (isArrLike) {
      accumulator = isArr ? new Ctor : []
    }
    else if (isObject(object)) {
      accumulator = typeof Ctor == 'function'
        ? Object.create(Object.getPrototypeOf(object))
        : {}
    }
    else {
      accumulator = {}
    }
  }
  (isArrLike ? arrayEach : baseForOwn)(object, (value, index, object) =>
    iteratee(accumulator, value, index, object))
  return accumulator
}

export default transform
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: trim.ts 1`] = `
"import castSlice from './.internal/castSlice.js'
import charsEndIndex from './.internal/charsEndIndex.js'
import charsStartIndex from './.internal/charsStartIndex.js'
import stringToArray from './.internal/stringToArray.js'

/**
 * Removes leading and trailing whitespace or specified characters from \`string\`.
 *
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @returns {string} Returns the trimmed string.
 * @see trimEnd, trimStart
 * @example
 *
 * trim('  abc  ')
 * // => 'abc'
 *
 * trim('-_-abc-_-', '_-')
 * // => 'abc'
 */
function trim(string: string, chars: string): string {
  if (string && chars === undefined) {
    return string.trim()
  }
  if (!string || !chars) {
    return string
  }
  const strSymbols = stringToArray(string)
  const chrSymbols = stringToArray(chars)
  const start = charsStartIndex(strSymbols, chrSymbols)
  const end = charsEndIndex(strSymbols, chrSymbols) + 1

  return castSlice(strSymbols, start, end).join('')
}

export default trim
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: trimEnd.ts 1`] = `
"import castSlice from './.internal/castSlice.js'
import charsEndIndex from './.internal/charsEndIndex.js'
import stringToArray from './.internal/stringToArray.js'

const methodName = ''.trimRight ? 'trimRight': 'trimEnd'

/**
 * Removes trailing whitespace or specified characters from \`string\`.
 *
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @returns {string} Returns the trimmed string.
 * @see trim, trimStart
 * @example
 *
 * trimEnd('  abc  ')
 * // => '  abc'
 *
 * trimEnd('-_-abc-_-', '_-')
 * // => '-_-abc'
 */
function trimEnd(string: string, chars: string): string {
  if (string && chars === undefined) {
    return string[methodName]()
  }
  if (!string || !chars) {
    return string
  }
  const strSymbols = stringToArray(string)
  const end = charsEndIndex(strSymbols, stringToArray(chars)) + 1
  return castSlice(strSymbols, 0, end).join('')
}

export default trimEnd
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: trimStart.ts 1`] = `
"import castSlice from './.internal/castSlice.js'
import charsStartIndex from './.internal/charsStartIndex.js'
import stringToArray from './.internal/stringToArray.js'

const methodName =  ''.trimLeft ? 'trimLeft' : 'trimStart'

/**
 * Removes leading whitespace or specified characters from \`string\`.
 *
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @returns {string} Returns the trimmed string.
 * @see trim, trimEnd
 * @example
 *
 * trimStart('  abc  ')
 * // => 'abc  '
 *
 * trimStart('-_-abc-_-', '_-')
 * // => 'abc-_-'
 */
function trimStart(string: string, chars: string): string {
  if (string && chars === undefined) {
    return string[methodName]()
  }
  if (!string || !chars) {
    return string
  }
  const strSymbols = stringToArray(string)
  const start = charsStartIndex(strSymbols, stringToArray(chars))
  return castSlice(strSymbols, start).join('')
}

export default trimStart
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: truncate.ts 1`] = `
"import baseToString from './.internal/baseToString.js'
import castSlice from './.internal/castSlice.js'
import hasUnicode from './.internal/hasUnicode.js'
import isObject from './isObject.js'
import isRegExp from './isRegExp.js'
import stringSize from './.internal/stringSize.js'
import stringToArray from './.internal/stringToArray.js'

/** Used as default options for \`truncate\`. */
const DEFAULT_TRUNC_LENGTH = 30
const DEFAULT_TRUNC_OMISSION = '...'

/** Used to match \`RegExp\` flags from their coerced string values. */
const reFlags = /\\\\w*$/

/**
 * Truncates \`string\` if it's longer than the given maximum string length.
 * The last characters of the truncated string are replaced with the omission
 * string which defaults to \\"...\\".
 *
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to truncate.
 * @param {Object} [options={}] The options object.
 * @param {number} [options.length=30] The maximum string length.
 * @param {string} [options.omission='...'] The string to indicate text is omitted.
 * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
 * @returns {string} Returns the truncated string.
 * @see replace
 * @example
 *
 * truncate('hi-diddly-ho there, neighborino')
 * // => 'hi-diddly-ho there, neighbo...'
 *
 * truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': ' '
 * })
 * // => 'hi-diddly-ho there,...'
 *
 * truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': /,? +/
 * })
 * // => 'hi-diddly-ho there...'
 *
 * truncate('hi-diddly-ho there, neighborino', {
 *   'omission': ' [...]'
 * })
 * // => 'hi-diddly-ho there, neig [...]'
 */
function truncate(string: string, options: Object): string {
  let separator
  let length = DEFAULT_TRUNC_LENGTH
  let omission = DEFAULT_TRUNC_OMISSION

  if (isObject(options)) {
    separator = 'separator' in options ? options.separator : separator
    length = 'length' in options ? options.length : length
    omission = 'omission' in options ? baseToString(options.omission) : omission
  }
  let strSymbols
  let strLength = string.length
  if (hasUnicode(string)) {
    strSymbols = stringToArray(string)
    strLength = strSymbols.length
  }
  if (length >= strLength) {
    return string
  }
  let end = length - stringSize(omission)
  if (end < 1) {
    return omission
  }
  let result = strSymbols
    ? castSlice(strSymbols, 0, end).join('')
    : string.slice(0, end)

  if (separator === undefined) {
    return result + omission
  }
  if (strSymbols) {
    end += (result.length - end)
  }
  if (isRegExp(separator)) {
    if (string.slice(end).search(separator)) {
      let match
      let newEnd
      const substring = result

      if (!separator.global) {
        separator = RegExp(separator.source, \`\${reFlags.exec(separator) || ''}g\`)
      }
      separator.lastIndex = 0
      while ((match = separator.exec(substring))) {
        newEnd = match.index
      }
      result = result.slice(0, newEnd === undefined ? end : newEnd)
    }
  } else if (string.indexOf(baseToString(separator), end) != end) {
    const index = result.lastIndexOf(separator)
    if (index > -1) {
      result = result.slice(0, index)
    }
  }
  return result + omission
}

export default truncate
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: unescape.ts 1`] = `
"/** Used to map HTML entities to characters. */
const htmlUnescapes = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '\\"',
  '&#39;': \\"'\\"
}

/** Used to match HTML entities and HTML characters. */
const reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g
const reHasEscapedHtml = RegExp(reEscapedHtml.source)

/**
 * The inverse of \`escape\`this method converts the HTML entities
 * \`&amp;\`, \`&lt;\`, \`&gt;\`, \`&quot;\` and \`&#39;\` in \`string\` to
 * their corresponding characters.
 *
 * **Note:** No other HTML entities are unescaped. To unescape additional
 * HTML entities use a third-party library like [_he_](https://mths.be/he).
 *
 * @since 0.6.0
 * @category String
 * @param {string} [string=''] The string to unescape.
 * @returns {string} Returns the unescaped string.
 * @see escape, escapeRegExp
 * @example
 *
 * unescape('fred, barney, &amp; pebbles')
 * // => 'fred, barney, & pebbles'
 */
function unescape(string: string): string {
  return (string && reHasEscapedHtml.test(string))
    ? string.replace(reEscapedHtml, (entity) => htmlUnescapes[entity])
    : string
}

export default unescape
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: union.ts 1`] = `
"import baseFlatten from './.internal/baseFlatten.js'
import baseUniq from './.internal/baseUniq.js'
import isArrayLikeObject from './isArrayLikeObject.js'

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [\`SameValueZero\`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @see difference, unionBy, unionWith, without, xor, xorBy
 * @example
 *
 * union([2, 3], [1, 2])
 * // => [2, 3, 1]
 */
function union(...arrays: any[][]): any[] {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true))
}

export default union
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: unionBy.ts 1`] = `
"import baseFlatten from './.internal/baseFlatten.js'
import baseUniq from './.internal/baseUniq.js'
import isArrayLikeObject from './isArrayLikeObject.js'
import last from './last.js'

/**
 * This method is like \`union\` except that it accepts \`iteratee\` which is
 * invoked for each element of each \`arrays\` to generate the criterion by
 * which uniqueness is computed. Result values are chosen from the first
 * array in which the value occurs. The iteratee is invoked with one argument:
 * (value).
 *
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {Array} Returns the new array of combined values.
 * @see difference, union, unionWith, without, xor, xorBy
 * @example
 *
 * unionBy([2.1], [1.2, 2.3], Math.floor)
 * // => [2.1, 1.2]
 */
function unionBy(...arrays: any[][]): any[] {
  let iteratee = last(arrays)
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined
  }
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), iteratee)
}

export default unionBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: unionWith.ts 1`] = `
"import baseFlatten from './.internal/baseFlatten.js'
import baseUniq from './.internal/baseUniq.js'
import isArrayLikeObject from './isArrayLikeObject.js'
import last from './last.js'

/**
 * This method is like \`union\` except that it accepts \`comparator\` which
 * is invoked to compare elements of \`arrays\`. Result values are chosen from
 * the first array in which the value occurs. The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of combined values.
 * @see difference, union, unionBy, without, xor, xorBy
 * @example
 *
 * const objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 * const others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }]
 *
 * unionWith(objects, others, isEqual)
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 */
function unionWith(...arrays: any[][]): any[] {
  let comparator = last(arrays)
  comparator = typeof comparator == 'function' ? comparator : undefined
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator)
}

export default unionWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: uniq.ts 1`] = `
"import baseUniq from './.internal/baseUniq.js'

/**
 * Creates a duplicate-free version of an array, using
 * [\`SameValueZero\`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @see uniqBy, uniqWith
 * @example
 *
 * uniq([2, 1, 2])
 * // => [2, 1]
 */
function uniq(array: any[]): any[] {
  return (array != null && array.length)
    ? baseUniq(array)
    : []
}

export default uniq
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: uniqBy.ts 1`] = `
"import baseUniq from './.internal/baseUniq.js'

/**
 * This method is like \`uniq\` except that it accepts \`iteratee\` which is
 * invoked for each element in \`array\` to generate the criterion by which
 * uniqueness is computed. The order of result values is determined by the
 * order they occur in the array. The iteratee is invoked with one argument:
 * (value).
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @see uniq, uniqWith
 * @example
 *
 * uniqBy([2.1, 1.2, 2.3], Math.floor)
 * // => [2.1, 1.2]
 */
function uniqBy(array: any[], iteratee: Function): any[] {
  return (array != null && array.length)
    ? baseUniq(array, iteratee)
    : []
}

export default uniqBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: uniqWith.ts 1`] = `
"import baseUniq from './.internal/baseUniq.js'

/**
 * This method is like \`uniq\` except that it accepts \`comparator\` which
 * is invoked to compare elements of \`array\`. The order of result values is
 * determined by the order they occur in the array. The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @see uniq, uniqBy
 * @example
 *
 * const objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }]
 *
 * uniqWith(objects, isEqual)
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */
function uniqWith(array: any[], comparator: Function): any[] {
  comparator = typeof comparator == 'function' ? comparator : undefined
  return (array != null && array.length)
    ? baseUniq(array, undefined, comparator)
    : []
}

export default uniqWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: uniqueId.ts 1`] = `
"/** Used to generate unique IDs. */
const idCounter = {}

/**
 * Generates a unique ID. If \`prefix\` is given, the ID is appended to it.
 *
 * @since 0.1.0
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @see random
 * @example
 *
 * uniqueId('contact_')
 * // => 'contact_104'
 *
 * uniqueId()
 * // => '105'
 */
function uniqueId(prefix = '$lodash$'): string {
  if (!idCounter[prefix]) {
    idCounter[prefix] = 0
  }

  const id =++idCounter[prefix]
  if (prefix === '$lodash$') {
    return \`\${id}\`
  }

  return \`\${prefix + id}\`
}

export default uniqueId
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: unset.ts 1`] = `
"import baseUnset from './.internal/baseUnset.js'

/**
 * Removes the property at \`path\` of \`object\`.
 *
 * **Note:** This method mutates \`object\`.
 *
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to unset.
 * @returns {boolean} Returns \`true\` if the property is deleted, else \`false\`.
 * @see get, has, set
 * @example
 *
 * const object = { 'a': [{ 'b': { 'c': 7 } }] }
 * unset(object, 'a[0].b.c')
 * // => true
 *
 * console.log(object)
 * // => { 'a': [{ 'b': {} }] }
 *
 * unset(object, ['a', '0', 'b', 'c'])
 * // => true
 *
 * console.log(object)
 * // => { 'a': [{ 'b': {} }] }
 */
function unset(object: Object, path: any[] | string): boolean {
  return object == null ? true : baseUnset(object, path)
}

export default unset
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: unzip.ts 1`] = `
"import filter from './filter.js'
import map from './map.js'
import baseProperty from './.internal/baseProperty.js'
import isArrayLikeObject from './isArrayLikeObject.js'

/**
 * This method is like \`zip\` except that it accepts an array of grouped
 * elements and creates an array regrouping the elements to their pre-zip
 * configuration.
 *
 * @since 1.2.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @returns {Array} Returns the new array of regrouped elements.
 * @see unzipWith, zip, zipObject, zipObjectDeep, zipWith
 * @example
 *
 * const zipped = zip(['a', 'b'], [1, 2], [true, false])
 * // => [['a', 1, true], ['b', 2, false]]
 *
 * unzip(zipped)
 * // => [['a', 'b'], [1, 2], [true, false]]
 */
function unzip(array: any[]): any[] {
  if (!(array != null && array.length)) {
    return []
  }
  let length = 0
  array = filter(array, (group) => {
    if (isArrayLikeObject(group)) {
      length = Math.max(group.length, length)
      return true
    }
  })
  let index = -1
  const result = new Array(length)
  while (++index < length) {
    result[index] = map(array, baseProperty(index))
  }
  return result
}

export default unzip
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: unzipWith.ts 1`] = `
"import map from './map.js'
import unzip from './unzip.js'

/**
 * This method is like \`unzip\` except that it accepts \`iteratee\` to specify
 * how regrouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @since 3.8.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @param {Function} iteratee The function to combine
 *  regrouped values.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * const zipped = zip([1, 2], [10, 20], [100, 200])
 * // => [[1, 10, 100], [2, 20, 200]]
 *
 * unzipWith(zipped, add)
 * // => [3, 30, 300]
 */
function unzipWith(array: any[], iteratee: Function): any[] {
  if (!(array != null && array.length)) {
    return []
  }
  const result = unzip(array)
  return map(result, (group) => iteratee.apply(undefined, group))
}

export default unzipWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: update.ts 1`] = `
"import baseUpdate from './.internal/baseUpdate.js'

/**
 * This method is like \`set\` except that it accepts \`updater\` to produce the
 * value to set. Use \`updateWith\` to customize \`path\` creation. The \`updater\`
 * is invoked with one argument: (value).
 *
 * **Note:** This method mutates \`object\`.
 *
 * @since 4.6.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {Function} updater The function to produce the updated value.
 * @returns {Object} Returns \`object\`.
 * @example
 *
 * const object = { 'a': [{ 'b': { 'c': 3 } }] }
 *
 * update(object, 'a[0].b.c', n => n * n)
 * console.log(object.a[0].b.c)
 * // => 9
 *
 * update(object, 'x[0].y.z', n => n ? n + 1 : 0)
 * console.log(object.x[0].y.z)
 * // => 0
 */
function update(object: Object, path: any[] | string, updater: Function): Object {
  return object == null ? object : baseUpdate(object, path, updater)
}

export default update
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: updateWith.ts 1`] = `
"import baseUpdate from './.internal/baseUpdate.js'

/**
 * This method is like \`update\` except that it accepts \`customizer\` which is
 * invoked to produce the objects of \`path\`. If \`customizer\` returns \`undefined\`
 * path creation is handled by the method instead. The \`customizer\` is invoked
 * with three arguments: (nsValue, key, nsObject).
 *
 * **Note:** This method mutates \`object\`.
 *
 * @since 4.6.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {Function} updater The function to produce the updated value.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns \`object\`.
 * @example
 *
 * const object = {}
 *
 * updateWith(object, '[0][1]', () => 'a', Object)
 * // => { '0': { '1': 'a' } }
 */
function updateWith(
 object: Object,
 path: any[] | string,
 updater: Function,
 customizer: Function
): Object {
  customizer = typeof customizer == 'function' ? customizer : undefined
  return object == null ? object : baseUpdate(object, path, updater, customizer)
}

export default updateWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: upperCase.ts 1`] = `
"import words from './words.js'

/**
 * Converts \`string\`, as space separated words, to upper case.
 *
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the upper cased string.
 * @see camelCase, kebabCase, lowerCase, snakeCase, startCase, upperFirst
 * @example
 *
 * upperCase('--foo-bar')
 * // => 'FOO BAR'
 *
 * upperCase('fooBar')
 * // => 'FOO BAR'
 *
 * upperCase('__foo_bar__')
 * // => 'FOO BAR'
 */
const upperCase = (string) => (
  words(\`\${string}\`.replace(/['\\\\u2019]/g, '')).reduce((result, word, index) => (
    result + (index ? ' ' : '') + word.toUpperCase()
  ), '')
)

export default upperCase
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: upperFirst.ts 1`] = `
"import createCaseFirst from './.internal/createCaseFirst.js'

/**
 * Converts the first character of \`string\` to upper case.
 *
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @see camelCase, kebabCase, lowerCase, snakeCase, startCase, upperCase
 * @example
 *
 * upperFirst('fred')
 * // => 'Fred'
 *
 * upperFirst('FRED')
 * // => 'FRED'
 */
const upperFirst = createCaseFirst('toUpperCase')

export default upperFirst
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: values.ts 1`] = `
"import baseValues from './.internal/baseValues.js'
import keys from './keys.js'

/**
 * Creates an array of the own enumerable string keyed property values of \`object\`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @since 0.1.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @see keys, valuesIn
 * @example
 *
 * function Foo() {
 *   this.a = 1
 *   this.b = 2
 * }
 *
 * Foo.prototype.c = 3
 *
 * values(new Foo)
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * values('hi')
 * // => ['h', 'i']
 */
function values(object: Object): any[] {
  return object == null ? [] : baseValues(object, keys(object))
}

export default values
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: without.ts 1`] = `
"import baseDifference from './.internal/baseDifference.js'
import isArrayLikeObject from './isArrayLikeObject.js'

/**
 * Creates an array excluding all given values using
 * [\`SameValueZero\`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike \`pull\`, this method returns a new array.
 *
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see difference, union, unionBy, unionWith, xor, xorBy, xorWith
 * @example
 *
 * without([2, 1, 2, 3], 1, 2)
 * // => [3]
 */
function without(array: any[], ...values: any[]): any[] {
  return isArrayLikeObject(array) ? baseDifference(array, values) : []
}

export default without
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: words.ts 1`] = `
"import unicodeWords from './.internal/unicodeWords.js'

const asciiWords = RegExp.prototype.exec.bind(
  /[^\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\x7f]+/g
)

const hasUnicodeWord = RegExp.prototype.test.bind(
  /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/
)

/**
 * Splits \`string\` into an array of its words.
 *
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @returns {Array} Returns the words of \`string\`.
 * @example
 *
 * words('fred, barney, & pebbles')
 * // => ['fred', 'barney', 'pebbles']
 *
 * words('fred, barney, & pebbles', /[^, ]+/g)
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string: string, pattern: RegExp | string): any[] {
  if (pattern === undefined) {
    const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string)
    return result || []
  }
  return string.match(pattern) || []
}

export default words
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: xor.ts 1`] = `
"import baseXor from './.internal/baseXor.js'
import isArrayLikeObject from './isArrayLikeObject.js'

/**
 * Creates an array of unique values that is the
 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
 * of the given arrays. The order of result values is determined by the order
 * they occur in the arrays.
 *
 * @since 2.4.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of filtered values.
 * @see difference, union, unionBy, unionWith, without, xorBy, xorWith
 * @example
 *
 * xor([2, 1], [2, 3])
 * // => [1, 3]
 */
function xor(...arrays: any[][]): any[] {
  return baseXor(arrays.filter(isArrayLikeObject))
}

export default xor
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: xorBy.ts 1`] = `
"import baseXor from './.internal/baseXor.js'
import isArrayLikeObject from './isArrayLikeObject.js'
import last from './last.js'

/**
 * This method is like \`xor\` except that it accepts \`iteratee\` which is
 * invoked for each element of each \`arrays\` to generate the criterion by
 * which they're compared. The order of result values is determined
 * by the order they occur in the arrays. The iteratee is invoked with one
 * argument: (value).
 *
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} iteratee The iteratee invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @see difference, union, unionBy, unionWith, without, xor, xorWith
 * @example
 *
 * xorBy([2.1, 1.2], [2.3, 3.4], Math.floor)
 * // => [1.2, 3.4]
 */
function xorBy(...arrays: any[][]): any[] {
  let iteratee = last(arrays)
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined
  }
  return baseXor(arrays.filter(isArrayLikeObject), iteratee)
}

export default xorBy
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: xorWith.ts 1`] = `
"import baseXor from './.internal/baseXor.js'
import isArrayLikeObject from './isArrayLikeObject.js'
import last from './last.js'

/**
 * This method is like \`xor\` except that it accepts \`comparator\` which is
 * invoked to compare elements of \`arrays\`. The order of result values is
 * determined by the order they occur in the arrays. The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @see difference, union, unionBy, unionWith, without, xor, xorBy
 * @example
 *
 * const objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 * const others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }]
 *
 * xorWith(objects, others, isEqual)
 * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 */
function xorWith(...arrays: any[][]): any[] {
  let comparator = last(arrays)
  comparator = typeof comparator == 'function' ? comparator : undefined
  return baseXor(arrays.filter(isArrayLikeObject), undefined, comparator)
}

export default xorWith
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: zip.ts 1`] = `
"import unzip from './unzip.js'

/**
 * Creates an array of grouped elements, the first of which contains the
 * first elements of the given arrays, the second of which contains the
 * second elements of the given arrays, and so on.
 *
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @returns {Array} Returns the new array of grouped elements.
 * @see unzip, unzipWith, zipObject, zipObjectDeep, zipWith
 * @example
 *
 * zip(['a', 'b'], [1, 2], [true, false])
 * // => [['a', 1, true], ['b', 2, false]]
 */
function zip(...arrays: any[][]): any[] {
  return unzip(arrays)
}

export default zip
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: zipObject.ts 1`] = `
"import assignValue from './.internal/assignValue.js'
import baseZipObject from './.internal/baseZipObject.js'

/**
 * This method is like \`fromPairs\` except that it accepts two arrays,
 * one of property identifiers and one of corresponding values.
 *
 * @since 0.4.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @see unzip, unzipWith, zip, zipObjectDeep, zipWith
 * @example
 *
 * zipObject(['a', 'b'], [1, 2])
 * // => { 'a': 1, 'b': 2 }
 */
function zipObject(props: any[], values: any[]): Object {
  return baseZipObject(props || [], values || [], assignValue)
}

export default zipObject
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: zipObjectDeep.ts 1`] = `
"import baseSet from './.internal/baseSet.js'
import baseZipObject from './.internal/baseZipObject.js'

/**
 * This method is like \`zipObject\` except that it supports property paths.
 *
 * @since 4.1.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @see unzip, unzipWith, zip, zipObject, zipWith
 * @example
 *
 * zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2])
 * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
 */
function zipObjectDeep(props: any[], values: any[]): Object {
  return baseZipObject(props || [], values || [], baseSet)
}

export default zipObjectDeep
"
`;

exports[`E2E: lodash transforms all lodash methods to TypeScript: zipWith.ts 1`] = `
"import unzipWith from './unzipWith.js'

/**
 * This method is like \`zip\` except that it accepts \`iteratee\` to specify
 * how grouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @since 3.8.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @param {Function} iteratee The function to combine
 *  grouped values.
 * @returns {Array} Returns the new array of grouped elements.
 * @see unzip, unzipWith, zip, zipObject, zipObjectDeep, zipWith
 * @example
 *
 * zipWith([1, 2], [10, 20], [100, 200], (a, b, c) => a + b + c)
 * // => [111, 222]
 */
function zipWith(...arrays: any[][]): any[] {
  const length = arrays.length
  let iteratee = length > 1 ? arrays[length - 1] : undefined
  iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined
  return unzipWith(arrays, iteratee)
}

export default zipWith
"
`;

exports[`E2E: lodash transforms the clamp method to AssemblyScript 1`] = `
Object {
  "data": Array [
    47,
    42,
    42,
    10,
    32,
    42,
    32,
    67,
    108,
    97,
    109,
    112,
    115,
    32,
    96,
    110,
    117,
    109,
    98,
    101,
    114,
    96,
    32,
    119,
    105,
    116,
    104,
    105,
    110,
    32,
    116,
    104,
    101,
    32,
    105,
    110,
    99,
    108,
    117,
    115,
    105,
    118,
    101,
    32,
    96,
    108,
    111,
    119,
    101,
    114,
    96,
    32,
    97,
    110,
    100,
    32,
    96,
    117,
    112,
    112,
    101,
    114,
    96,
    32,
    98,
    111,
    117,
    110,
    100,
    115,
    46,
    10,
    32,
    42,
    10,
    32,
    42,
    32,
    64,
    115,
    105,
    110,
    99,
    101,
    32,
    52,
    46,
    48,
    46,
    48,
    10,
    32,
    42,
    32,
    64,
    99,
    97,
    116,
    101,
    103,
    111,
    114,
    121,
    32,
    78,
    117,
    109,
    98,
    101,
    114,
    10,
    32,
    42,
    32,
    64,
    112,
    97,
    114,
    97,
    109,
    32,
    123,
    110,
    117,
    109,
    98,
    101,
    114,
    125,
    32,
    110,
    117,
    109,
    98,
    101,
    114,
    32,
    84,
    104,
    101,
    32,
    110,
    117,
    109,
    98,
    101,
    114,
    32,
    116,
    111,
    32,
    99,
    108,
    97,
    109,
    112,
    46,
    10,
    32,
    42,
    32,
    64,
    112,
    97,
    114,
    97,
    109,
    32,
    123,
    110,
    117,
    109,
    98,
    101,
    114,
    125,
    32,
    108,
    111,
    119,
    101,
    114,
    32,
    84,
    104,
    101,
    32,
    108,
    111,
    119,
    101,
    114,
    32,
    98,
    111,
    117,
    110,
    100,
    46,
    10,
    32,
    42,
    32,
    64,
    112,
    97,
    114,
    97,
    109,
    32,
    123,
    110,
    117,
    109,
    98,
    101,
    114,
    125,
    32,
    117,
    112,
    112,
    101,
    114,
    32,
    84,
    104,
    101,
    32,
    117,
    112,
    112,
    101,
    114,
    32,
    98,
    111,
    117,
    110,
    100,
    46,
    10,
    32,
    42,
    32,
    64,
    114,
    101,
    116,
    117,
    114,
    110,
    115,
    32,
    123,
    110,
    117,
    109,
    98,
    101,
    114,
    125,
    32,
    82,
    101,
    116,
    117,
    114,
    110,
    115,
    32,
    116,
    104,
    101,
    32,
    99,
    108,
    97,
    109,
    112,
    101,
    100,
    32,
    110,
    117,
    109,
    98,
    101,
    114,
    46,
    10,
    32,
    42,
    32,
    64,
    101,
    120,
    97,
    109,
    112,
    108,
    101,
    10,
    32,
    42,
    10,
    32,
    42,
    32,
    99,
    108,
    97,
    109,
    112,
    40,
    45,
    49,
    48,
    44,
    32,
    45,
    53,
    44,
    32,
    53,
    41,
    10,
    32,
    42,
    32,
    47,
    47,
    32,
    61,
    62,
    32,
    45,
    53,
    10,
    32,
    42,
    10,
    32,
    42,
    32,
    99,
    108,
    97,
    109,
    112,
    40,
    49,
    48,
    44,
    32,
    45,
    53,
    44,
    32,
    53,
    41,
    10,
    32,
    42,
    32,
    47,
    47,
    32,
    61,
    62,
    32,
    53,
    10,
    32,
    42,
    47,
    10,
    101,
    120,
    112,
    111,
    114,
    116,
    32,
    102,
    117,
    110,
    99,
    116,
    105,
    111,
    110,
    32,
    99,
    108,
    97,
    109,
    112,
    40,
    110,
    117,
    109,
    98,
    101,
    114,
    58,
    32,
    102,
    54,
    52,
    44,
    32,
    108,
    111,
    119,
    101,
    114,
    58,
    32,
    102,
    54,
    52,
    44,
    32,
    117,
    112,
    112,
    101,
    114,
    58,
    32,
    102,
    54,
    52,
    41,
    58,
    32,
    102,
    54,
    52,
    32,
    123,
    10,
    32,
    32,
    110,
    117,
    109,
    98,
    101,
    114,
    32,
    61,
    32,
    43,
    110,
    117,
    109,
    98,
    101,
    114,
    10,
    32,
    32,
    108,
    111,
    119,
    101,
    114,
    32,
    61,
    32,
    43,
    108,
    111,
    119,
    101,
    114,
    10,
    32,
    32,
    117,
    112,
    112,
    101,
    114,
    32,
    61,
    32,
    43,
    117,
    112,
    112,
    101,
    114,
    10,
    32,
    32,
    108,
    111,
    119,
    101,
    114,
    32,
    61,
    32,
    108,
    111,
    119,
    101,
    114,
    32,
    61,
    61,
    61,
    32,
    108,
    111,
    119,
    101,
    114,
    32,
    63,
    32,
    108,
    111,
    119,
    101,
    114,
    32,
    58,
    32,
    48,
    10,
    32,
    32,
    117,
    112,
    112,
    101,
    114,
    32,
    61,
    32,
    117,
    112,
    112,
    101,
    114,
    32,
    61,
    61,
    61,
    32,
    117,
    112,
    112,
    101,
    114,
    32,
    63,
    32,
    117,
    112,
    112,
    101,
    114,
    32,
    58,
    32,
    48,
    10,
    32,
    32,
    105,
    102,
    32,
    40,
    110,
    117,
    109,
    98,
    101,
    114,
    32,
    61,
    61,
    61,
    32,
    110,
    117,
    109,
    98,
    101,
    114,
    41,
    32,
    123,
    10,
    32,
    32,
    32,
    32,
    110,
    117,
    109,
    98,
    101,
    114,
    32,
    61,
    32,
    110,
    117,
    109,
    98,
    101,
    114,
    32,
    60,
    61,
    32,
    117,
    112,
    112,
    101,
    114,
    32,
    63,
    32,
    110,
    117,
    109,
    98,
    101,
    114,
    32,
    58,
    32,
    117,
    112,
    112,
    101,
    114,
    10,
    32,
    32,
    32,
    32,
    110,
    117,
    109,
    98,
    101,
    114,
    32,
    61,
    32,
    110,
    117,
    109,
    98,
    101,
    114,
    32,
    62,
    61,
    32,
    108,
    111,
    119,
    101,
    114,
    32,
    63,
    32,
    110,
    117,
    109,
    98,
    101,
    114,
    32,
    58,
    32,
    108,
    111,
    119,
    101,
    114,
    10,
    32,
    32,
    125,
    10,
    32,
    32,
    114,
    101,
    116,
    117,
    114,
    110,
    32,
    110,
    117,
    109,
    98,
    101,
    114,
    10,
    125,
    10,
    10,
  ],
  "type": "Buffer",
}
`;
